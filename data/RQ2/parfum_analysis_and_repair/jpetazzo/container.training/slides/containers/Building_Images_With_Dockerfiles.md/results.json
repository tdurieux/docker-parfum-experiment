{
  "startTime": 1674215315833,
  "endTime": 1674215316333,
  "originalSmells": [
    {
      "rule": "aptGetInstallUseY",
      "position": {
        "lineStart": 57,
        "lineEnd": 57,
        "columnStart": 4,
        "columnEnd": 26
      }
    },
    {
      "rule": "aptGetInstallUseNoRec",
      "position": {
        "lineStart": 57,
        "lineEnd": 57,
        "columnStart": 4,
        "columnEnd": 26
      }
    },
    {
      "rule": "aptGetUpdatePrecedesInstall",
      "position": {
        "lineStart": 57,
        "lineEnd": 57,
        "columnStart": 4,
        "columnEnd": 26
      }
    },
    {
      "rule": "ruleAptGetInstallThenRemoveAptLists",
      "position": {
        "lineStart": 57,
        "lineEnd": 57,
        "columnStart": 4,
        "columnEnd": 26
      }
    }
  ],
  "repairedSmells": [
    {
      "rule": "aptGetUpdatePrecedesInstall",
      "position": {
        "lineStart": 56,
        "lineEnd": 56,
        "columnStart": 4,
        "columnEnd": 53
      }
    }
  ],
  "repairedDockerfile": "class: title\n\n# Building Docker images with a Dockerfile\n\n![Construction site with containers](images/title-building-docker-images-with-a-dockerfile.jpg)\n\n---\n\n## Objectives\n\nWe will build a container image automatically, with a `Dockerfile`.\n\nAt the end of this lesson, you will be able to:\n\n* Write a `Dockerfile`.\n\n* Build an image from a `Dockerfile`.\n\n---\n\n## `Dockerfile` overview\n\n* A `Dockerfile` is a build recipe for a Docker image.\n\n* It contains a series of instructions telling Docker how an image is constructed.\n\n* The `docker build` command builds an image from a `Dockerfile`.\n\n---\n\n## Writing our first `Dockerfile`\n\nOur Dockerfile must be in a **new, empty directory**.\n\n1. Create a directory to hold our `Dockerfile`.\n\n```bash\n$ mkdir myimage\n```\n\n2. Create a `Dockerfile` inside this directory.\n\n```bash\n$ cd myimage\n$ vim Dockerfile\n```\n\nOf course, you can use any other editor of your choice.\n\n---\n\n## Type this into our Dockerfile...\n\n```dockerfile\nFROM ubuntu\nRUN apt-get update\nRUN apt-get install -y --no-install-recommends figlet && rm -rf /var/lib/apt/lists/*;\n```\n\n* `FROM` indicates the base image for our build.\n\n* Each `RUN` line will be executed by Docker during the build.\n\n* Our `RUN` commands **must be non-interactive.**\n  <br/>(No input can be provided to Docker during the build.)\n\n* In many cases, we will add the `-y` flag to `apt-get`.\n\n---\n\n## Build it!\n\nSave our file, then execute:\n\n```bash\n$ docker build -t figlet .\n```\n\n* `-t` indicates the tag to apply to the image.\n\n* `.` indicates the location of the *build context*.\n\nWe will talk more about the build context later.\n\nTo keep things simple for now: this is the directory where our Dockerfile is located.\n\n---\n\n## What happens when we build the image?\n\nIt depends if we're using BuildKit or not!\n\nIf there are lots of blue lines and the first line looks like this:\n```\n[+] Building 1.8s (4/6)\n```\n... then we're using BuildKit.\n\nIf the output is mostly black-and-white and the first line looks like this:\n```\nSending build context to Docker daemon  2.048kB\n```\n... then we're using the \"classic\" or \"old-style\" builder.\n\n---\n\n## To BuildKit or Not To BuildKit\n\nClassic builder:\n\n- copies the whole \"build context\" to the Docker Engine\n\n- linear (processes lines one after the other)\n\n- requires a full Docker Engine\n\nBuildKit:\n\n- only transfers parts of the \"build context\" when needed\n\n- will parallelize operations (when possible)\n\n- can run in non-privileged containers (e.g. on Kubernetes)\n\n---\n\n## With the classic builder\n\nThe output of `docker build` looks like this:\n\n.small[\n```bash\ndocker build -t figlet .\nSending build context to Docker daemon  2.048kB\nStep 1/3 : FROM ubuntu\n ---> f975c5035748\nStep 2/3 : RUN apt-get update\n ---> Running in e01b294dbffd\n(...output of the RUN command...)\nRemoving intermediate container e01b294dbffd\n ---> eb8d9b561b37\nStep 3/3 : RUN apt-get install figlet\n ---> Running in c29230d70f9b\n(...output of the RUN command...)\nRemoving intermediate container c29230d70f9b\n ---> 0dfd7a253f21\nSuccessfully built 0dfd7a253f21\nSuccessfully tagged figlet:latest\n```\n]\n\n* The output of the `RUN` commands has been omitted.\n* Let's explain what this output means.\n\n---\n\n## Sending the build context to Docker\n\n```bash\nSending build context to Docker daemon 2.048 kB\n```\n\n* The build context is the `.` directory given to `docker build`.\n\n* It is sent (as an archive) by the Docker client to the Docker daemon.\n\n* This allows to use a remote machine to build using local files.\n\n* Be careful (or patient) if that directory is big and your link is slow.\n\n* You can speed up the process with a [`.dockerignore`](https://docs.docker.com/engine/reference/builder/#dockerignore-file) file\n\n  * It tells docker to ignore specific files in the directory\n\n  * Only ignore files that you won't need in the build context!\n\n---\n\n## Executing each step\n\n```bash\nStep 2/3 : RUN apt-get update\n ---> Running in e01b294dbffd\n(...output of the RUN command...)\nRemoving intermediate container e01b294dbffd\n ---> eb8d9b561b37\n```\n\n* A container (`e01b294dbffd`) is created from the base image.\n\n* The `RUN` command is executed in this container.\n\n* The container is committed into an image (`eb8d9b561b37`).\n\n* The build container (`e01b294dbffd`) is removed.\n\n* The output of this step will be the base image for the next one.\n\n---\n\n## With BuildKit\n\n.small[\n```bash\n[+] Building 7.9s (7/7) FINISHED\n => [internal] load build definition from Dockerfile                                                 0.0s\n => => transferring dockerfile: 98B                                                                  0.0s\n => [internal] load .dockerignore                                                                    0.0s\n => => transferring context: 2B                                                                      0.0s\n => [internal] load metadata for docker.io/library/ubuntu:latest                                     1.2s\n => [1/3] FROM docker.io/library/ubuntu@sha256:cf31af331f38d1d7158470e095b132acd126a7180a54f263d386  3.2s\n => => resolve docker.io/library/ubuntu@sha256:cf31af331f38d1d7158470e095b132acd126a7180a54f263d386  0.0s\n => => sha256:cf31af331f38d1d7158470e095b132acd126a7180a54f263d386da88eb681d93 1.20kB / 1.20kB       0.0s\n => => sha256:1de4c5e2d8954bf5fa9855f8b4c9d3c3b97d1d380efe19f60f3e4107a66f5cae 943B / 943B           0.0s\n => => sha256:6a98cbe39225dadebcaa04e21dbe5900ad604739b07a9fa351dd10a6ebad4c1b 3.31kB / 3.31kB       0.0s\n => => sha256:80bc30679ac1fd798f3241208c14accd6a364cb8a6224d1127dfb1577d10554f 27.14MB / 27.14MB     2.3s\n => => sha256:9bf18fab4cfbf479fa9f8409ad47e2702c63241304c2cdd4c33f2a1633c5f85e 850B / 850B           0.5s\n => => sha256:5979309c983a2adeff352538937475cf961d49c34194fa2aab142effe19ed9c1 189B / 189B           0.4s\n => => extracting sha256:80bc30679ac1fd798f3241208c14accd6a364cb8a6224d1127dfb1577d10554f            0.7s\n => => extracting sha256:9bf18fab4cfbf479fa9f8409ad47e2702c63241304c2cdd4c33f2a1633c5f85e            0.0s\n => => extracting sha256:5979309c983a2adeff352538937475cf961d49c34194fa2aab142effe19ed9c1            0.0s\n => [2/3] RUN apt-get update                                                                         2.5s\n => [3/3] RUN apt-get install figlet                                                                 0.9s\n => exporting to image                                                                               0.1s\n => => exporting layers                                                                              0.1s\n => => writing image sha256:3b8aee7b444ab775975dfba691a72d8ac24af2756e0a024e056e3858d5a23f7c         0.0s\n => => naming to docker.io/library/figlet                                                            0.0s\n ```\n ]\n\n---\n\n## Understanding BuildKit output\n\n- BuildKit transfers the Dockerfile and the *build context*\n\n  (these are the first two `[internal]` stages)\n\n- Then it executes the steps defined in the Dockerfile\n\n  (`[1/3]`, `[2/3]`, `[3/3]`)\n\n- Finally, it exports the result of the build\n\n  (image definition + collection of layers)\n\n---\n\nclass: extra-details\n\n## BuildKit plain output\n\n- When running BuildKit in e.g. a CI pipeline, its output will be different\n\n- We can see the same output format by using `--progress=plain`\n\n---\n\n## The caching system\n\nIf you run the same build again, it will be instantaneous. Why?\n\n* After each build step, Docker takes a snapshot of the resulting image.\n\n* Before executing a step, Docker checks if it has already built the same sequence.\n\n* Docker uses the exact strings defined in your Dockerfile, so:\n\n  * `RUN apt-get install figlet cowsay`\n    <br/> is different from\n    <br/> `RUN apt-get install cowsay figlet`\n\n  * `RUN apt-get update` is not re-executed when the mirrors are updated\n\nYou can force a rebuild with `docker build --no-cache ...`.\n\n---\n\n## Running the image\n\nThe resulting image is not different from the one produced manually.\n\n```bash\n$ docker run -ti figlet\nroot@91f3c974c9a1:/# figlet hello\n _          _ _      \n| |__   ___| | | ___ \n| '_ \\ / _ \\ | |/ _ \\ \n| | | |  __/ | | (_) |\n|_| |_|\\___|_|_|\\___/\n```\n\n\nYay! ðŸŽ‰\n\n---\n\n## Using image and viewing history\n\nThe `history` command lists all the layers composing an image.\n\nFor each layer, it shows its creation time, size, and creation command.\n\nWhen an image was built with a Dockerfile, each layer corresponds to\na line of the Dockerfile.\n\n```bash\n$ docker history figlet\nIMAGE         CREATED            CREATED BY                     SIZE\nf9e8f1642759  About an hour ago  /bin/sh -c apt-get install fi  1.627 MB\n7257c37726a1  About an hour ago  /bin/sh -c apt-get update      21.58 MB\n07c86167cdc4  4 days ago         /bin/sh -c #(nop) CMD [\"/bin   0 B\n<missing>     4 days ago         /bin/sh -c sed -i 's/^#\\s*\\(   1.895 kB\n<missing>     4 days ago         /bin/sh -c echo '#!/bin/sh'    194.5 kB\n<missing>     4 days ago         /bin/sh -c #(nop) ADD file:b   187.8 MB\n```\n\n---\n\nclass: extra-details\n\n## Why `sh -c`?\n\n* On UNIX, to start a new program, we need two system calls:\n\n  - `fork()`, to create a new child process;\n\n  - `execve()`, to replace the new child process with the program to run.\n\n* Conceptually, `execve()` works like this:\n\n  `execve(program, [list, of, arguments])`\n\n* When we run a command, e.g. `ls -l /tmp`, something needs to parse the command.\n\n  (i.e. split the program and its arguments into a list.)\n\n* The shell is usually doing that.\n\n  (It also takes care of expanding environment variables and special things like `~`.)\n\n---\n\nclass: extra-details\n\n## Why `sh -c`?\n\n* When we do `RUN ls -l /tmp`, the Docker builder needs to parse the command.\n\n* Instead of implementing its own parser, it outsources the job to the shell.\n\n* That's why we see `sh -c ls -l /tmp` in that case.\n\n* But we can also do the parsing jobs ourselves.\n\n* This means passing `RUN` a list of arguments.\n\n* This is called the *exec syntax*.\n\n---\n\n## Shell syntax vs exec syntax\n\nDockerfile commands that execute something can have two forms:\n\n* plain string, or *shell syntax*:\n  <br/>`RUN apt-get install figlet`\n\n* JSON list, or *exec syntax*:\n  <br/>`RUN [\"apt-get\", \"install\", \"figlet\"]`\n\nWe are going to change our Dockerfile to see how it affects the resulting image.\n\n---\n\n## Using exec syntax in our Dockerfile\n\nLet's change our Dockerfile as follows!\n\n```dockerfile\nFROM ubuntu\nRUN apt-get update\nRUN [\"apt-get\", \"install\", \"figlet\"]\n```\n\nThen build the new Dockerfile.\n\n```bash\n$ docker build -t figlet .\n```\n\n---\n\n## History with exec syntax\n\nCompare the new history:\n\n```bash\n$ docker history figlet\nIMAGE         CREATED            CREATED BY                     SIZE\n27954bb5faaf  10 seconds ago     apt-get install figlet         1.627 MB\n7257c37726a1  About an hour ago  /bin/sh -c apt-get update      21.58 MB\n07c86167cdc4  4 days ago         /bin/sh -c #(nop) CMD [\"/bin   0 B\n<missing>     4 days ago         /bin/sh -c sed -i 's/^#\\s*\\(   1.895 kB\n<missing>     4 days ago         /bin/sh -c echo '#!/bin/sh'    194.5 kB\n<missing>     4 days ago         /bin/sh -c #(nop) ADD file:b   187.8 MB\n```\n\n* Exec syntax specifies an *exact* command to execute.\n\n* Shell syntax specifies a command to be wrapped within `/bin/sh -c \"...\"`.\n\n---\n\n## When to use exec syntax and shell syntax\n\n* shell syntax:\n\n  * is easier to write\n  * interpolates environment variables and other shell expressions\n  * creates an extra process (`/bin/sh -c ...`) to parse the string\n  * requires `/bin/sh` to exist in the container\n\n* exec syntax:\n\n  * is harder to write (and read!)\n  * passes all arguments without extra processing\n  * doesn't create an extra process\n  * doesn't require `/bin/sh` to exist in the container\n\n---\n\n## Pro-tip: the `exec` shell built-in\n\nPOSIX shells have a built-in command named `exec`.\n\n`exec` should be followed by a program and its arguments.\n\nFrom a user perspective:\n\n- it looks like the shell exits right away after the command execution,\n\n- in fact, the shell exits just *before* command execution;\n\n- or rather, the shell gets *replaced* by the command.\n\n---\n\n## Example using `exec`\n\n```dockerfile\nCMD exec figlet -f script hello\n```\n\nIn this example, `sh -c` will still be used, but\n`figlet` will be PID 1 in the container.\n\nThe shell gets replaced by `figlet` when `figlet` starts execution.\n\nThis allows to run processes as PID 1 without using JSON.\n\n???\n\n:EN:- Towards automated, reproducible builds\n:EN:- Writing our first Dockerfile\n:FR:- Rendre le processus automatique et reproductible\n:FR:- Ã‰crire son premier Dockerfile\n"
}