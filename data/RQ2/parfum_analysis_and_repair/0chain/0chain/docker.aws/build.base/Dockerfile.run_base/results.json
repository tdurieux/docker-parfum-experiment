{
  "startTime": 1674255261748,
  "endTime": 1674255262873,
  "originalSmells": [
    {
      "rule": "apkAddUseNoCache",
      "position": {
        "lineStart": 4,
        "lineEnd": 4,
        "columnStart": 4,
        "columnEnd": 16
      }
    },
    {
      "rule": "apkAddUseNoCache",
      "position": {
        "lineStart": 5,
        "lineEnd": 5,
        "columnStart": 4,
        "columnEnd": 44
      }
    },
    {
      "rule": "apkAddUseNoCache",
      "position": {
        "lineStart": 6,
        "lineEnd": 6,
        "columnStart": 4,
        "columnEnd": 38
      }
    }
  ],
  "repairedSmells": [],
  "repairedDockerfile": "#docker.aws\nARG image_tag\nFROM 0chain_build_base:${image_tag} as zchain_build_base\nFROM alpine:3.15\nRUN apk add --no-cache bash\nRUN apk add --no-cache libbz2 lz4-libs snappy zstd-libs# For RocksDB\nRUN apk add --no-cache gmp libcrypto1.1 libssl1.1# For Herumi\n\nCOPY --from=zchain_build_base \\\n                    /usr/local/lib/librocksdb.so.*.*.* \\\n                    /usr/local/lib/libmcl*.so \\\n                    /usr/local/lib/libbls*.so \\\n                    /usr/local/lib/\n\n# Following standard Unix convention, the file librocksdb.x.y is a symbolic link\n# to librocksdb.x.y.z. Unfortunately, the Docker COPY command reads through\n# symbolic links and copies the file to which they point. Additionally, there is\n# no glob syntax to specify that we want to COPY the .x.y file without also\n# copying the .x.y.z file. But since librocksdb is 25 MB, we don't want to\n# duplicate it.\n#\n# Above, we copied the .x.y.z file. Now we can manually rename it from .x.y.z\n# to .x.y.\nRUN mv /usr/local/lib/librocksdb.so* $(ls /usr/local/lib/librocksdb.so* | cut -f1-4 -d.)\n"
}