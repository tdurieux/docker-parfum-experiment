{
  "startTime": 1674248406250,
  "endTime": 1674248407229,
  "originalSmells": [
    {
      "rule": "apkAddUseNoCache",
      "position": {
        "lineStart": 103,
        "lineEnd": 103,
        "columnStart": 8,
        "columnEnd": 49
      }
    },
    {
      "rule": "apkAddUseNoCache",
      "position": {
        "lineStart": 104,
        "lineEnd": 104,
        "columnStart": 8,
        "columnEnd": 40
      }
    },
    {
      "rule": "apkAddUseNoCache",
      "position": {
        "lineStart": 296,
        "lineEnd": 296,
        "columnStart": 8,
        "columnEnd": 36
      }
    },
    {
      "rule": "apkAddUseNoCache",
      "position": {
        "lineStart": 407,
        "lineEnd": 407,
        "columnStart": 8,
        "columnEnd": 20
      }
    }
  ],
  "repairedSmells": [],
  "repairedDockerfile": "#\n# Build app\n#\n# It takes advantage of caching and parallel build support in BuildKit.\n#\n# The \"syntax\" line must be the first thing in the file, as it enables the\n# new syntax for caching, etc. see\n# https://docs.docker.com/develop/develop-images/build_enhancements/\n# https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental.md\n\nARG ELIXIR_VERSION=1.13.3\nARG OTP_VERSION=24.2\nARG NODE_VERSION=16.14.1\n\nARG ALPINE_VERSION=3.15.0\n\n# Docker registry for internal images, e.g. 123.dkr.ecr.ap-northeast-1.amazonaws.com/\n# If blank, docker.io will be used. If specified, should have a trailing slash.\nARG REGISTRY=\"\"\n# Registry for public base images, e.g. debian or alpine.\n# Public images may be mirrored into the private registry, with e.g. Skopeo\nARG PUBLIC_REGISTRY=$REGISTRY\n\nARG BUILD_IMAGE_NAME=${PUBLIC_REGISTRY}hexpm/elixir\nARG BUILD_IMAGE_TAG=${ELIXIR_VERSION}-erlang-${OTP_VERSION}-alpine-${ALPINE_VERSION}\n\nARG DEPLOY_IMAGE_NAME=${PUBLIC_REGISTRY}alpine\nARG DEPLOY_IMAGE_TAG=$ALPINE_VERSION\n\nARG INSTALL_IMAGE_NAME=$DEPLOY_IMAGE_NAME\nARG INSTALL_IMAGE_TAG=$DEPLOY_IMAGE_TAG\n\n# App name, used to name directories\nARG APP_NAME=app\n\n# Dir where app is installed\nARG APP_DIR=/app\n\n# OS user for app to run under\n# nonroot:x:65532:65532:nonroot:/home/nonroot:/usr/sbin/nologin\n# nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin\nARG APP_USER=nonroot\n# OS group that app runs under\nARG APP_GROUP=$APP_USER\n# OS numeric user and group id\nARG APP_USER_ID=65532\nARG APP_GROUP_ID=$APP_USER_ID\n\nARG LANG=C.UTF-8\n\n# By default, packages come from the APK index for the base Alpine image.\n# Package versions are consistent between builds, and we normally upgrade by\n# upgrading the Alpine version.\nARG APK_UPDATE=\":\"\nARG APK_UPGRADE=\":\"\n# If a vulnerability is fixed in packages but not yet released in an Alpine base image,\n# Then we can run update/upgrade as part of the build.\n# ARG APK_UPDATE=\"apk update\"\n# ARG APK_UPGRADE=\"apk upgrade --update-cache -a\"\n\n# ARG http_proxy\n# ARG https_proxy=$http_proxy\n\n# Build cache dirs\n# ARG MIX_HOME=/opt/mix\n# ARG HEX_HOME=/opt/hex\n# ARG XDG_CACHE_HOME=/opt/cache\n\n# Elixir release env to build\nARG MIX_ENV=prod\n\n# Name of Elixir release\nARG RELEASE=prod\n# This should match mix.exs, e.g.\n# defp releases do\n#   [\n#     prod: [\n#       include_executables_for: [:unix],\n#     ],\n#   ]\n# end\n\n# App listen port\nARG APP_PORT=4000\n\n# Create build base image with OS dependencies\nFROM ${BUILD_IMAGE_NAME}:${BUILD_IMAGE_TAG} AS build-os-deps\n    # ARG http_proxy\n    # ARG https_proxy\n\n    ARG APK_UPDATE\n    ARG APK_UPGRADE\n\n    # Install tools and libraries to build binary libraries\n    # Not necessary for a minimal Phoenix app, but likely needed\n    # See https://wiki.alpinelinux.org/wiki/Local_APK_cache for details\n    # on the local cache and need for the symlink\n    RUN --mount=type=cache,id=apk,target=/var/cache/apk \\\n        set -ex && \\\n        $APK_UPDATE && $APK_UPGRADE && \\\n        # Install build tools\n        # apk add --no-progress alpine-sdk && \\\n        apk add --no-cache --no-progress git build-base curl && \\\n        apk add --no-cache --no-progress nodejs npm && \\\n        # apk add --no-progress python3 && \\\n        # Vulnerability checking\n        curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin\n\n    # Database command line clients to check if DBs are up when performing integration tests\n    # RUN apk add --no-progress postgresql-client mysql-client\n    # RUN apk add --no-progress --no-cache curl gnupg --virtual .build-dependencies -- && \\\n    #     curl -O https://download.microsoft.com/download/e/4/e/e4e67866-dffd-428c-aac7-8d28ddafb39b/msodbcsql17_17.5.2.1-1_amd64.apk && \\\n    #     curl -O https://download.microsoft.com/download/e/4/e/e4e67866-dffd-428c-aac7-8d28ddafb39b/mssql-tools_17.5.2.1-1_amd64.apk && \\\n    #     echo y | apk add --allow-untrusted msodbcsql17_17.5.2.1-1_amd64.apk mssql-tools_17.5.2.1-1_amd64.apk && \\\n    #     apk del .build-dependencies && rm -f msodbcsql*.sig mssql-tools*.apk\n    # ENV PATH=\"/opt/mssql-tools/bin:${PATH}\"\n\n# Get Elixir deps\nFROM build-os-deps AS build-deps-get\n    # ARG http_proxy\n    # ARG https_proxy\n    ARG LANG\n    ARG MIX_ENV\n    ARG APP_DIR\n\n    WORKDIR $APP_DIR\n\n    # Get Elixir app deps\n    COPY config ./config\n    COPY mix.exs .\n    COPY mix.lock .\n\n    # Install build tools and get app deps\n    # RUN --mount=type=cache,id=hex,target=/opt/hex,sharing=locked \\\n    #     # --mount=type=cache,id=rebar,target=~/.cache/rebar3,sharing=locked \\\n    RUN mix do local.rebar --force, local.hex --force\n    RUN mix deps.get\n\n    # RUN --mount=type=cache,id=hex,target=/opt/hex,sharing=locked \\\n    #    # --mount=type=cache,target=~/.cache/rebar3,sharing=locked \\\n    RUN mix esbuild.install\n\n# Create base image for tests\nFROM build-deps-get AS test-image\n    ARG LANG\n    ARG APP_DIR\n\n    ENV LANG=$LANG \\\n        HOME=$APP_DIR \\\n        MIX_ENV=test\n\n    # ARG MIX_HOME\n    # ARG HEX_HOME\n    # ARG XDG_CACHE_HOME\n    # ENV MIX_HOME=$MIX_HOME \\\n    #     HEX_HOME=$HEX_HOME \\\n    #     XDG_CACHE_HOME=$XDG_CACHE_HOME\n\n    WORKDIR $APP_DIR\n\n    # Compile deps separately from app, improving Docker caching\n    # RUN --mount=type=cache,id=hex,target=/opt/hex,sharing=locked \\\n    #     # --mount=type=cache,id=rebar,target=~/.cache/rebar3,sharing=locked \\\n    RUN mix do local.rebar --force, local.hex --force\n    RUN mix deps.compile\n\n    # COPY --if-exists coveralls.json .formatter.exs .credo.exs dialyzer-ignore ./\n    COPY .formatter.exs ./\n\n    # Non-umbrella\n    COPY lib ./lib\n    COPY priv ./priv\n    COPY test ./test\n    COPY bin ./bin\n\n    # Umbrella\n    # COPY apps ./apps\n    # COPY priv ./priv\n\n    # RUN --mount=type=cache,id=hex,target=/opt/hex,sharing=locked \\\n    #    # --mount=type=cache,id=rebar,target=~/.cache/rebar3,sharing=locked \\\n    RUN mix compile --warnings-as-errors\n\n    # For umbrella, using `mix cmd` ensures each app is compiled in\n    # isolation https://github.com/elixir-lang/elixir/issues/9407\n    # RUN --mount=type=cache,target=~/.hex/packages/hexpm,sharing=locked \\\n    #     --mount=type=cache,target=~/.cache/rebar3,sharing=locked \\\n    #     mix cmd mix compile --warnings-as-errors\n\n# Create Elixir release\nFROM build-deps-get AS deploy-release\n    ARG APP_DIR\n    ARG RELEASE\n\n    ENV MIX_ENV=prod\n\n    WORKDIR $APP_DIR\n\n    # Doing \"mix do compile, phx.digest, release\" in a single stage is worse,\n    # because a single line of code changed causes a complete recompile.\n    # With the stages separated most of the compilation is cached.\n\n    # Compile deps separately from application for better caching\n    # RUN --mount=type=cache,id=hex,target=/opt/hex,sharing=locked \\\n    #    # --mount=type=cache,id=rebar,target=~/.cache/rebar3,sharing=locked \\\n    RUN mix deps.compile\n\n    # Compile assets the old way\n    # WORKDIR /app/assets\n    #\n    # COPY assets/package.json assets/package-lock.json ./\n    #\n    # # Cache npm cache directory as type=cache\n    # RUN --mount=type=cache,target=~/.npm,sharing=locked \\\n    #     npm --prefer-offline --no-audit --progress=false --loglevel=error ci\n    #\n    # COPY assets ./\n    #\n    # RUN --mount=type=cache,target=~/.npm,sharing=locked \\\n    #     npm run deploy\n    #\n    # Generate assets the really old way\n    # RUN --mount=type=cache,target=~/.npm,sharing=locked \\\n    #   npm install && \\\n    #   node node_modules/webpack/bin/webpack.js --mode production\n\n    # Build JS and CS with esbuild\n    COPY assets ./assets\n    COPY priv ./priv\n\n    # mix.exs: \"assets.deploy\": [\"esbuild default --minify\", \"phx.digest\"]\n    # https://hexdocs.pm/phoenix/Mix.Tasks.Phx.Digest.html\n    # RUN --mount=type=cache,id=hex,target=/opt/hex,sharing=locked \\\n    #    # --mount=type=cache,id=rebar,target=~/.cache/rebar3,sharing=locked \\\n    RUN mix assets.deploy\n\n    # Non-umbrella\n    COPY lib ./lib\n\n    # Umbrella\n    # COPY apps ./apps\n\n    # RUN --mount=type=cache,id=hex,target=/opt/hex,sharing=locked \\\n    #    # --mount=type=cache,id=rebar,target=~/.cache/rebar3,sharing=locked \\\n    RUN mix compile --warnings-as-errors\n\n    # Build release\n    COPY rel ./rel\n    # RUN --mount=type=cache,id=hex,target=/opt/hex,sharing=locked \\\n    #    # --mount=type=cache,id=rebar,target=~/.cache/rebar3,sharing=locked \\\n    RUN mix release \"$RELEASE\"\n\n# Create base image for deploy, with everything but the code release\nFROM ${DEPLOY_IMAGE_NAME}:${DEPLOY_IMAGE_TAG} AS deploy-base\n    ARG APK_UPDATE\n    ARG APK_UPGRADE\n    ARG LANG\n    ARG APP_USER\n    ARG APP_GROUP\n    ARG APP_USER_ID\n    ARG APP_GROUP_ID\n\n    ARG MIX_ENV=prod\n    ARG RELEASE\n\n    ENV LANG=$LANG\n\n    # Create OS user and group to run app under\n    # https://wiki.alpinelinux.org/wiki/Setting_up_a_new_user#adduser\n    RUN addgroup -g $APP_GROUP_ID -S \"$APP_GROUP\" && \\\n        adduser -u $APP_USER_ID -S \"$APP_USER\" -G \"$APP_GROUP\" -h \"$HOME\"\n\n    # Create app dirs\n    RUN mkdir -p \"/run/${APP_NAME}\" && \\\n        # Make dirs writable by app\n        chown -R \"${APP_USER}:${APP_GROUP}\" \\\n            # Needed for RELEASE_TMP\n            \"/run/${APP_NAME}\"\n\n    # Install Alpine libraries needed at runtime\n    # See https://wiki.alpinelinux.org/wiki/Local_APK_cache for details\n    # on the local cache and need for the symlink\n    RUN --mount=type=cache,id=apk,target=/var/cache/apk,sharing=locked \\\n        set -ex && \\\n        ln -s /var/cache/apk /etc/apk/cache && \\\n        # Upgrading ensures that we get the latest packages, but makes the build nondeterministic\n        $APK_UPDATE && $APK_UPGRADE && \\\n        # https://github.com/krallin/tini\n        # apk add tini && \\\n        # Make DNS resolution more reliable\n        # https://github.com/sourcegraph/godockerize/commit/5cf4e6d81720f2551e6a7b2b18c63d1460bbbe4e\n        # apk add bind-tools && \\\n\n        # Install openssl, allowing app to listen on HTTPS.\n        # May not be needed if HTTPS is handled outside the application, e.g. in load balancer.\n        apk add --no-cache openssl ncurses-libs\n\n# Create final app image which gets deployed\nFROM deploy-base AS deploy\n    ARG APP_DIR\n    ARG APP_NAME\n    ARG APP_USER\n    ARG APP_GROUP\n\n    ARG MIX_ENV=prod\n    ARG RELEASE\n\n    ARG APP_PORT\n\n    # Set environment vars used by the app\n    # SECRET_KEY_BASE and DATABASE_URL env vars should be set when running the application\n    # maybe set COOKIE and other things\n    ENV HOME=$APP_DIR \\\n        PORT=$APP_PORT \\\n        PHX_SERVER=true \\\n        RELEASE=$RELEASE \\\n        RELEASE_TMP=\"/run/${APP_NAME}\"\n\n    # USER $APP_USER\n\n    # Setting WORKDIR after USER makes directory be owned by the user.\n    # Setting it before makes it owned by root, which is more secure.\n    # The app needs to be able to write to a tmp directory on startup, which by\n    # default is under the release. This can be changed by setting RELEASE_TMP to\n    # /tmp or, more securely, /run/foo\n    WORKDIR $APP_DIR\n\n    # When using a startup script, copy to /app/bin\n    # COPY bin ./bin\n\n    USER $APP_USER\n\n    # Chown files while copying. Running \"RUN chown -R app:app /app\"\n    # adds an extra layer which is about 10Mb, a huge difference if the\n    # app image is around 20Mb.\n\n    # TODO: For more security, change specific files to have group read/execute\n    # permissions while leaving them owned by root\n\n    # When using a startup script, unpack release under \"/app/current\" dir\n    # WORKDIR $APP_DIR/current\n\n    COPY --from=deploy-release --chown=\"$APP_USER:$APP_GROUP\" \"/app/_build/${MIX_ENV}/rel/${RELEASE}\" ./\n\n    EXPOSE $APP_PORT\n\n    # \"bin\" is the directory under the unpacked release, and \"prod\" is the name\n    # of the release\n    ENTRYPOINT [\"bin/prod\"]\n\n    # Run under init to avoid zombie processes\n    # https://github.com/krallin/tini\n    # ENTRYPOINT [\"/sbin/tini\", \"--\", \"bin/prod\"]\n\n    # Run app in foreground\n    CMD [\"start\"]\n\n    # Run via startup script\n    # CMD [\"/app/bin/start-docker\"]\n\n    # USER $APP_USER\n\n    # Setting WORKDIR after USER makes directory be owned by the user.\n    # Setting it before makes it owned by root, which is more secure.\n    # The app needs to be able to write to a tmp directory on startup, which by\n    # default is under the release. This can be changed by setting RELEASE_TMP to\n    # /tmp or, more securely, /run/foo\n    WORKDIR $APP_DIR\n\n    # When using a startup script, copy to /app/bin\n    # COPY bin ./bin\n\n    USER $APP_USER\n\n    # Chown files while copying. Running \"RUN chown -R app:app /app\"\n    # adds an extra layer which is about 10Mb, a huge difference if the\n    # app image is around 20Mb.\n\n    # TODO: For more security, change specific files to have group read/execute\n    # permissions while leaving them owned by root\n\n    # When using a startup script, unpack release under \"/app/current\" dir\n    # WORKDIR $APP_DIR/current\n\n    COPY --from=deploy-release --chown=\"$APP_USER:$APP_GROUP\" \"/app/_build/${MIX_ENV}/rel/${RELEASE}\" ./\n\n    EXPOSE $APP_PORT\n\n    # \"bin\" is the directory under the unpacked release, and \"prod\" is the name\n    # of the release\n    ENTRYPOINT [\"bin/prod\"]\n\n    # Run under init to avoid zombie processes\n    # https://github.com/krallin/tini\n    # ENTRYPOINT [\"/sbin/tini\", \"--\", \"bin/prod\"]\n\n    # Run app in foreground\n    CMD [\"start\"]\n\n# Scan for security vulnerabilities\nFROM deploy as deploy-scan\n    USER root\n\n    RUN --mount=type=cache,id=apk,target=/var/cache/apk,sharing=locked \\\n        set -ex && \\\n        $APK_UPDATE && $APK_UPGRADE && \\\n        apk add --no-cache curl && \\\n        curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin\n\n    RUN --mount=type=cache,id=apk,target=/var/cache/apk,sharing=locked \\\n        set -ex && \\\n        # Succeed for issues of severity = HIGH\n        # trivy filesystem $TRIVY_OPTS --format sarif -o /sarif-reports/trivy.high.sarif --exit-code 0 --severity HIGH --no-progress / && \\\n        trivy filesystem $TRIVY_OPTS --exit-code 0 --severity HIGH --no-progress / && \\\n        # Fail for issues of severity = CRITICAL\n        # trivy filesystem $TRIVY_OPTS --format sarif -o /sarif-reports/trivy.sarif --exit-code 1 --severity CRITICAL --no-progress /\n        # Fail for any issues\n        # trivy filesystem -d --exit-code 1 --no-progress /\n        trivy filesystem --format sarif -o /sarif-reports/trivy.sarif --no-progress $TRIVY_OPTS --no-progress /\n\n        # curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin && \\\n        # grype -vv --fail-on medium dir:/ \\\n\n# Copy build artifacts to host\nFROM scratch as artifacts\n    ARG MIX_ENV\n    ARG RELEASE\n\n    COPY --from=deploy-release \"/app/_build/${MIX_ENV}/rel/${RELEASE}\" /release\n    COPY --from=deploy-release /app/priv/static /static\n\n# Default target\nFROM deploy\n"
}