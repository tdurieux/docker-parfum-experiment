{
  "startTime": 1674248705443,
  "endTime": 1674248706088,
  "originalSmells": [
    {
      "rule": "pipUseNoCacheDir",
      "position": {
        "lineStart": 21,
        "lineEnd": 21,
        "columnStart": 4,
        "columnEnd": 45
      }
    }
  ],
  "repairedSmells": [],
  "repairedDockerfile": "# We start from my nginx fork which includes the proxy-connect module from tEngine\n# Source is available at https://github.com/rpardini/nginx-proxy-connect-stable-alpine\n# This is already multi-arch!\nARG BASE_IMAGE=\"docker.io/rpardini/nginx-proxy-connect-stable-alpine:nginx-1.20.1-alpine-3.12.7\"\n# Could be \"-debug\"\nARG BASE_IMAGE_SUFFIX=\"\"\nFROM ${BASE_IMAGE}${BASE_IMAGE_SUFFIX}\n\n# Link image to original repository on GitHub\nLABEL org.opencontainers.image.source https://github.com/rpardini/docker-registry-proxy\n\n# apk packages that will be present in the final image both debug and release\nRUN apk add --no-cache --update bash ca-certificates-bundle coreutils openssl\n\n# If set to 1, enables building mitmproxy, which helps a lot in debugging, but is super heavy to build.\nARG DEBUG_BUILD=\"1\"\nENV DO_DEBUG_BUILD=\"$DEBUG_BUILD\"\n\n# Build mitmproxy via pip. This is heavy, takes minutes do build and creates a 90mb+ layer. Oh well.\nRUN [[ \"a$DO_DEBUG_BUILD\" == \"a1\" ]] && { \\\n echo \"Debug build ENABLED.\" \\\n && apk add --no-cache --update su-exec git g++ libffi libffi-dev libstdc++ openssl-dev python3 python3-dev py3-pip py3-wheel py3-six py3-idna py3-certifi py3-setuptools \\\n && LDFLAGS=-L/lib pip --no-cache-dir install mitmproxy==5.2 \\\n && apk del --purge git g++ libffi-dev openssl-dev python3-dev py3-pip py3-wheel \\\n && rm -rf ~/.cache/pip \\\n ; \\\n} || { echo \"Debug build disabled.\" ; }\n\n# Required for mitmproxy\nENV LANG=en_US.UTF-8\n\n# Check the installed mitmproxy version, if built.\nRUN [[ \"a$DO_DEBUG_BUILD\" == \"a1\" ]] && { mitmproxy --version && mitmweb --version ; } || { echo \"Debug build disabled.\"; }\n\n# Create the cache directory and CA directory\nRUN mkdir -p /docker_mirror_cache /ca\n\n# Expose it as a volume, so cache can be kept external to the Docker image\nVOLUME /docker_mirror_cache\n\n# Expose /ca as a volume. Users are supposed to volume mount this, as to preserve it across restarts.\n# Actually, its required; if not, then docker clients will reject the CA certificate when the proxy is run the second time\nVOLUME /ca\n\n# Add our configuration\nADD nginx.conf /etc/nginx/nginx.conf\nADD nginx.manifest.common.conf /etc/nginx/nginx.manifest.common.conf\nADD nginx.manifest.stale.conf /etc/nginx/nginx.manifest.stale.conf\n\n# Add our very hackish entrypoint and ca-building scripts, make them executable\nADD entrypoint.sh /entrypoint.sh\nADD create_ca_cert.sh /create_ca_cert.sh\nRUN chmod +x /create_ca_cert.sh /entrypoint.sh\n\n# Clients should only use 3128, not anything else.\nEXPOSE 3128\n\n# In debug mode, 8081 exposes the mitmweb interface (for incoming requests from Docker clients)\nEXPOSE 8081\n# In debug-hub mode, 8082 exposes the mitmweb interface (for outgoing requests to DockerHub)\nEXPOSE 8082\n\n## Default envs.\n# A space delimited list of registries we should proxy and cache; this is in addition to the central DockerHub.\nENV REGISTRIES=\"k8s.gcr.io gcr.io quay.io\"\n# A space delimited list of registry:user:password to inject authentication for\nENV AUTH_REGISTRIES=\"some.authenticated.registry:oneuser:onepassword another.registry:user:password\"\n# Should we verify upstream's certificates? Default to true.\nENV VERIFY_SSL=\"true\"\n# Enable debugging mode; this inserts mitmproxy/mitmweb between the CONNECT proxy and the caching layer\nENV DEBUG=\"false\"\n# Enable debugging mode; this inserts mitmproxy/mitmweb between the caching layer and DockerHub's registry\nENV DEBUG_HUB=\"false\"\n# Enable nginx debugging mode; this uses nginx-debug binary and enabled debug logging, which is VERY verbose so separate setting\nENV DEBUG_NGINX=\"false\"\n\n# Manifest caching tiers. Disabled by default, to mimick 0.4/0.5 behaviour.\n# Setting it to true enables the processing of the ENVs below.\n# Once enabled, it is valid for all registries, not only DockerHub.\n# The envs *_REGEX represent a regex fragment, check entrypoint.sh to understand how they're used (nginx ~ location, PCRE syntax).\nENV ENABLE_MANIFEST_CACHE=\"false\"\n\n# 'Primary' tier defaults to 10m cache for frequently used/abused tags.\n# - People publishing to production via :latest (argh) will want to include that in the regex\n# - Heavy pullers who are being ratelimited but don't mind getting outdated manifests should (also) increase the cache time here\nENV MANIFEST_CACHE_PRIMARY_REGEX=\"(stable|nightly|production|test)\"\nENV MANIFEST_CACHE_PRIMARY_TIME=\"10m\"\n\n# 'Secondary' tier defaults any tag that has 3 digits or dots, in the hopes of matching most explicitly-versioned tags.\n# It caches for 60d, which is also the cache time for the large binary blobs to which the manifests refer.\n# That makes them effectively immutable. Make sure you're not affected; tighten this regex or widen the primary tier.\nENV MANIFEST_CACHE_SECONDARY_REGEX=\"(.*)(\\d|\\.)+(.*)(\\d|\\.)+(.*)(\\d|\\.)+\"\nENV MANIFEST_CACHE_SECONDARY_TIME=\"60d\"\n\n# The default cache duration for manifests that don't match either the primary or secondary tiers above.\n# In the default config, :latest and other frequently-used tags will get this value.\nENV MANIFEST_CACHE_DEFAULT_TIME=\"1h\"\n\n# Should we allow actions different than pull, default to false.\nENV ALLOW_PUSH=\"false\"\n\n# If push is allowed, buffering requests can cause issues on slow upstreams.\n# If you have trouble pushing, set this to false first, then fix remainig timouts.\n# Default is true to not change default behavior.\nENV PROXY_REQUEST_BUFFERING=\"true\"\n\n# Timeouts\n# ngx_http_core_module\nENV SEND_TIMEOUT=\"60s\"\nENV CLIENT_BODY_TIMEOUT=\"60s\"\nENV CLIENT_HEADER_TIMEOUT=\"60s\"\nENV KEEPALIVE_TIMEOUT=\"300s\"\n# ngx_http_proxy_module\nENV PROXY_READ_TIMEOUT=\"60s\"\nENV PROXY_CONNECT_TIMEOUT=\"60s\"\nENV PROXY_SEND_TIMEOUT=\"60s\"\n# ngx_http_proxy_connect_module - external module\nENV PROXY_CONNECT_READ_TIMEOUT=\"60s\"\nENV PROXY_CONNECT_CONNECT_TIMEOUT=\"60s\"\nENV PROXY_CONNECT_SEND_TIMEOUT=\"60s\"\n\n# Did you want a shell? Sorry, the entrypoint never returns, because it runs nginx itself. Use 'docker exec' if you need to mess around internally.\nENTRYPOINT [\"/entrypoint.sh\"]\n"
}