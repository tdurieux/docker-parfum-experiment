{
  "startTime": 1674256285069,
  "endTime": 1674256285933,
  "originalSmells": [
    {
      "rule": "aptGetUpdatePrecedesInstall",
      "position": {
        "lineStart": 57,
        "lineEnd": 62,
        "columnStart": 4,
        "columnEnd": 11
      }
    },
    {
      "rule": "ruleAptGetInstallThenRemoveAptLists",
      "position": {
        "lineStart": 57,
        "lineEnd": 62,
        "columnStart": 4,
        "columnEnd": 11
      }
    }
  ],
  "repairedSmells": [],
  "repairedDockerfile": "# Copyright 2016 The Kubernetes Authors.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# HOW TO USE THIS CONTAINER:\n#\n# For most users, the simplest way to use this container is to mount a volume\n# on /tmp/git.  The only commandline argument (or env var) that is really\n# required is `--repo` ($GIT_SYNC_REPO).  Everything else is optional (run this\n# with `--man` for details).\n#\n# This container will run as UID:GID 65533:65533 by default, and unless you\n# change that, you do not need to think about permissions much.  If you run\n# into permissions problems, this might help:\n#\n#  - User does not mount a volume\n#    => should work, but limited utility\n#\n#  - User mounts a new docker volume on /tmp/git\n#    => should work\n#\n#  - User mounts an existing docker volume on /tmp/git\n#    => if the volume already exists with compatible permissions it should work\n#    => if the volume already exists with different permissions you can either\n#       set the container UID or GID(s) or you can chown the volume\n#\n#  - User mounts an existing dir on /tmp/git\n#    => set container UID or GID(s) to be able to access that dir\n#\n#  - User sets a different UID and git-sync GID\n#    => should work\n#\n#  - User sets a different GID\n#    => either add the git-sync GID or else set --root, mount a volume,\n#       and manage volume permissions to access that volume\n\n#############################################################################\n# First we prepare the image that we want, regardless of build layers.\n#############################################################################\nFROM {ARG_FROM} as prep\n\n# When building, we can pass a unique value (e.g. `date +%s`) for this arg,\n# which will force a rebuild from here (by invalidating docker's cache).\nARG FORCE_REBUILD=0\n\nRUN apt-get -q -y update && apt-get -q -y install --no-install-recommends \\\n        ca-certificates \\\n        coreutils \\\n        socat \\\n        openssh-client \\\n        git && rm -rf /var/lib/apt/lists/*;\nRUN apt-get -q -y upgrade\n\n\n\n\n\n\nRUN apt-get -q -y autoremove\nRUN rm -rf /var/lib/apt/lists/*\n\n# By default we will run as this user...\nRUN echo \"git-sync:x:65533:65533::/tmp:/sbin/nologin\" >> /etc/passwd\n# ...but the user might choose a different UID and pass --add-user\n# which needs to be able to write to /etc/passwd.\nRUN chmod 0666 /etc/passwd\n\n# Add the default GID to /etc/group for completeness.\nRUN echo \"git-sync:x:65533:git-sync\" >> /etc/group\n\n# Make a directory that can be used to mount volumes and make it the default,\n# which makes the container image easier to use.  Setting the mode to include\n# group-write allows users to run this image as a different user, as long as\n# they use our git-sync group.  If the user needs a different group or sets\n# $GIT_SYNC_ROOT or --root, their values will override this, and we assume they\n# are handling permissions themselves.\nRUN mkdir -m 02775 /tmp/git && chown 65533:65533 /tmp/git\n\n# When building, we can pass a hash of the licenses tree, which docker checks\n# against its cache and can force a rebuild from here.\nARG HASH_LICENSES=0\n\n# Add third-party licenses.\nCOPY .licenses/ /LICENSES/\n\n# When building, we can pass a hash of the binary, which docker checks against\n# its cache and can force a rebuild from here.\nARG HASH_BINARY=0\n\n# Add the platform-specific binary.\nCOPY bin/{ARG_OS}_{ARG_ARCH}/{ARG_BIN} /{ARG_BIN}\n\n#############################################################################\n# Now we make a \"clean\" final image.\n#############################################################################\nFROM scratch\nCOPY --from=prep / /\n\n# Run as non-root by default.  There's simply no reason to run as root.\nUSER 65533:65533\n\n# Setting HOME ensures that whatever UID this ultimately runs as can write to\n# files like ~/.gitconfig.\nENV HOME=/tmp\nWORKDIR /tmp\n\n# Default values for flags.\nENV GIT_SYNC_ROOT=/tmp/git\n\nENTRYPOINT [\"/{ARG_BIN}\"]\n"
}