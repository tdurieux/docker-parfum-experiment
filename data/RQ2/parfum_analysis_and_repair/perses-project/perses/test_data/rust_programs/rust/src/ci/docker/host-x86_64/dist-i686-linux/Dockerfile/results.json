{
  "startTime": 1674252359927,
  "endTime": 1674252360968,
  "originalSmells": [
    {
      "rule": "ruleAptGetInstallThenRemoveAptLists",
      "position": {
        "lineStart": 13,
        "lineEnd": 34,
        "columnStart": 4,
        "columnEnd": 16
      }
    }
  ],
  "repairedSmells": [],
  "repairedDockerfile": "# We use Debian 6 (glibc 2.11, kernel 2.6.32) as a common base for other\n# distros that still need Rust support: RHEL 6 (glibc 2.12, kernel 2.6.32) and\n# SLES 11 SP4 (glibc 2.11, kernel 3.0).\nFROM debian:6\n\nWORKDIR /build\n\n# Debian 6 is EOL and no longer available from the usual mirrors,\n# so we'll need to switch to http://archive.debian.org/\nRUN sed -i '/updates/d' /etc/apt/sources.list && \\\n    sed -i 's/httpredir/archive/' /etc/apt/sources.list\n\nRUN apt-get update && \\\n    apt-get install --allow-unauthenticated -y --no-install-recommends \\\n      automake \\\n      bzip2 \\\n      ca-certificates \\\n      curl \\\n      file \\\n      g++ \\\n      g++-multilib \\\n      gcc \\\n      gcc-multilib \\\n      git \\\n      lib32z1-dev \\\n      libedit-dev \\\n      libncurses-dev \\\n      make \\\n      patch \\\n      perl \\\n      pkg-config \\\n      unzip \\\n      wget \\\n      xz-utils \\\n      zlib1g-dev && rm -rf /var/lib/apt/lists/*;\n\nENV PATH=/rustroot/bin:$PATH\nENV LD_LIBRARY_PATH=/rustroot/lib64:/rustroot/lib32:/rustroot/lib\nENV PKG_CONFIG_PATH=/rustroot/lib/pkgconfig\nWORKDIR /tmp\nRUN mkdir /home/user\nCOPY host-x86_64/dist-x86_64-linux/shared.sh /tmp/\n\n# We need a build of openssl which supports SNI to download artifacts from\n# static.rust-lang.org. This'll be used to link into libcurl below (and used\n# later as well), so build a copy of OpenSSL with dynamic libraries into our\n# generic root.\nCOPY host-x86_64/dist-x86_64-linux/build-openssl.sh /tmp/\nRUN ./build-openssl.sh\n\n# The `curl` binary on Debian 6 doesn't support SNI which is needed for fetching\n# some https urls we have, so install a new version of libcurl + curl which is\n# using the openssl we just built previously.\n#\n# Note that we also disable a bunch of optional features of curl that we don't\n# really need.\nCOPY host-x86_64/dist-x86_64-linux/build-curl.sh /tmp/\nRUN ./build-curl.sh && apt-get remove -y curl\n\n# binutils < 2.22 has a bug where the 32-bit executables it generates\n# immediately segfault in Rust, so we need to install our own binutils.\n#\n# See https://github.com/rust-lang/rust/issues/20440 for more info\nCOPY host-x86_64/dist-x86_64-linux/build-binutils.sh /tmp/\nRUN ./build-binutils.sh\n\n# Need at least GCC 5.1 to compile LLVM nowadays\nCOPY host-x86_64/dist-x86_64-linux/build-gcc.sh /tmp/\nRUN ./build-gcc.sh && apt-get remove -y gcc g++\n\n# Debian 6 has Python 2.6 by default, but LLVM needs 2.7+\nCOPY host-x86_64/dist-x86_64-linux/build-python.sh /tmp/\nRUN ./build-python.sh\n\n# LLVM needs cmake 3.4.3 or higher, and is planning to raise to 3.13.4.\nCOPY host-x86_64/dist-x86_64-linux/build-cmake.sh /tmp/\nRUN ./build-cmake.sh\n\n# Now build LLVM+Clang, afterwards configuring further compilations to use the\n# clang/clang++ compilers.\nCOPY host-x86_64/dist-x86_64-linux/build-clang.sh /tmp/\nRUN ./build-clang.sh\nENV CC=clang CXX=clang++\n\nCOPY scripts/sccache.sh /scripts/\nRUN sh /scripts/sccache.sh\n\nENV HOSTS=i686-unknown-linux-gnu\n\nENV RUST_CONFIGURE_ARGS \\\n      --enable-full-tools \\\n      --enable-sanitizers \\\n      --enable-profiler \\\n      --set target.i686-unknown-linux-gnu.linker=clang \\\n      --build=i686-unknown-linux-gnu \\\n      --set llvm.ninja=false \\\n      --set rust.jemalloc\nENV SCRIPT python2.7 ../x.py dist --build $HOSTS --host $HOSTS --target $HOSTS\nENV CARGO_TARGET_I686_UNKNOWN_LINUX_GNU_LINKER=clang\n\n# This was added when we switched from gcc to clang. It's not clear why this is\n# needed unfortunately, but without this the stage1 bootstrap segfaults\n# somewhere inside of a build script. The build ends up just hanging instead of\n# actually killing the process that segfaulted, but if the process is run\n# manually in a debugger the segfault is immediately seen as well as the\n# misaligned stack access.\n#\n# Added in #50200 there's some more logs there\nENV CFLAGS -mstackrealign\n\n# When we build cargo in this container, we don't want it to use the system\n# libcurl, instead it should compile its own.\nENV LIBCURL_NO_PKG_CONFIG 1\n\n# There was a bad interaction between \"old\" 32-bit binaries on current 64-bit\n# kernels with selinux enabled, where ASLR mmap would sometimes choose a low\n# address and then block it for being below `vm.mmap_min_addr` -> `EACCES`.\n# This is probably a kernel bug, but setting `ulimit -Hs` works around it.\n# See also `src/ci/run.sh` where this takes effect.\nENV SET_HARD_RLIMIT_STACK 1\n\nENV DIST_REQUIRE_ALL_TOOLS 1\n"
}