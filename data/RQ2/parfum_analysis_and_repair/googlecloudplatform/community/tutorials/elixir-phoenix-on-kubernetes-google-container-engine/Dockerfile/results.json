{
  "startTime": 1674254191006,
  "endTime": 1674254191809,
  "originalSmells": [
    {
      "rule": "npmCacheCleanAfterInstall",
      "position": {
        "lineStart": 82,
        "lineEnd": 82,
        "columnStart": 7,
        "columnEnd": 18
      }
    }
  ],
  "repairedSmells": [],
  "repairedDockerfile": "# Copyright 2017 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\n# This is a sample Dockerfile for packaging an Elixir Phoenix application\n# as a Docker image. It builds a Distillery release and installs it on\n# Alpine Linux. The final image launches the application on port 8080. It\n# requires the project ID to be passed in the project_id build arg.\n#\n# This Dockerfile includes two stages and requires Docker 17.05 or later.\n#\n# To adapt this Dockerfile to your app, you may need to customize the app_name\n# and phoenix_subdir build arguments, as outlined below.\n\n\n################################################################################\n# BUILD STAGE\n#\n# Builds the app, does a Brunch build to build the assets, and creates a\n# release. This stage uses the official Alpine Linux - Elixir base image, and\n# installs a few additional build tools such as Node.js.\n\nFROM elixir:alpine\n\n\n##############################################################################\n## Build arguments. Modify these to adapt this Dockerfile to your app.      ##\n## Alternatively, you may specify --build-arg when running `docker build`.  ##\n\n## The name of your Phoenix application.                                    ##\nARG app_name=hello\n\n## The subdirectory of the Phoenix application within the toplevel project. ##\n## If your project is an umbrella project, this should be the relative path ##\n## to the Phoenix application, e.g. \"apps/hello_web\". If this is a simple   ##\n## project, this should be \".\"                                              ##\nARG phoenix_subdir=.\n\n## The build environment. This is usually prod, but you might change it if  ##\n## you have staging environments.                                           ##\nARG build_env=prod\n\n## End build arguments.                                                     ##\n##############################################################################\n\n\n# Set up build environment.\nENV MIX_ENV=${build_env} \\\n    TERM=xterm\n\n# Set the build directory.\nWORKDIR /opt/app\n\n# Install build tools needed in addition to Elixir:\n# NodeJS is used for Webpack builds of Phoenix assets.\n# Hex and Rebar are needed to get and build dependencies.\nRUN apk update \\\n    && apk --no-cache --update add nodejs npm \\\n    && mix local.rebar --force \\\n    && mix local.hex --force\n\n# Copy the application files into /opt/app.\nCOPY . .\n\n# Build the application.\nRUN mix do deps.get, compile\n\n# Build assets by running a Webpack build and Phoenix digest.\n# If you are using a different mechanism for asset builds, you may need to\n# alter these commands.\nRUN cd ${phoenix_subdir}/assets \\\n    && npm install \\\n    && ./node_modules/webpack/bin/webpack.js --mode production \\\n    && cd .. \\\n    && mix phx.digest && npm cache clean --force;\n\n# Create the release, and move the artifacts to well-known paths so the\n# runtime image doesn't need to know the app name. Specifically, the binary\n# is renamed to \"start_server\", and the entire release is moved into\n# /opt/release.\nRUN mix release ${app_name} \\\n    && mv _build/${build_env}/rel/${app_name} /opt/release \\\n    && mv /opt/release/bin/${app_name} /opt/release/bin/start_server\n\n\n################################################################################\n# RUNTIME STAGE\n#\n# Creates the actual runtime image. This is based on a the Alpine Linux base\n# image, with only the minimum dependencies for running ERTS and the Cloud SQL\n# Proxy.\n\nFROM alpine:latest\n\n# The Google Cloud project ID must be provided via a --build-arg.\nARG project_id\n\n# Install dependencies. Bash and OpenSSL are required for ERTS. Also install\n# certificates needed to communicate with Google Cloud APIs over HTTPS.\nRUN apk update \\\n    && apk --no-cache --update add bash ca-certificates openssl-dev\n\n# Install the Cloud SQL Proxy in /usr/local/bin/. Also create the directory\n# /tmp/cloudsql where SQL connection sockets will be kept.\nRUN mkdir -p /usr/local/bin \\\n    && wget https://dl.google.com/cloudsql/cloud_sql_proxy.linux.amd64 -O /usr/local/bin/cloud_sql_proxy \\\n    && chmod +x /usr/local/bin/cloud_sql_proxy \\\n    && mkdir -p /tmp/cloudsql\n\n# This is the runtime environment for a Phoenix app.\n# It listens on port 8080, and runs in the prod environment.\nENV PORT=8080 \\\n    GCLOUD_PROJECT_ID=${project_id} \\\n    REPLACE_OS_VARS=true\nEXPOSE ${PORT}\n\n# Set the install directory. The app will run from here.\nWORKDIR /opt/app\n\n# Obtain the built application release from the build stage.\nCOPY --from=0 /opt/release .\n\n# Start the server. This first starts the Cloud SQL Proxy in the background,\n# then runs the release in the foreground. This will work for simple\n# deployments, but a more robust deployment might run the Cloud SQL Proxy in a\n# sidecar container.\nCMD (/usr/local/bin/cloud_sql_proxy \\\n      -projects=${GCLOUD_PROJECT_ID} -dir=/tmp/cloudsql &); \\\n    exec /opt/app/bin/start_server start\n"
}