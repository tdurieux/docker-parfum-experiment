{
  "startTime": 1674250392268,
  "endTime": 1674250393050,
  "originalSmells": [
    {
      "rule": "aptGetInstallUseNoRec",
      "position": {
        "lineStart": 82,
        "lineEnd": 82,
        "columnStart": 22,
        "columnEnd": 45
      }
    },
    {
      "rule": "aptGetInstallUseNoRec",
      "position": {
        "lineStart": 89,
        "lineEnd": 89,
        "columnStart": 4,
        "columnEnd": 27
      }
    },
    {
      "rule": "ruleAptGetInstallThenRemoveAptLists",
      "position": {
        "lineStart": 82,
        "lineEnd": 82,
        "columnStart": 22,
        "columnEnd": 45
      }
    },
    {
      "rule": "ruleAptGetInstallThenRemoveAptLists",
      "position": {
        "lineStart": 89,
        "lineEnd": 89,
        "columnStart": 4,
        "columnEnd": 27
      }
    }
  ],
  "repairedSmells": [],
  "repairedDockerfile": "class: title\n\n# Advanced Dockerfiles\n\n![construction](images/title-advanced-dockerfiles.jpg)\n\n---\n\n## Objectives\n\nWe have seen simple Dockerfiles to illustrate how Docker build\ncontainer images.\n\nIn this section, we will see more Dockerfile commands.\n\n---\n\n## `Dockerfile` usage summary\n\n* `Dockerfile` instructions are executed in order.\n\n* Each instruction creates a new layer in the image.\n\n* Docker maintains a cache with the layers of previous builds.\n\n* When there are no changes in the instructions and files making a layer,\n  the builder re-uses the cached layer, without executing the instruction for that layer.\n\n* The `FROM` instruction MUST be the first non-comment instruction.\n\n* Lines starting with `#` are treated as comments.\n\n* Some instructions (like `CMD` or `ENTRYPOINT`) update a piece of metadata.\n\n  (As a result, each call to these instructions makes the previous one useless.)\n\n---\n\n## The `RUN` instruction\n\nThe `RUN` instruction can be specified in two ways.\n\nWith shell wrapping, which runs the specified command inside a shell,\nwith `/bin/sh -c`:\n\n```dockerfile\nRUN apt-get update\n```\n\nOr using the `exec` method, which avoids shell string expansion, and\nallows execution in images that don't have `/bin/sh`:\n\n```dockerfile\nRUN [ \"apt-get\", \"update\" ]\n```\n\n---\n\n## More about the `RUN` instruction\n\n`RUN` will do the following:\n\n* Execute a command.\n* Record changes made to the filesystem.\n* Work great to install libraries, packages, and various files.\n\n`RUN` will NOT do the following:\n\n* Record state of *processes*.\n* Automatically start daemons.\n\nIf you want to start something automatically when the container runs,\nyou should use `CMD` and/or `ENTRYPOINT`.\n\n---\n\n## Collapsing layers\n\nIt is possible to execute multiple commands in a single step:\n\n```dockerfile\nRUN apt-get update && apt-get install --no-install-recommends -y wget && apt-get clean && rm -rf /var/lib/apt/lists/*;\n```\n\nIt is also possible to break a command onto multiple lines:\n\n```dockerfile\nRUN apt-get update \\\n && apt-get install --no-install-recommends -y wget \\\n && apt-get clean && rm -rf /var/lib/apt/lists/*;\n```\n\n---\n\n## The `EXPOSE` instruction\n\nThe `EXPOSE` instruction tells Docker what ports are to be published\nin this image.\n\n```dockerfile\nEXPOSE 8080\nEXPOSE 80 443\nEXPOSE 53/tcp 53/udp\n```\n\n* All ports are private by default.\n\n* Declaring a port with `EXPOSE` is not enough to make it public.\n\n* The `Dockerfile` doesn't control on which port a service gets exposed.\n\n---\n\n## Exposing ports\n\n* When you `docker run -p <port> ...`, that port becomes public.\n\n    (Even if it was not declared with `EXPOSE`.)\n\n* When you `docker run -P ...` (without port number), all ports\n  declared with `EXPOSE` become public.\n\nA *public port* is reachable from other containers and from outside the host.\n\nA *private port* is not reachable from outside.\n\n---\n\n## The `COPY` instruction\n\nThe `COPY` instruction adds files and content from your host into the\nimage.\n\n```dockerfile\nCOPY . /src\n```\n\nThis will add the contents of the *build context* (the directory\npassed as an argument to `docker build`) to the directory `/src`\nin the container.\n\n---\n\n## Build context isolation\n\nNote: you can only reference files and directories *inside* the\nbuild context. Absolute paths are taken as being anchored to\nthe build context, so the two following lines are equivalent:\n\n```dockerfile\nCOPY . /src\nCOPY / /src\n```\n\nAttempts to use `..` to get out of the build context will be\ndetected and blocked with Docker, and the build will fail.\n\nOtherwise, a `Dockerfile` could succeed on host A, but fail on host B.\n\n---\n\n## `ADD`\n\n`ADD` works almost like `COPY`, but has a few extra features.\n\n`ADD` can get remote files:\n\n```dockerfile\nADD http://www.example.com/webapp.jar /opt/\n```\n\nThis would download the `webapp.jar` file and place it in the `/opt`\ndirectory.\n\n`ADD` will automatically unpack zip files and tar archives:\n\n```dockerfile\nADD ./assets.zip /var/www/htdocs/assets/\n```\n\nThis would unpack `assets.zip` into `/var/www/htdocs/assets`.\n\n*However,* `ADD` will not automatically unpack remote archives.\n\n---\n\n## `ADD`, `COPY`, and the build cache\n\n* Before creating a new layer, Docker checks its build cache.\n\n* For most Dockerfile instructions, Docker only looks at the\n  `Dockerfile` content to do the cache lookup.\n\n* For `ADD` and `COPY` instructions, Docker also checks if the files\n  to be added to the container have been changed.\n\n* `ADD` always needs to download the remote file before\n  it can check if it has been changed.\n\n  (It cannot use,\n  e.g., ETags or If-Modified-Since headers.)\n\n---\n\n## `VOLUME`\n\nThe `VOLUME` instruction tells Docker that a specific directory\nshould be a *volume*.\n\n```dockerfile\nVOLUME /var/lib/mysql\n```\n\nFilesystem access in volumes bypasses the copy-on-write layer,\noffering native performance to I/O done in those directories.\n\nVolumes can be attached to multiple containers, allowing to\n\"port\" data over from a container to another, e.g. to\nupgrade a database to a newer version.\n\nIt is possible to start a container in \"read-only\" mode.\nThe container filesystem will be made read-only, but volumes\ncan still have read/write access if necessary.\n\n---\n\n## The `WORKDIR` instruction\n\nThe `WORKDIR` instruction sets the working directory for subsequent\ninstructions.\n\nIt also affects `CMD` and `ENTRYPOINT`, since it sets the working\ndirectory used when starting the container.\n\n```dockerfile\nWORKDIR /src\n```\n\nYou can specify `WORKDIR` again to change the working directory for\nfurther operations.\n\n---\n\n## The `ENV` instruction\n\nThe `ENV` instruction specifies environment variables that should be\nset in any container launched from the image.\n\n```dockerfile\nENV WEBAPP_PORT 8080\n```\n\nThis will result in an environment variable being created in any\ncontainers created from this image of\n\n```bash\nWEBAPP_PORT=8080\n```\n\nYou can also specify environment variables when you use `docker run`.\n\n```bash\n$ docker run -e WEBAPP_PORT=8000 -e WEBAPP_HOST=www.example.com ...\n```\n\n---\n\n## The `USER` instruction\n\nThe `USER` instruction sets the user name or UID to use when running\nthe image.\n\nIt can be used multiple times to change back to root or to another user.\n\n---\n\n## The `CMD` instruction\n\nThe `CMD` instruction is a default command run when a container is\nlaunched from the image.\n\n```dockerfile\nCMD [ \"nginx\", \"-g\", \"daemon off;\" ]\n```\n\nMeans we don't need to specify `nginx -g \"daemon off;\"` when running the\ncontainer.\n\nInstead of:\n\n```bash\n$ docker run <dockerhubUsername>/web_image nginx -g \"daemon off;\"\n```\n\nWe can just do:\n\n```bash\n$ docker run <dockerhubUsername>/web_image\n```\n\n---\n\n## More about the `CMD` instruction\n\nJust like `RUN`, the `CMD` instruction comes in two forms.\nThe first executes in a shell:\n\n```dockerfile\nCMD nginx -g \"daemon off;\"\n```\n\nThe second executes directly, without shell processing:\n\n```dockerfile\nCMD [ \"nginx\", \"-g\", \"daemon off;\" ]\n```\n\n---\n\nclass: extra-details\n\n## Overriding the `CMD` instruction\n\nThe `CMD` can be overridden when you run a container.\n\n```bash\n$ docker run -it <dockerhubUsername>/web_image bash\n```\n\nWill run `bash` instead of `nginx -g \"daemon off;\"`.\n\n---\n\n## The `ENTRYPOINT` instruction\n\nThe `ENTRYPOINT` instruction is like the `CMD` instruction,\nbut arguments given on the command line are *appended* to the\nentry point.\n\nNote: you have to use the \"exec\" syntax (`[ \"...\" ]`).\n\n```dockerfile\nENTRYPOINT [ \"/bin/ls\" ]\n```\n\nIf we were to run:\n\n```bash\n$ docker run training/ls -l\n```\n\nInstead of trying to run `-l`, the container will run `/bin/ls -l`.\n\n---\n\nclass: extra-details\n\n## Overriding the `ENTRYPOINT` instruction\n\nThe entry point can be overridden as well.\n\n```bash\n$ docker run -it training/ls\nbin   dev  home  lib64  mnt  proc  run   srv  tmp  var\nboot  etc  lib   media  opt  root  sbin  sys  usr\n$ docker run -it --entrypoint bash training/ls\nroot@d902fb7b1fc7:/#\n```\n\n---\n\n## How `CMD` and `ENTRYPOINT` interact\n\nThe `CMD` and `ENTRYPOINT` instructions work best when used\ntogether.\n\n```dockerfile\nENTRYPOINT [ \"nginx\" ]\nCMD [ \"-g\", \"daemon off;\" ]\n```\n\nThe `ENTRYPOINT` specifies the command to be run and the `CMD`\nspecifies its options. On the command line we can then potentially\noverride the options when needed.\n\n```bash\n$ docker run -d <dockerhubUsername>/web_image -t\n```\n\nThis will override the options `CMD` provided with new flags.\n\n---\n\n## Advanced Dockerfile instructions\n\n* `ONBUILD` lets you stash instructions that will be executed\n  when this image is used as a base for another one.\n* `LABEL` adds arbitrary metadata to the image.\n* `ARG` defines build-time variables (optional or mandatory).\n* `STOPSIGNAL` sets the signal for `docker stop` (`TERM` by default).\n* `HEALTHCHECK` defines a command assessing the status of the container.\n* `SHELL` sets the default program to use for string-syntax RUN, CMD, etc.\n\n---\n\nclass: extra-details\n\n## The `ONBUILD` instruction\n\nThe `ONBUILD` instruction is a trigger. It sets instructions that will\nbe executed when another image is built from the image being build.\n\nThis is useful for building images which will be used as a base\nto build other images.\n\n```dockerfile\nONBUILD COPY . /src\n```\n\n* You can't chain `ONBUILD` instructions with `ONBUILD`.\n* `ONBUILD` can't be used to trigger `FROM` instructions.\n"
}