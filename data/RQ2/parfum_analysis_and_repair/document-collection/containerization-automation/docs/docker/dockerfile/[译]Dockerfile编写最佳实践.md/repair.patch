diff --git "a/Users/tdurieux/git/dinghy-experiment/data/evaluation/dockerfiles/document-collection/containerization-automation/docs/docker/dockerfile/[\350\257\221]Dockerfile\347\274\226\345\206\231\346\234\200\344\275\263\345\256\236\350\267\265.md" "b/Users/tdurieux/git/dinghy-experiment/data/evaluation/dockerfile_repair_results/document-collection/containerization-automation/docs/docker/dockerfile/[\350\257\221]Dockerfile\347\274\226\345\206\231\346\234\200\344\275\263\345\256\236\350\267\265.md/repaired.Dockerfile"
index b0665b1..ebf6893 100644
--- "a/Users/tdurieux/git/dinghy-experiment/data/evaluation/dockerfiles/document-collection/containerization-automation/docs/docker/dockerfile/[\350\257\221]Dockerfile\347\274\226\345\206\231\346\234\200\344\275\263\345\256\236\350\267\265.md"
+++ "b/Users/tdurieux/git/dinghy-experiment/data/evaluation/dockerfile_repair_results/document-collection/containerization-automation/docs/docker/dockerfile/[\350\257\221]Dockerfile\347\274\226\345\206\231\346\234\200\344\275\263\345\256\236\350\267\265.md/repaired.Dockerfile"
@@ -1,4 +1,3 @@
-
 # [译]Dockerfile编写最佳实践
 
 原文地址：[Best practices for writing Dockerfiles](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)
@@ -57,7 +56,7 @@ $ docker build --tag=helloapp:v1 .
 Sending build context to Docker daemon  3.072kB
 Step 1/3 : FROM alpine
 latest: Pulling from library/alpine
-9d48c3bd43c5: Pull complete 
+9d48c3bd43c5: Pull complete
 Digest: sha256:72c42ed48c3a2db31b7dafe17d275b634664a708d901ec9fd57b1529280f01fb
 Status: Downloaded newer image for alpine:latest
  ---> 961769676411
@@ -249,7 +248,7 @@ Successfully tagged myimage:latest
 
 ### 最小化层数量
 
-在旧版本的`Docker`中，最小化图像的层数以确保其性能是非常重要的。最后的版本中添加了以下功能以减少此限制： 
+在旧版本的`Docker`中，最小化图像的层数以确保其性能是非常重要的。最后的版本中添加了以下功能以减少此限制：
 
 * 只有指令`RUN，COPY，ADD`创建层。其他指令会创建临时中间镜像，并且不会增加生成的大小
 * 尽可能的使用[多阶段构建](https://docs.docker.com/develop/develop-images/multistage-build/)，只将需要的内容复制到最终镜像中。这允许您在中间构建阶段包含工具和调试信息，而不增加最终镜像的大小
@@ -259,12 +258,12 @@ Successfully tagged myimage:latest
 尽可能的通过按字母数字顺序排列多行参数来简化以后的更改。这有助于避免包的重复，并使列表更易于更新。这也使得`PRs`更易于阅读和审查。在反斜杠（`\`）前添加空格也有帮助。示例如下：
 
 ```
-RUN apt-get update && apt-get install -y \
+RUN apt-get update && apt-get install --no-install-recommends -y \
   bzr \
   cvs \
   git \
   mercurial \
-  subversion
+  subversion && rm -rf /var/lib/apt/lists/*;
 ```
 
 ### 利用构建缓存
@@ -336,10 +335,10 @@ LABEL vendor=ACME\ Incorporated \
 始终将`RUN apt-get update`与`apt-get install`合并在同一`RUN`语句中。例如：
 
 ```
-RUN apt-get update && apt-get install -y \
+RUN apt-get update && apt-get install --no-install-recommends -y \
     package-bar \
     package-baz \
-    package-foo
+    package-foo && rm -rf /var/lib/apt/lists/*;
 ```
 
 在`RUN`语句中单独使用`apt-get update`会导致缓存问题和后续`apt-get`安装指令失败。例如
@@ -347,7 +346,7 @@ RUN apt-get update && apt-get install -y \
 ```
 FROM ubuntu:18.04
 RUN apt-get update
-RUN apt-get install -y curl
+RUN apt-get install --no-install-recommends -y curl && rm -rf /var/lib/apt/lists/*;
 ```
 
 生成镜像后，所有层都在`Docker`缓存中。假设稍后通过添加额外的包来修改`apt-get-install`：
@@ -355,7 +354,7 @@ RUN apt-get install -y curl
 ```
 FROM ubuntu:18.04
 RUN apt-get update
-RUN apt-get install -y curl nginx
+RUN apt-get install --no-install-recommends -y curl nginx && rm -rf /var/lib/apt/lists/*;
 ```
 
 `Docker`将初始指令和修改后的指令视为相同的，并重用前面步骤中的缓存。因此`apt-get update`不会执行，因为构建使用了缓存版本。因为`apt-get update`没有运行，所以构建可能会得到`curl`和`nginx`包的过时版本
@@ -363,10 +362,10 @@ RUN apt-get install -y curl nginx
 使用`RUN apt-get update && apt-get install -y`确保`Dockerfile`安装最新的包版本，而无需进一步编码或手动干预。这种技术被称为`缓存破坏`。还可以通过指定包版本来实现缓存破坏。这称为版本固定（`version pinning`），例如：
 
 ```
-RUN apt-get update && apt-get install -y \
+RUN apt-get update && apt-get install --no-install-recommends -y \
     package-bar \
     package-baz \
-    package-foo=1.3.*
+    package-foo=1.3.* && rm -rf /var/lib/apt/lists/*;
 ```
 
 版本固定会强制生成检索特定版本，而不管缓存中有什么。此技术还可以减少由于所需包中的意外更改而导致的故障
@@ -374,7 +373,7 @@ RUN apt-get update && apt-get install -y \
 下面是一个格式良好的`RUN`指令，它演示了所有`apt-get`建议
 
 ```
-RUN apt-get update && apt-get install -y \
+RUN apt-get update && apt-get install --no-install-recommends -y \
     aufs-tools \
     automake \
     build-essential \
@@ -449,7 +448,7 @@ RUN ["/bin/bash", "-c", "set -o pipefail && wget -O - https://some.site | wc -l
 ```
 ENV PG_MAJOR 9.3
 ENV PG_VERSION 9.3.4
-RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress && …
+RUN curl -f -SL https://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress && …
 ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH
 ```
 
@@ -498,7 +497,7 @@ $ docker run --rm test sh -c 'echo $ADMIN_USER'
 
 ```
 COPY requirements.txt /tmp/
-RUN pip install --requirement /tmp/requirements.txt
+RUN pip install --no-cache-dir --requirement /tmp/requirements.txt
 COPY . /tmp/
 ```
 
@@ -508,7 +507,7 @@ COPY . /tmp/
 
 ```
 ADD http://example.com/big.tar.xz /usr/src/things/
-RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things
+RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things && rm /usr/src/things/big.tar.xz
 RUN make -C /usr/src/things all
 ```
 
@@ -516,9 +515,9 @@ RUN make -C /usr/src/things all
 
 ```
 RUN mkdir -p /usr/src/things \
-    && curl -SL http://example.com/big.tar.xz \
+    && curl -f -SL https://example.com/big.tar.xz \
     | tar -xJC /usr/src/things \
-    && make -C /usr/src/things all
+    && make -C /usr/src/things all && rm -rf /usr/src/things
 ```
 
 对于不需要`ADD`的`tar`自动提取功能的其他项（文件、目录），应始终使用`COPY`