{
  "startTime": 1674255317351,
  "endTime": 1674255318218,
  "originalSmells": [
    {
      "rule": "curlUseFlagF",
      "position": {
        "lineStart": 49,
        "lineEnd": 49,
        "columnStart": 4,
        "columnEnd": 71
      }
    },
    {
      "rule": "curlUseFlagF",
      "position": {
        "lineStart": 61,
        "lineEnd": 61,
        "columnStart": 10,
        "columnEnd": 71
      }
    },
    {
      "rule": "tarSomethingRmTheSomething",
      "position": {
        "lineStart": 92,
        "lineEnd": 92,
        "columnStart": 14,
        "columnEnd": 97
      }
    }
  ],
  "repairedSmells": [],
  "repairedDockerfile": "# Copyright 2021 Intel Coporation.\n#\n# SPDX-License-Identifier: Apache-2.0\n\n# Image for building PMEM-CSI for OpenShift.\n#\n# This need a subscription for the RHEL package feed.\n#\n# On a suitable host, run\n#   subscription-manager register --username <username> --auto-attach\n# to subscribe. Then build with\n#   buildah bud -f Dockerfile.UBI\n#\n# If such a host is not available, then the same can be done in a container.\n# The host then only needs buildah but doesn't need to be RHEL. In the following\n# example, /nvme is where the GOPATH and the current directory are located.\n#\n#   docker run --detach --privileged -v /var/lib/containers/:/var/lib/containers/:Z -v /nvme:/nvme --name rhel registry.access.redhat.com/rhel7:latest sleep infinity\n#   docker exec -ti rhel subscription-manager register --username <username> --auto-attach\n#   docker exec rhel subscription-manager repos --enable=rhel-7-server-rpms\n#   docker exec rhel subscription-manager repos --enable=rhel-7-server-extras-rpms\n#   docker exec rhel yum -y install buildah\n#   docker exec rhel buildah bud -f `pwd`/Dockerfile.UBI `pwd`\n#\n# Because /var/lib/containers/ is shared with the host, buildah on the host will\n# have access to the resulting image:\n#\n# $ sudo buildah images\n# REPOSITORY                                                                                 TAG      IMAGE ID       CREATED         SIZE\n# <none>                                                                                     <none>   d1767ba7457c   1 minutes ago   361 MB\n# $ container=$(sudo buildah from d1767ba7457c)\n# $ sudo buildah $container ls /licenses\n# PMEM-CSI.LICENSE  github.com  go-fibmap  go.LICENSE  go.uber.org  golang.org  gomodules.xyz  google.golang.org gopkg.in  ipmctl.LICENSE  k8s.io  sigs.k8s.io\n#\n# It can be tagged either as part of \"buildah bud\" with \"-t <tag>\" or later.\n\n# Image #0 as build\nFROM registry.access.redhat.com/ubi8\n\nWORKDIR /pmem-csi\nCOPY . .\n\nARG GO_VERSION=\"1.16.1\"\n\n# CACHEBUST is set by the CI when building releases to ensure that apt-get really gets\n# run instead of just using some older, cached result.\nARG CACHEBUST\n\nRUN dnf install -y gcc ndctl-devel make git pkg-config curl tar findutils xz cmake pkg-config gcc-c++ python36\nRUN curl -f -L https://dl.google.com/go/go${GO_VERSION}.linux-amd64.tar.gz | tar -zxf - -C / && \\\n    mkdir -p /usr/local/bin/ && \\\n    for i in /go/bin/*; do ln -s $i /usr/local/bin/; done\n\n# Build ipmctl from source.\n# We use the latest official release and determine that via\n# the HTML redirect page.\nRUN set -x && \\\n    git clone https://github.com/intel/ipmctl.git && \\\n    mkdir -p /usr/local/share/package-licenses && \\\n    cp LICENSE /usr/local/share/package-licenses/ipmctl.LICENSE && \\\n    cd ipmctl && \\\n    tag=$( curl -f --silent https://github.com/intel/ipmctl/releases/latest | sed -e 's;.*tag/\\([^\"]*\\).*;\\1;') && \\\n    git checkout $tag && \\\n    mkdir build && \\\n    cd build && \\\n    cmake -DRELEASE=ON -DCMAKE_INSTALL_PREFIX=/usr/local .. && \\\n    make -j all && \\\n    make install\n\n# build pmem-csi-driver\nARG VERSION=\"unknown\"\nENV PKG_CONFIG_PATH=/usr/lib/pkgconfig/\n\n# Here we choose explicitly which binaries we want in the image and in\n# which flavor (production or testing). The actual binary name in the\n# image is going to be the same, to avoid unnecessary deployment\n# differences.\nRUN set -x && \\\n    make VERSION=${VERSION} pmem-csi-driver pmem-csi-operator && \\\n    mkdir -p /usr/local/bin && \\\n    mv _output/pmem-csi-driver /usr/local/bin/pmem-csi-driver && \\\n    mv _output/pmem-csi-operator /usr/local/bin/pmem-csi-operator && \\\n    go mod vendor && \\\n    hack/copy-modules-license.sh /usr/local/share/package-licenses ./cmd/pmem-csi-driver ./cmd/pmem-csi-operator && \\\n    cp /go/LICENSE /usr/local/share/package-licenses/go.LICENSE && \\\n    cp LICENSE /usr/local/share/package-licenses/PMEM-CSI.LICENSE\n\n# Now also copy copyleft source code that was used during the build of our binaries.\nRUN set -x && \\\n    mkdir -p /usr/local/share/package-sources && \\\n    for license in $(grep -l -r -w -e MPL -e GPL -e LGPL /usr/local/share/package-licenses | sed -e 's;^/usr/local/share/package-licenses/;;'); do \\\n        if ! (dir=$(dirname $license) && \\\n              tar -Jvcf /usr/local/share/package-sources/$(echo $dir | tr / _).tar.xz vendor/$dir ); then \\\n              exit 1; \\\n        fi; \\\n    done; rm /usr/local/share/package-sources/$( echo $dir | tr / _).tar.xz \\\n    ls -l /usr/local/share/package-sources; \\\n    du -h /usr/local/share/package-sources\n\n# The actual pmem-csi-driver image.\n# Image #1 as runtime\nFROM registry.access.redhat.com/ubi8\nLABEL name=\"pmem-csi-driver\"\nLABEL vendor=\"Intel\"\n# updated by hack/set-version.sh when preparing a release\nLABEL version=\"v0.9.1\"\n# Needs to be set by Red Hat build service.\n# LABEL release=\"1\"\nLABEL summary=\"A CSI driver for managing PMEM.\"\nLABEL description=\"Intel(R) PMEM-CSI is a Container Storage Interface (CSI) driver for container orchestrators like Kubernetes. It makes local persistent memory (PMEM) available as a filesystem volume to container applications.\"\n\n# Update and install the minimal amount of additional packages that\n# are needed at runtime:\n# file - driver uses file utility to determine filesystem type\n# xfsprogs, e2fsprogs - formating filesystems\n# lvm2 - volume management\n# ndctl - pulls in the necessary library, useful by itself\nRUN dnf install -y file xfsprogs e2fsprogs lvm2 ndctl && \\\n    mv /var/log/dnf.rpm.log /usr/local/share/package-install.log && \\\n    rm -rf /var/cache /var/log/dnf*\n\n# Move required binaries and libraries to clean container.\nCOPY --from=0 /usr/local/bin/pmem-* /usr/local/bin/ipmctl /usr/local/bin/\nCOPY --from=0 /usr/local/lib64/libipmctl*.so.* /usr/local/lib64\nCOPY --from=0 /usr/local/share/package-licenses /licenses\nCOPY --from=0 /usr/local/share/package-sources /sources\n\n# /usr/local/lib is not in the default library search path.\nRUN for i in /usr/local/lib64/*.so.*; do ln -s $i /usr/lib64; done\n\n# Download source RPMs for those packages that were installed by us above.\nRUN echo \"Extra packages installed as separate layer:\" && grep Installed: /usr/local/share/package-install.log\nRUN set -xe && \\\n    cd /sources && \\\n    for package in $(grep Installed: /usr/local/share/package-install.log | sed -e 's/.*Installed: //' | sort -u); do \\\n       base=${package%-*-*} && \\\n       case $base in \\\n           *) \\\n               license=$(rpm -q --qf %{license} \"$base\") && \\\n               case $license in \\\n                   *MPL*|*GPL*) \\\n                       echo \"INFO: downloading source of $base because of the $license\" && \\\n                       dnf download --source $base \\\n                       ;; \\\n                   *) \\\n                       echo \"INFO: not shipping source of $base because not required by $license\" \\\n                       ;; \\\n               esac \\\n               ;; \\\n       esac; \\\n    done && \\\n    rm -rf /var/cache /var/log/dnf*\n\nRUN ls -l /sources\nRUN du -h /sources\n\n# Don't rely on udevd, it isn't available (https://unix.stackexchange.com/questions/591724/how-to-add-a-block-to-udev-database-that-works-after-reboot).\n# Same with D-Bus.\n# Backup and archival of metadata inside the container is useless.\nRUN sed -i \\\n        -e 's/udev_sync = 1/udev_sync = 0/' \\\n        -e 's/udev_rules = 1/udev_rules = 0/' \\\n        -e 's/obtain_device_list_from_udev = 1/obtain_device_list_from_udev = 0/' \\\n        -e 's/multipath_component_detection = 1/multipath_component_detection = 0/' \\\n        -e 's/md_component_detection = 1/md_component_detection = 0/' \\\n        -e 's/notify_dbus = 1/notify_dbus = 0/' \\\n        -e 's/backup = 1/backup = 0/' \\\n        -e 's/archive = 1/archive = 0/' \\\n        /etc/lvm/lvm.conf\n\n"
}