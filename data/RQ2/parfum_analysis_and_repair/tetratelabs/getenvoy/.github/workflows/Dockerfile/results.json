{
  "startTime": 1674252465320,
  "endTime": 1674252465889,
  "originalSmells": [
    {
      "rule": "curlUseFlagF",
      "position": {
        "lineStart": 95,
        "lineEnd": 95,
        "columnStart": 33,
        "columnEnd": 59
      }
    },
    {
      "rule": "curlUseFlagF",
      "position": {
        "lineStart": 101,
        "lineEnd": 101,
        "columnStart": 32,
        "columnEnd": 57
      }
    }
  ],
  "repairedSmells": [],
  "repairedDockerfile": "# This builds Docker images similar to the GitHub Actions Virtual Environments,\n# with the dependencies we need for end-to-end (e2e) tests.\n#\n# The runtime user `runner` is setup the same as GitHub Actions also. Notably,\n# this allows passwordless `sudo` for RPM and Debian testing.\n#\n# `make e2e` requires make and go, but `CGO=0` means gcc isn't needed. Ubuntu\n# installs more packages, notably windows, for the `check` and `dist` targets.\n# To run RPM tests on CentOS, you must build them first on Ubuntu.\n#\n# This build is intended for use in a matrix, testing all major Linux platforms\n# supported by Envoy: Ubuntu and CentOS * amd64 and arm64. Notably, this adds\n# CentOS and arm64 which aren't available natively on GitHub Actions. It is\n# intended to run arm64 with Travis (as opposed to via emulation). In any case,\n# all matrixes should be pushed for local debugging.\n#\n# Ex. Build the images:\n# ```bash\n# for parent_image in ubuntu:20.04 centos:8; do docker buildx build \\\n#                --platform linux/amd64 \\\n#                --build-arg parent_image=${parent_image} \\\n#                --build-arg go_stable_release=1_18 \\\n#                --build-arg go_stable_revision=1.18.1 \\\n#                --build-arg go_prior_release=1_17 \\\n#                --build-arg go_prior_revision=1.17.9 \\\n#                -t func-e-internal:${parent_image//:/-} .github/workflows; done\n# ```\n#\n# Ex. Build func-e on Ubuntu, then end-to-end test on CentOS\n# ```bash\n# $ docker run --rm -v $PWD:/work func-e-internal:ubuntu-20.04 dist\n# $ docker run --rm -v $PWD:/work func-e-internal:centos-8 -o build/func-e_linux_amd64/func-e e2e\n# ```\n#\n# You can troubleshoot like this:\n# ```bash\n# $ docker run --rm -v $PWD:/work -it --entrypoint /bin/bash func-e-internal:centos-8\n# ```\nARG parent_image=centos:8\n\n# This section looks odd, but it is needed to match conventions of the GitHub\n# Actions runner. For example, TARGETARCH in Docker is \"amd64\" whereas GitHub\n# actions uses \"x64\". Moreover, depending on use, case format will change.\n# Docker lacks variable substitution options to do this, so we fake it with\n# stages. See https://github.com/moby/moby/issues/42904\nFROM $parent_image as base-amd64\nARG arch=X64\nARG arch_lc=x64\n\nARG LINUX\nFROM $parent_image as base-arm64\nARG arch=ARM64\nARG arch_lc=arm64\n\nFROM base-${TARGETARCH}\n\n# CentOS runs e2e, but can't run dist as Windows packages are not available.\n# While it is possible to build osslsigncode on CentOS, msitools can't due to\n# missing libgcab1-devel package. The workaround is to `make dist` with Ubuntu.\nARG centos_packages=\"make sudo\"\n# Ubuntu runs check, dist, and e2e, so needs more packages.\nARG ubuntu_packages=\"make sudo curl git zip wixl msitools osslsigncode\"\nRUN if [ -f /etc/centos-release ]; then \\\n    # Change mirrors to vault.centos.org because CentOS 8 went EOL.\n    sed -i 's/mirrorlist/#mirrorlist/g' /etc/yum.repos.d/CentOS-* && \\\n    sed -i 's|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g' /etc/yum.repos.d/CentOS-* && \\\n    # Use Dandified YUM on CentOS >=8.\n    dnf=\"dnf -qy\" && ${dnf} install ${centos_packages} && ${dnf} clean all; \\\n    else \\\n    # Use noninteractive to prevent hangs asking about timezone on Ubuntu.\n    export DEBIAN_FRONTEND=noninteractive && apt_get=\"apt-get -qq -y\" && \\\n    ${apt_get} update && ${apt_get} install ${ubuntu_packages} && ${apt_get} clean; \\\n    fi\n\n# See https://docs.docker.com/engine/reference/builder/#automatic-platform-args-in-the-global-scope\nARG TARGETARCH\n\n# This installs two GOROOTs: the stable and prior release. Two allows pull\n# requests to update from a stale release to current without a chicken-egg\n# problem or the skew and install time risks of on-demand installation. This\n# publishes only two versions as more would bloat the image.\n#\n# Build args control the precise GOROOTs to install, and should be taken from\n# the current GitHub Actions runner. Doing so allows version coherency between\n# normal runners and Docker, with version skew bounded by image push frequency.\n# See https://github.com/actions/virtual-environments for current versions.\n#\n# go_XXX_release is the underscore delimited release version. Ex. \"1_17\"\n# go_XXX_revision is the full version number. Ex. \"1.17.1\"\n#\n# These are used along with the architecture to build GOROOT variables.\n# Ex. GOROOT_1_17_X64=/opt/hostedtoolcache/go/1.17.1/x64\nARG go_stable_revision\nARG go_stable_url=https://golang.org/dl/go${go_stable_revision}.linux-${TARGETARCH}.tar.gz\nARG goroot_stable=${runner_tool_cache}/go/${go_stable_revision}/${arch_lc}\nRUN mkdir -p ${goroot_stable} && curl -f -sSL ${go_stable_url} | tar --strip-components 1 -C ${goroot_stable} -xzpf -\n\n# Dockerfile doesn't support iteration, so repeat above for the prior release.\nARG go_prior_revision\nARG go_prior_url=https://golang.org/dl/go${go_prior_revision}.linux-${TARGETARCH}.tar.gz\nARG goroot_prior=${runner_tool_cache}/go/${go_prior_revision}/${arch_lc}\nRUN mkdir -p ${goroot_prior} && curl -f -sSL ${go_prior_url} | tar --strip-components 1 -C ${goroot_prior} -xzpf -\n\n# Add and switch to the same user as the GitHub Actions runner. This prevents\n# ownership problems writing to volumes from the host to docker and visa versa.\nARG user=runner\nARG uid=1001\nARG gid=121\nRUN groupadd -f -g ${gid} docker && \\\n    useradd -u ${uid} -g ${gid} -md /home/runner -s /bin/bash -N ${user} && \\\n    echo \"${user} ALL=NOPASSWD: ALL\" >> /etc/sudoers\nUSER ${user}\n\n# Setup ENV variables used in make that match the GitHub Actions runner.\nENV RUNNER_TOOL_CACHE ${runner_tool_cache}\nARG go_stable_release\nENV GOROOT_${go_stable_release}_${arch} ${goroot_stable}\nARG go_prior_release\nENV GOROOT_${go_prior_release}_${arch} ${goroot_prior}\n\n# Disable gcc to avoid a build dependency on gcc: its glibc might affect Envoy.\nENV CGO_ENABLED 0\n\n# Set CWD to the work directory to avoid overlaps with $HOME.\nWORKDIR /work\n\n# Almost everything uses make, but you can override `--entrypoint /bin/bash`.\nENTRYPOINT [\"/usr/bin/make\"]\nCMD [\"help\"]\n"
}