{
  "startTime": 1674216379791,
  "endTime": 1674216381143,
  "originalSmells": [
    {
      "rule": "yarnCacheCleanAfterInstall",
      "position": {
        "lineStart": 45,
        "lineEnd": 45,
        "columnStart": 5,
        "columnEnd": 21
      }
    },
    {
      "rule": "yarnCacheCleanAfterInstall",
      "position": {
        "lineStart": 55,
        "lineEnd": 55,
        "columnStart": 4,
        "columnEnd": 14
      }
    },
    {
      "rule": "pipUseNoCacheDir",
      "position": {
        "lineStart": 27,
        "lineEnd": 27,
        "columnStart": 5,
        "columnEnd": 47
      }
    }
  ],
  "repairedSmells": [
    {
      "rule": "yarnCacheCleanAfterInstall",
      "position": {
        "lineStart": 45,
        "lineEnd": 45,
        "columnStart": 25,
        "columnEnd": 41
      }
    },
    {
      "rule": "yarnCacheCleanAfterInstall",
      "position": {
        "lineStart": 57,
        "lineEnd": 57,
        "columnStart": 41,
        "columnEnd": 57
      }
    }
  ],
  "repairedDockerfile": "# This Dockerfile can be used to deploy a production instance\n# to Heroku.\n#\n# It builds upon the image in the base Dockerfile, adding\n# extra directives to install all dependencies, generate static\n# assets, and so forth, so that the final container is completely\n# self-contained.\n\nFROM justfixnyc/tenants2_base:0.10\n\n# The way we're using lots of layers here is intentional, as\n# we're first installing our dependencies--which don't change\n# very often--and then copying over the rest of our source code,\n# which does change often. This means we can iterate faster\n# because we e.g. don't have to re-install all our dependencies\n# if we change a single line of code (it also reduces the amount\n# of data we need to transfer to send our image somewhere, if\n# the destination already has cached layers from previous\n# builds we've sent).\n\nENV NODE_ENV=production\n\nCOPY Pipfile* requirements.production.txt /var/tenants2/\n\nWORKDIR /var/tenants2\n\nRUN pipenv install --system --keep-outdated \\\n  && pip install --no-cache-dir -r requirements.production.txt \\\n  && rm -rf ~/.cache\n\nWORKDIR /tenants2\n\n# This contains the fake version of a npm module that we need on the\n# filesystem so yarn can install dependencies. For more details, see\n# https://github.com/JustFixNYC/tenants2/pull/1661.\nCOPY frontend/fake-opencollective /tenants2/frontend/fake-opencollective\n\nCOPY package.json yarn.lock /tenants2/\n\n# Make sure we run as a non-root user.\nRUN useradd -m myuser\nRUN chown myuser /tenants2\nUSER myuser\n\nRUN yarn install --frozen-lockfile \\\n  && yarn cache clean && yarn cache clean;\n\nADD --chown=myuser:myuser . /tenants2/\n\nARG GIT_REVISION\nARG IS_GIT_REPO_PRISTINE\n\nENV GIT_REVISION=$GIT_REVISION\nENV IS_GIT_REPO_PRISTINE=$IS_GIT_REPO_PRISTINE\n\nRUN yarn build \\\n  && python manage.py collectstatic \\\n  && python manage.py compilemessages && yarn cache clean;\n\nCMD gunicorn --bind 0.0.0.0:$PORT project.wsgi\n"
}