{
  "user": "theonestack",
  "name": "cfhighlander",
  "namespace": "theonestack",
  "repository_type": "image",
  "status": 1,
  "status_description": "active",
  "description": "DSL processor that enables composition and orchestration of Amazon CloudFormation templates",
  "is_private": false,
  "is_automated": true,
  "can_edit": false,
  "star_count": 0,
  "pull_count": 56164,
  "last_updated": "2022-05-17T00:49:23.719281Z",
  "date_registered": "2018-05-29T01:15:00.419432Z",
  "collaborator_count": 0,
  "affiliation": null,
  "hub_user": "theonestack",
  "has_starred": false,
  "full_description": "[![Build Status](https://travis-ci.org/theonestack/cfhighlander.svg?branch=develop)](https://travis-ci.org/theonestack/cfhighlander) [![Join the chat at https://gitter.im/theonestack/cfhighlander](https://badges.gitter.im/theonestack/cfhighlander.svg)](https://gitter.im/theonestack/cfhighlander?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\n# Intro\n\nCfhighlander is a feature rich tool and DSL for infrastructure\ncoders working with CloudFormation templates.\n\nIt was designed to\n\n-  Abstract AWS resources or sets of resources as\n   **components** by describing them using Cfhighlander\n   DSL and [cfndsl](https://github.com/cfndsl/cfndsl).\n\n- Produce, validate and publish CloudFormation templates\n  from those components\n\n- Enable infrastructure coders to use concepts of **inheritance**\n  and **composition** when designing components. In other words\n  allowing components to be *extended*, and allowing components\n  to be built from other components.\n\n- Allow for easy **discovery** and consumption of components from\n  different sources (git repository, file system, S3 buckets)\n\n - Allow component developers and consumers to take\n   more **descriptive** approach using DSL, compared to\n   instructional approach.\n\n# Installation\n\n```\ngem install cfhighlander\n```\n\n# Example\n\nPassing output value from one substack to another substack within root stack\nhas to be done manually - either if you build JSON/YAML templates by hand,\nor if using `Cfndsl`. With cfhighlander, this code is automatically generated for you\n\n```ruby\n## place contents below in file name application.cfhighlander.rb\nCfhighlanderTemplate do\n\n  # explicit configuration for vpc component\n  vpc_config = { 'maximum_availability_zones' => 2 }\n\n  # declare vpc component, and pass some parameters\n  # to it\n  Component name: 'vpc',\n        template: 'vpc@master.snapshot',\n        config: vpc_config do\n    parameter name: 'Az0', value: FnSelect(0,FnGetAZs())\n    parameter name: 'Az1', value: FnSelect(1,FnGetAZs())\n    parameter name: 'DnsDomain', value: 'example.com'\n    parameter name: 'StackMask', value: '16'\n  end\n\n  # Compiled cloudformation template will\n  # pass Compute subnets from VPC into ECS Cluster\n  Component name: 'ecs', template:'ecs@master.snapshot' do\n    parameter name: 'DnsDomain', value: 'example.com'\n  end\n\n  # feed mapping maparameters to components\n  addMapping('EnvironmentType',{\n    'development' => {\n      'MaxNatGateways'=>'1',\n      'EcsAsgMin' => 1,\n      'EcsAsgMax' => 1,\n      'KeyName' => 'default',\n      'InstanceType' => 't2.large',\n      'SingleNatGateway' => true\n    }\n  })\nend\n\n```\n\n... compile the template with ...\n\n```shell\ncfcompile application\n```\n\n... and check how the subnets are being passed around ..\n\n```shell\n$ cat out/yaml/application.compiled.yaml | grep  -A3 SubnetCompute0\n          SubnetCompute0:\n            Fn::GetAtt:\n            - vpc\n            - Outputs.SubnetCompute0\n          SubnetCompute1:\n            Fn::GetAtt:\n            - vpc\n\n```\n\n\n\n# Component library\n\nAs part of [theonestack org](https://github.com/theonestack/), there are many publicly available components.\n\n- [vpc](https://github.com/theonestack/hl-component-vpc) - Has separation of public\n   and private subnets, configurable number of NAT Gateways (per AZ or single for all\n  subnets), lays out default subnets (private - compute, storage and cache, public), as well as their route tables\n\n- [ecs](https://github.com/theonestack/hl-component-ecs) - ECS Cluster deployed in VPC Compute Subnets\n- [bastion](https://github.com/theonestack/hl-component-bastion) - Deployed into VPC Public subnets\n  Subnets, with configuration for whitelisting IP addresses to access port 22\n- [ecs-service](https://github.com/theonestack/hl-component-ecs-service) - Deploy containerised apps running on ECS Clusters\n- [loadbalancer](https://github.com/theonestack/hl-component-loadbalancer) - ALB, ELB or NLB\n- [sns](https://github.com/theonestack/hl-component-sns) - SNS Topics, with implemented\nLambda function to post Slack messages\n- [efs](https://github.com/theonestack/hl-component-efs) - Elastic File System, can be\nused in conjuction with ECS Cluster\n- [rds-mysql](https://github.com/theonestack/hl-component-rds-mysql) - RDS Component for MySQL engine\n- [rds-postgres](https://github.com/theonestack/hl-component-rds-postgres) - RDS Component for Postgres engine\n- [aurora-mysql](https://github.com/theonestack/hl-component-aurora-mysql) - Aurora component for MySQL engine\n- [aurora-postgres](https://github.com/theonestack/hl-component-aurora-postgres) - Aurora component for Postgres engine\n- [elasticache-memcache](https://github.com/theonestack/hl-component-elasticache-memcache) - Aws Elasticache - Memcache engine\n- [elasticache-memcache](https://github.com/theonestack/hl-component-elasticache-redis) - Aws Elasticache - Redis engine\n- [asg](https://github.com/theonestack/hl-component-asg) - AutoScalingGroup component\n- [cognito](https://github.com/theonestack/hl-component-cognito) - Cognito user pools, custom domain names and clients\n\nYou can easily test any of these. Automatic component resolver will default\nto 'https://github.com/theonestack/hl-component-$name' location if component\nis not found in local sources.\n\nFrom shell, command below will generate cloudformation for given component in `out` folder\n```shell\ncfcompile component_name\n```\n\nOr from outer cfhighlander template, just pull component using `Component` DSL statement\n\n```ruby\nCfhighlanderTemplate do\n  Component component_name\nend\n```\n\n\n# How it works ?\n\nHighlander DSL produces CloudFormation templates in 4 phases\n\n- Processing referenced component's configuration and resolving configuration exports\n- Wiring parameters from components to their inner components\n- Producing [CfnDsl](https://github.com/cfndsl/cfndsl) templates for all components and subcomponents as intermediary\n  step\n- Producing resulting CloudFormation templates using configuration and templates generated in two previous phases.\n\nEach phase (aside from parameter wiring) above is executable as stand-alone through CLI, making development of Highlander templates easier by enabling\ndebugging of produced configuration and cfndsl templates.\n\n\n## Highlander components\n\nHighlander component is located on local file system or S3 location with following\nfiles defining them\n\n- Highlander DSL file (`$componentname.highlander.rb`)\n- *(Optional)* Configuration files (`*.config.yaml`)\n- *(Optional)* CfnDSL file (`componentname.cfnds.rb`)\n- *(Optional)* Mappings YAML files `*.mappings.yaml` -\nthis file defines map used within component itself\n- *(Optional)* Mappings extension file `componentname.mappings.rb` - see more under Mappings section\n- *(Optional)* Ruby extensions consumed by cfndsl templates - placed in `ext/cfndsl/*.rb` - see more under\n Extensions section\n\n## Terminology\n\n**Component** is basic building block of highlander systems. Components have following roles\n\n- Define (include) other components\n- Provide values for their inner component parameters\n- Define how their configuration affects other components\n- Define sources of their inner components\n- Define publish location for both component source code and compiled CloudFormation templates\n- Define cfndsl template used for building CloudFormation resources\n\n\n**Outer component** is component that defines other component via cfhighlander dsl `Component` statement. Defined component\nis called **inner component**. Components defined under same outer component are **sibling components**\n\n## Usage\n\nYou can either pull highlander classes in your own code, or more commonly use it via command line interface (cli).\nFor both ways, highlander is distributed as ruby gem\n\n\n```bash\n$ gem install cfhighlander\n$ cfhighlander help\ncfhighlander commands:\n  cfhighlander cfcompile component[@version] -f, --format=FORMAT   # Compile Highlander component to CloudFormation templates\n  cfhighlander cfpublish component[@version] -f, --format=FORMAT   # Publish CloudFormation template for component, and it' referenced subcomponents\n  cfhighlander configcompile component[@version]                   # Compile Highlander components configuration\n  cfhighlander dslcompile component[@version] -f, --format=FORMAT  # Compile Highlander component configuration and create cfndsl templates\n  cfhighlander help [COMMAND]                                      # Describe available commands or one specific command\n  cfhighlander publish component[@version] [-v published_version]  # Publish CloudFormation template for component, and it' referenced subcomponents\n\n```\n### Working directory\n\nAll templates and configuration generated are placed in `$WORKDIR/out` directory. Optionally, you can alter working directory\nvia `CFHIGHLANDER_WORKDIR` environment variable.\n\n### Commands\n\nTo get full list of options for any of cli commands use `highlander help command_name` syntax\n\n```bash\n$ cfhighlander help publish\nUsage:\n  cfhighlander publish component[@version] [-v published_version]\n\nOptions:\n      [--dstbucket=DSTBUCKET]  # Distribution S3 bucket\n      [--dstprefix=DSTPREFIX]  # Distribution S3 prefix\n  -v, [--version=VERSION]      # Distribution component version, defaults to latest\n\nPublish CloudFormation template for component,\n            and it's referenced subcomponents\n\n```\n\n#### Silent mode\n\nCfhighlander DSL processor has built-in support for packaging and deploying AWS Lambda functions. Some of these lambda\nfunctions may require shell command to be executed (e.g. pulling library dependencies) prior their packaging in ZIP archive format.\nSuch commands are potential security risk, as they allow execution of arbitrary code, so for this reason user agreement is required\ne.g:\n\n```bash\nPackaging AWS Lambda function logMessage...\nFollowing code will be executed to generate lambda function logMessage:\n\npip install requests -t lib\n\nProceed (y/n)?\n```\n\nIn order to avoid user prompt pass `-q` or `--quiet` switch to CLI for commands that require Lambda packaging\n(`dslcompile`, `cfcompile`, `cfpublish`)\n\n\n#### cfcompile\n\n*cfcompile* will produce cloudformation templates in specified format (defaults to yaml). You can optionally validate\nproduced template via `--validate` switch. Resulting templates will be placed in `$WORKDIR/out/$format`\n\n\n#### cfpublish\n\n*cfcompile* will produce cloudformation templates in specified format (defaults to yaml), and publish them to S3 location.\nYou can optionally validate produced template via `--validate` switch. Resulting templates will be placed in `$WORKDIR/out/$format`, and\npublished to `s3://$distributionBucket/$distributionPrefix/$distributionVersion`. All S3 path components can be controlled\nvia CLI (`--dstbucket`, `--dstprefix`, `-v`). Default distribution bucket and prefix can be also be controlled via DSL using\n`DistributionBucket`, `DistributionBucket`, `DistributionPrefix` or `ComponentDistribution` statements. Check DSL specification\nfor more details on this statements. Version defaults to `latest` if not explicitly given using `-v` switch\n\nIf no distribution options is given using mentioned CLI options or DSL statements,\nbucket will be automatically created for you. Bucket name defaults to\n`$ACCOUNT.$REGION.cfhighlander.templates`, with `/published-templates`\nprefix.\n\n*cfpublish* command will give you quick launch CloudFirmation stack URL to assist\nyou in creating your stack:\n\n```bash\n$ cfpublish vpc@1.2.0\n...\n...\n...\n\nUse following url to launch CloudFormation stack\n\nhttps://console.aws.amazon.com/cloudformation/home#/stacks/create/review?filter=active&templateURL=https://123456789012.ap-southeast-2.cfhighlander.templates.s3.amazonaws.com/published-templates/vpc/1.2.0/vpc.compiled.yaml&stackName=vpc\n\n```\n\n\n#### configcompile\n\n*configcompile* produces configuration yamls that are passed as external configuration when processing\ncfndsl templates. Check component configuration section for more details.\n\n#### dslcompile\n\n*dslcompile* will produce intermediary cfndsl templates. This is useful for debugging cfhighlander components\n\n#### publish\n\n*publish* command publishes cfhighlander components source code to s3 location (compared to *cfpublish* which is publishing\ncompiled cloudformation templates). Same CLI / DSL options apply as for *cfpublish* command. Version defaults to `latest`\n\n\n## Component configuration\n\nThere are 4 levels of component configuration\n\n- Component local config file `component.config.yaml` (lowest priority)\n- Outer component configuration file, under `components` key, like\n\n\n```yaml\n\n# some configuration values\n\ncomponents:\n  vpc:\n    config:\n      maximum_availibility_zones: 2\n\n```\nThis configuration level overrides component's own config file.\nAlternatively, to keep things less nested in configuration hierarchy, creating config file `vpc.config.yaml`\nfor component named `vpc` works just as well:\n\n```yaml\n\n# contents of vpc.config.yaml in outer component, defining vpc component\n\n# line below prevents component configuration file being merged with outer component configuration\nsubcomponent_config_file:  \n\n# there is no need for components/vpc/config structure, it is implied by file name\nmaximum_availibility_zones: 3\n\n\n```\n\n\n- Outer component explicit configuration. You can pass `config` named parameter to `Component` statement, such as\n\n```ruby\nCfhighlanderTemplate do\n\n# ...\n# some dsl code\n# ...\n\n   Component template:'vpc@latest',config: {'maximum_availibility_zones' => 2}\n\nend\n```\nConfiguration done this way will override any outer component config coming from configuration file\n\n\n- Exported configuration from other components. If any component exports configuration using `config_export` configuration\n  key, it may alter configuration of other components. Globally exported configuration is defined under `global`, while\n  component-oriented configuration is exported under `component` key. E.g. following configuration will export global\n  configuration defining name of ecs cluster, and targeted to vpc component configuration, defining subnets\n\n```yaml\necs_cluster_name: ApplicationCluster\n\nsubnets:\n  ecs_cluster:\n    name: ECSCluster\n    type: private\n    allocation: 20\n\nconfig_export:  \n  global:\n    - ecs_cluster_name\n\n  component:\n    vpc:\n      - subnets\n```\n\nConfiguration is exported **AFTER** component local config, and outer component configurations are loaded.\nOuter component configuration takes priority over exported configuration, as this configuration is loaded once\nmore once component exported conifgurations are applied to appropriate components.  \n\nTo change *NAME* of targeted component (e.g. from `vpc` to `vpc1`), you can use `export_config` named parameter on `Component` dsl method\nIn addition to configuration in inner component above, wiring of targeted component for export would be done like\n\n```ruby\nComponent name: 'vpc1', template: 'vpc'\nComponent name: 'ecs_cluster', template: 'ecs_cluster@latest', export_config: {'vpc' => 'vpc1'}\n```\n## CloudFormation mappings\n\n[CloudFormation Mappings](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/mappings-section-structure.html)\nsection matches a key to a corresponding set of named values. Highlander allows you to define this mappings in two ways\n\n1. By using static maps defined through YAML files. Place `*.mappings.yaml` file alongside with highlander\ntemplate to define mappings this way. Mappings defined in a static way are automatically rendered withing CloudFormation\ntemplate E.g.\n\n```yaml\n# Master component mappings\n# envtype.mappings.yaml\nEnvironmentType:\n  dev:\n    InstanceType: t2.medium\n  prod:\n    InstanceType: m4.medium\n```\n\n2. By defining mappings dynamically through Ruby code. Alongside with mappings, you can define default map name, and default\nmap key to be used when looking up value within this map. This mappings are usually rendered in outer component when inner\ncomponents pulls mapping value as parameter via `MappingParam` statement. Optionally, this mappings can be rendered within\ncomponent that defines them using `DynamicMappings` DSL statement.\n\n## Extensions\n\n### Cfndsl extensions\n\nIn order to make template more DRY, template developer may reuse ruby functions. It is possible to place\nsuch functions in separate files. Any ruby files placed within `ext/cfndsl` directory will get automatically\nincluded via Ruby `require` function in compiled Cfndsl template.\n\n## Component DSL\n\n### Inner components or subcomponents\n\nInner components or subcomponents are defined via `Component` DSL statement\n\n```ruby\nCfhighlanderTemplate do\n\n  # Example1 : Include component by template name only\n  Component 'vpc'\n\n  # Example2 : Include component by template name, version and give it a name\n  Component template: 'ecs@master.snapshot'\n\nend\n\n```\n\n**Conditional components** - If you want to add top level paramater as feature toggle for one of the inner\ncomponents, just mark it as conditional, using `conditional:` named parameter. In addition to this, default\nvalue for feature toggle can be supplied using `enabled:` named parameter\n\n\n```ruby\n\n# Include vpc and 2 ecs clusters with feature flags\nCfhighlanderTemplate do\n\n  # vpc component\n  Component 'vpc'\n\n  # Ecs Cluster 1 has feature toggle, enabled by default\n  Component name: 'ecs1', template: 'ecs', conditional: true\n\n  # Ecs Cluster 2 has feature toggle, and is explicitly disabled by default\n  Component name: 'ec2', template: 'ecs', conditional: true, enabled: false\n\nend\n\n```\n\n**Convert config value to parameter** - In case of inner component having configuration value\nyou wish to expose as runtime parameter, it is possible to do so with limitation that configuration\nvalue is only used in *resource declarations*, as property value. If configuration value is being used\nto control the dsl flow, taking part in any control structure statements, and such gets evaluated at\n**compile** time, there is no sense of making CloudFormation stack parameter out of it.\n\nBelow example demonstrate use of `ConfigParameter` statement on simple S3 Bucket component -\nit assumes that `s3bucket` template exists with `bucketName` as configuration value for it.\n\n\n```ruby\nCfhighlanderTemplate do\n\n    Component template: 's3bucket', name: 'parameterizedBucket' do\n        ConfigParameter config_key: 'bucketName', parameter_name: '', type: 'String'\n    end\n\nend\n\n\n```\n\n### Parameters\n\nParameters block is used to define CloudFormation template parameters, and metadata on how they\nare wired with outer or sibling components.\n\n```ruby\nCfhighlanderTemplate do\n  Parameters do\n    ##\n    ##  parameter definitions here\n    ##\n  end\nend\n```\n\nParameter block supports following parameters\n\n#### ComponentParam\n\n`ComponentParam` - Component parameter exposes parameter to be wired from outer component. Cfhighlander's\nautowiring mechanism will try and find any stack outputs from other components defined by outer components with name\nmatching. If there is no explicit value provided, or autowired from outputs, parameter will be propagated to outer component.\n\nPropagated parameter will be prefixed with component name **if it is not defined as global parameter**. Otherwise,\nparameter name is kept in full.\n\nExample below demonstrates 3 different ways of providing parameter values from outer to inner component.\n\n- Provide value explicitly\n- Provide value explicitly as output of another component     \n- Autowire value from output of another component with the same name\n- Propagate parameter to outer component\n\n```ruby\n\n# Inner Component 1\nCfhighlanderTemplate do\n  Name 's3'\n  Parameters do\n     ComponentParam 'BucketName','highlander.example.com.au'\n     ComponentParam 'BucketName2',''\n     ComponentParam 'BucketName3',''\n     ComponentParam 'BucketName4','', isGlobal: false # default value is false\n     ComponentParam 'BucketName5','', isGlobal: true\n  end\n\nend\n\n```\n\n```ruby\n# Inner Component 2\nCfhighlanderTemplate do\n  Name 'nameproducer'\n\n  # has output 'bucket name defined in cfdnsl\nend\n\n\n# -- contents of cfndsl\nCloudFormation do\n\n    Condition 'AlwaysFalse', FnEquals('true','false')\n    S3_Bucket :resourcetovalidateproperly do\n      Condition 'AlwaysFalse'\n    end\n\n    Output('BucketName') do\n        Value('highlanderbucketautowired.example.com.au')\n    end\nend\n\n\n```\n\n```ruby\n# Outer component\nCfhighlanderTemplate do\n    Component 'nameproducer'\n    Component 's3' do\n      parameter name: 'BucketName2', value: 'nameproducer.BucketName'\n      parameter name: 'BucketName3', value: 'mybucket.example.cfhighlander.org'\n    end\nend\n\n```\n\n\nExample above translates to following wiring of parameters in cfndsl template\n```ruby\nCloudFormation do\n\n     # Parameter that was propagated\n    Parameter('s3BucketName4') do\n      Type 'String'\n      Default ''\n      NoEcho false\n    end\n\n    Parameter('BucketName5') do\n      Type 'String'\n      Default ''\n      NoEcho false\n    end\n\n   CloudFormation_Stack('s3') do\n       TemplateURL './s3.compiled.yaml'\n       Parameters ({\n\n          # Paramater that was auto-wired\n           'BucketName' => {\"Fn::GetAtt\":[\"nameproducer\",\"Outputs.BucketName\"]},\n\n          # Parameter that was explicitly wired as output param from another component\n           'BucketName2' => {\"Fn::GetAtt\":[\"nameproducer\",\"Outputs.BucketName\"]},\n\n          # Paramater that was explicitly provided\n           'BucketName3' => 'mybucket.example.cfhighlander.org',\n\n          # Reference to parameter that was propagated. isGlobal: false when defining\n          # parameter, so parameter name is prefixed with component name\n           'BucketName4' => {\"Ref\":\"s3BucketName4\"},\n\n          # Reference to parameter that was propagated. isGlobal: true when defining\n          # parameter, so parameter name is not prefixed, but rather propagated as-is\n          'BucketName5' => {\"Ref\":\"BucketName5\"},\n\n       })\n   end\nend\n\n```\n\n\n#### MappingParam\n\n`MappingParam` - Mapping parameters value is passed as CloudFormation mapping lookup from outer component.\nThis DSL statements takes a full body, as Mapping name, Map key, and value key need to be specified. `key`,\n `attribute` and `map` methods are used to specify these properties. Mapping parameters involve ruby code execution\n\n\n\n ```ruby\n# Inner component\nCfhighlanderTemplate do\n  Name 's3'\n  Parameters do\n    MappingParam 'BucketName' do\n      map 'AccountId'\n      attribute 'DnsDomain'\n    end\n  end\nend\n ```\n\n\n### DependsOn\n\n`DependsOn` - this will include any globally exported libraries from given\ntemplate. E.g.\n\n ```ruby\nCfhighlanderTemplate do\n  Name 's3'\n  DependsOn 'vpc@1.0.3'\nend\n ```\n\nWill include any cfndsl libraries present and exported in vpc template\nso extension methods can be consumed within cfndsl template.\n\n### LambdaFunctions\n\n#### Packaging and publishing\n\n#### Rendering\n\n#### Referencing\n\n\n## Finding templates and creating components\n\n\nTemplates are located by default in following locations\n\n- `$WD`\n- `$WD/$componentname`\n- `$WD/components/$componentname`\n- `~/.cfhighlander/components/componentname/componentversion`\n- `https://github.com/cfhighlander/theonestack/hl-component-$componentname` on `master` branch\n\nLocation of component templates can be given as git/github repo:\n\n```ruby\n\nCfhighlanderTemplate do\n\n      # pulls directly from master branch of https://github.com/theonestack/hl-component-vpc\n      Component name: 'vpc0', template: 'vpc'\n\n      # specify branch github.com: or github: work. You specify branch with hash\n      Component name: 'vpc1', template: 'github:theonestack/hl-component-vpc#master'\n\n      # you can use git over ssh\n      # Component name: 'vpc2', template: 'git:git@github.com:theonestack/hl-component-vpc.git'\n\n      # use git over https\n      Component name: 'vpc3', template: 'git:https://github.com/theonestack/hl-component-sns.git'\n\n      # specify .snapshot to always clone fresh copy\n      Component name: 'vpc4', template: 'git:https://github.com/theonestack/hl-component-sns.git#master.snapshot'\n\n      # by default, if not found locally, highlander will search for https://github.com/theonestack/component-$componentname\n      # in v${version} branch (or tag for that matter)\n      Component name: 'vpc5', template: 'vpc@1.0.4'\n\nend\n\n```\n## Render mode for components\n\nRendering component resources in resulting cloudformation stack is available in 2 modes. These modes\nare controlled using `render` keyword of `Component` DSL statement\n\n`Substack` - creates additional substack for cfhighlander component and points to it using [CloudFormation\nStack](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-stack.html) resource type\nThis is also default render mode - if no render mode is specified `Substack` will be used\n\n`Inline` - places all defined resources from inner component in outer component cloudformation template. Resources,\nOutputs, Conditions, Parameters and Mappings are all inlined - please note that some of the template elements may be renamed in this\nprocess in order to assure uniq",
  "permissions": {
    "read": true,
    "write": false,
    "admin": false
  },
  "media_types": [
    "application/vnd.docker.container.image.v1+json"
  ],
  "content_types": [
    "image"
  ]
}