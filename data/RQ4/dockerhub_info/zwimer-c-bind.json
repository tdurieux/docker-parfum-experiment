{
  "user": "zwimer",
  "name": "c-bind",
  "namespace": "zwimer",
  "repository_type": "image",
  "status": 1,
  "status_description": "active",
  "description": "Dynamic partial function application in C !!!",
  "is_private": false,
  "is_automated": false,
  "can_edit": false,
  "star_count": 0,
  "pull_count": 55,
  "last_updated": "2019-04-24T04:24:15.977861Z",
  "date_registered": "2019-02-24T17:54:19.256692Z",
  "collaborator_count": 0,
  "affiliation": null,
  "hub_user": "zwimer",
  "has_starred": false,
  "full_description": "# C-bind: Dynamic function binding in C !!!\n[![Build Status](https://api.travis-ci.org/zwimer/C-bind.svg?branch=master)](https://travis-ci.org/zwimer/C-bind)\n\n# Table of Contents\n\n1. [Requirements](#requirements)\n1. [Usage](#usage)\n\t- [General](#general)\n\t- [SystemV](#systemv)\n\t- [Non-SystemV](#non-systemv)\n1. [Examples](#examples)\n1. [Compilation](#compilation)\n1. [Docker](#docker)\n1. [CI](#ci)\n1. [Documentation](#documentation)\n1. [Future Plans](#future-plans)\n\n---\n\n# Requirements\nCurrently `C-bind` requires `pthread` to be installed, and requires `x86_64`. `C-bind` has only been tested on `Ubuntu 18.04`, compiled with `gcc 7.3`.\n\n# Usage\n\n## General\n\n### Includes\nTo link the `C-bind` library simply include the header file ```bind.h```.\n\n### Note\nPassing extra arguments to a bound func will result in them being ignored.\n\n### SystemV vs Non-SystemV\n\nThe most common calling convention of `x86_64` / `amd64` is called SystemV. Unless otherwise specified, most major compilers should compile your code to meet this standard. This library provides functions for binding functions that follow the SystemV calling convention; functions that are not compliant have an API for them is provided for them as well. The default API of this library assumes SystemV functions are being bound.\n\n### Important notes\n1. This library uses a signal internally. By default this is `SIGUSR2`, however the user may change this whenever. This signal handler is install when-needed and restored when not, so for a single threaded application this is perfectly safe. However, in a multi-threaded enviornment it is important to set this signal to some (valid) unused signal! This can be done with the `bind_set_signal_number` function.\n\n### Thread Safe\nYes, as long as this library is the only thing that invokes the signal set by `bind_set_signal_number`.\n\n### Restrictions\n1. This library may not work with variadic functions\n1. This library *may* fail for SystemV if registers other than `rdi`, `rsi,` `rdx`, `rcx`, `r8`, and `r9` are used to pass arguments. However this is exceedingly rare.\n1. This library will only compile for `x86_64` / `amd64`\n\n## SystemV\n\n### Function Signature\nSystemV functions to be bound must return an object of type `ret_t` (which should be 8 bytes) or smaller; `void` is also valid. Do not attempt to return a large struct as it may fail! As for the arguments of the function, there are no restrictions except that the function may not be variadic! For more info look in the `bind.h` file.\n\n### Full binding\nTo fully bind a functon, invoke\n```C\nbound_func = full_bind( my_func, num_args, arg1, arg2, arg3 );\n```\nHere `num_args` is the number of arguments to pass to be passed to `my_func`. If more than `num_args` arguments are passed they will be ignored.\n\n### Full binding example\n```C\nint sum( int a, int b ) { return a + b; }\nFullBound bound_func = full_bind( sum, 2, /* Arguments begin */ 1, 2 );\nprintf( \"sum(1,2) = %d\", (int) bound_func() );\n```\nThe output of this code is: `sum(1,2) = 3`.\n\n### Partial binding\nTo partially bind a function, invoke\n```C\nbound_func = partial_bind( my_func, num_args, num_args_to_bind, arg1, arg2 );\n```\nHere `num_args_to_bind` is the number of arguments currently being bound!\n\nIt is worth noting that fully binding a function via a partial bind is supported.\n\n### Partial binding Example\n```C\nint sum3(int a, int b, int c) { return a + b + c; }\nPartBound bound_func = partial_bind( sum3, 3, 2, /* Arguments begin */ 100, 200 );\nprintf( \"Total sum = %d\", (int) bound_func(300) );\n```\nThe output of this code is: `Total sum = 600`\n\n## Non-SystemV\n\n### Signature\nNon-SystemV functions to be bound must have a unique signature, however when calling them they may be called as standard functions.\nTo bind a function, it must have the following signature:\n```C\nret_t my_func( arg_t * args );\n```\nA `ret_t` is simply a `void *`. A non-`void *` may be returned via casting so long as it is of equal or lesser size. You can think of `args` as an array of arguments! The function being bound may not be variadic, consequently, `my_func` must have a defined maximum number of 'arguments'. *That is, `my_func` must expect that no more `num_args` number of elements to be passed.* For more info look in the `bind.h` file. Parsing the `args` array is the job of `my_func`.\n\n### Full binding\nTo fully bind a function, invoke\n```C\nbound_func = full_bind( my_func, num_args, arg1, arg2, arg3 );\n```\nHere `num_args` is the number of elements in the `args` array that `my_func` expects to be passed. If more arguments than `num_args` arguments are passed in they will be ignored.\n\n### Full binding Example\n```C\nret_t sum( arg_t * args ) { return args[0] + args[1]; }\nFullBound bound_func = full_systemv_bind( sum, 2, /* Arguments begin */ 1, 2 );\nprintf( \"sum(1,2) = %d\", (int) bound_func() );\n```\nThe output of this code is: `sum(1,2) = 3`.\n\n### Partial binding\nTo partially bind a function, invoke\n```C\nbound_func = partial_bind( my_func, num_args, num_args_to_bind, arg1, arg2 );\n```\nHere `num_args_to_bind` is the number of arguments currently being bound!\n\nIt is worth noting that fully binding a function via a partial bind is supported.\n\n### Partial binding Example\n```C\nret_t sum3( arg_t * args ) { return args[0] + args[1] + args[2]; }\nPartBound bound_func = partial_systemv_bind( sum3, 3, 2, /* Arguments begin */ 100, 200 );\nprintf( \"Total sum = %d\", (int) bound_func(300) );\n```\nThe output of this code is: `Total sum = 600`\n\n---\n\n# Examples\nTo test the examples first compile the code\n```bash\ngit clone https://github.com/zwimer/C-bind && \\\nmkdir C-bind/build && cd C-bind/build && \\\ncmake ../examples && make\n```\n\nAfter that, run your desired test. Either `./test.out` (for SystemV tests) or `./test-non-systemv.out`.\n\n# Compilation\nOn `gcc` version`7.3`, this library is able to compile even with the `-O3` flag. If you experience issues however, try compiling at a lower optimization level. See the `CMakeLists.txt` file in the `examples` directory for an example.\n\n# Docker\nA `Dockerfile` is provided with `C-bind` and example cases installed and build. The image is hosted [here](https://cloud.docker.com/repository/docker/zwimer/c-bind) on [docker.com](https://docker.com). To pull the image just execute:\n```bash\ndocker pull zwimer/c-bind\n```\nTo run the container simply execute:\n```bash\ndocker run --rm -it zwimer/c-bind\n```\nIf you would like to build the container yourself execute:\n```bash\ngit clone https://github.com/zwimer/C-bind && \\\ncd C-bind && \\\ndocker build -t zwimer/c-bind .\n```\n\n# CI\n\nContinuous Integration is provided by [Travis CI](https://travis-ci.org). To view the CI setup, click [here](https://travis-ci.org/zwimer/C-bind/).\n\n# Documentation\n\nDocumentation is stored in on the `gh-pages` branch and hosted [here](https://zwimer.github.io/C-bind/docs/html/index.html) on [zwimer.com](https://zwimer.com). Documentation is generated via [doxygen](http://www.doxygen.nl/). To manually generate it install doxygen (from `apt-get` if you have it) then\n```bash\ncd C-bind && doxygen\n```\n\n# Future Plans\n1. Right now hidden in the internals of how the binding mechanism, the `get_stub` function maps an entire page of memory per stub generated. Realistically it should only require just a few bytes. This can be done by placing multiple stub functions on the same page.\n",
  "permissions": {
    "read": true,
    "write": false,
    "admin": false
  },
  "media_types": [
    "application/vnd.docker.container.image.v1+json"
  ],
  "content_types": [
    "image"
  ]
}