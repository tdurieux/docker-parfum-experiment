{
  "user": "nsuke",
  "name": "protobuf-qml",
  "namespace": "nsuke",
  "repository_type": "image",
  "status": 1,
  "status_description": "active",
  "description": "protobuf-qml  build environment",
  "is_private": false,
  "is_automated": true,
  "can_edit": false,
  "star_count": 1,
  "pull_count": 2910,
  "last_updated": "2018-04-14T00:41:59.914844Z",
  "date_registered": "2015-11-26T17:35:13.367865Z",
  "collaborator_count": 0,
  "affiliation": null,
  "hub_user": "nsuke",
  "has_starred": false,
  "full_description": "protobuf-qml\n============\n\n[![Build Status](https://travis-ci.org/nsuke/protobuf-qml.svg?branch=master)](https://travis-ci.org/nsuke/protobuf-qml)\n[![Build status](https://ci.appveyor.com/api/projects/status/3gaaq96kndvdwvno/branch/master?svg=true)](https://ci.appveyor.com/project/nsuke/protobuf-qml)\n\nEfficient schematized serialization and RPC for QtQuick2 applications through Protocol Buffers and gRPC bindings.\n\n## Usage\n\nFor installation, see [INSTALL.md](INSTALL.md).\n\n### Protocol Buffers binding\n\nFor Protocol Buffers itself, see upstream official site:\n\nhttps://developers.google.com/protocol-buffers/\n\n#### Code generation\nSuppose you write following .proto file, say `my_foo.proto`:\n\n```\n    message Foo {\n      string text = 1;\n      repeated uint32 nums = 2;\n    }\n```\n\nyou can generate QML/Javascript message type using compiler plugin:\n\n    $ protoc --qml_out gen my_foo.proto\n\nThis will yield `gen/my_foo.pb.js` file. Let's import this file from any QML using relative path.\n\n##### Docker image\n\nIf you want to try it out without building protobuf-qml, a docker image for code generator is available.\n\n    # docker pull nsuke/protobuf-qml\n    # docker run -it -v $(pwd):/opt/protobuf-qml nsuke/protobuf-qml -I. \\\n        --qml_out=<relative path to output dir> \\\n        <relative path to your .proto file>\n\nNote that the relative paths cannot contain parent or sibling directories, i.e., they need to be within current or sub directories.\n\n#### Serialization\n\n``` javascript\nimport 'gen/my_foo.pb.js' as Types\n```\n\nthen you can use the message type inside signal handlers, property bindings or functions:\n\n``` javascript\nvar foo = new Types.Foo({\n  text: 'hello world',\n  nums: [ 3, 4, 5 ],\n});\n\nvar buf = foo.serialize();\n```\n\nhere, the `buf` variable is an `ArrayBuffer` object.\n\n<!--\nYou can for example send it to a server using **[XmlHttpRequest](http://doc.qt.io/qt-5/qtqml-javascript-qmlglobalobject.html#xmlhttprequest)** (not yet, wait for Qt 5.7) or pass it to C++ layer. If your use case is remote procedure call, **gRPC** section below might be intersting.\n-->\n\n#### Deserialization\n\nDeserialization is quite simple too:\n\n``` javascript\nvar foo2 = Types.Foo.parse(buf);\n\nconsole.log(foo2.text)\n// output: hello world\nconsole.log(foo2.nums(1))\n// output: 4\n```\n\nTBD: Link to full sample code\n\ngRPC binding\n---\n\nFor gRPC itself, see upstream official page: http://www.grpc.io/\n\ngRPC binding is still experimental.\n\n#### Code generation\n\nSuppose you add service definition to the `my_foo.proto` above:\n\n```\nservice MyService {\n  rpc ExchangeFoo(Foo) returns(Foo) {}\n}\n```\n\ncompiler plugin will additionally yield `MyService.qml` and `MyServiceClient.qml` files besides `my_foo.pb.js` file.\nLet's import the directory containing those QML files:\n\n```javascript\nimport 'gen'\n```\n\nthen you can instantiate QML elements:\n\n```javascript\nMyServiceClient {\n  id: client\n}\nMyService {\n  id: service\n}\n```\n\n#### Client\n\nTo make the client element functional, plug it to a gRPC channel.\n(In fact, you can plug to custom RPC implementation but gRPC works out of the box)\n\n```javascript\nimport 'gen'\nimport gRPC\n```\n\n```\nGrpcChannel {\n  id: gchannel\n  target: 'example.org:44448'\n  credentials: InsecureCredentials {}\n}\n\nMyServiceClienit {\n  id: client\n  channel: gchannel\n}\n```\n\nThen inside signal handlers, property bindings or functions :\n\n```javascript\nclient.exchangeFoo({\n  text: 'hi',\n  nums: [1, 2, 3],\n}, function(err, responseFoo) {\n  if (err) {\n    console.warn('Received error response: ' + err);\n    return;\n  }\n\n  // Do some useful stuff with \"responseFoo\" content\n});\n```\n\nThis will make a RPC call to example.org port 44448.\n\n#### Server\n\nYou can create gRPC server in QML app if you want to. It's handy for P2P communication and/or notifications, but not suitable for heavy computation.\n\n```javascript\nimport 'gen'\nimport gRPC\n```\n\n```javascript\nGrpcServer {\n  id: gserver\n  address: '0.0.0.0:44448'\n  credentials: ServerInsecureCredentials {}\n}\n\nMyService {\n  id: server\n  server: gserver\n\n  // This function is called for each incoming request.\n  exchangeFoo: function(requestFoo, callback) {\n\n    // First argument is error.\n    callback(null, {\n      text: 'In response to ' + requestFoo.text,\n      nums: [42],\n    });\n  }\n}\n```\n\n### QtWebSockets with Qt 5.8+\n\nFrom Qt 5.8 (QtWebSockets 1.1 QML module) on, we can send array buffers through websockets.\n\n#### Sending serialized message with QtWebSockets\n\n``` javascript\nimport QtWebSockets 1.1\n```\n\n``` javascript\nWebSocket {\n  id: socket\n  url: 'ws://your.remote.server'\n  active: true\n}\n```\n\n``` javascript\n// Inside function or handler\nvar msg = new Types.Foo({\n  text: 'hello world',\n  nums: [ 3, 4, 5 ],\n});\nvar buf = msg.serialize();\nsocket.sendBinaryMessage(buf);\n```\n\n#### Receiving serialized message with QtWebSockets\n\n``` javascript\nWebSocket {\n  id: socket\n  url: 'ws://your.remote.server'\n  active: true\n\n  onBinaryMessageReceived: {\n    var msg = Types.Foo.parse(message);\n    console.log(msg.text);\n    console.log(msg.nums(0));\n    console.log(msg.nums(1));\n    // ... Do whatever with the data\n  }\n}\n```\n\nThe complete code is available under [examples/WebSockets](examples/WebSockets) directory.\n\n### Future examples\n\nIn the future, it might become possible to send ArrayBuffer using XMLHttpRequest too.\n\nI've submitted a patch for [XMLHttpRequest](https://codereview.qt-project.org/#/c/143732/) to Qt project which enables following usage.\n\n### Send and receive serialized message with XMLHttpRequest\n\n``` javascript\n// Inside function or handler\nvar xhr = new XMLHttpRequest();\nxhr.open('POST', 'http://your.remote.server/');\nxhr.onreadystatechange = function() {\n  if (xhr.readyState === 4 && xhr.status === 200) {\n    var response = Types.Foo.parse(xhr.response);\n    // ... Do whatever with the data\n  }\n};\nxhr.responseType = 'arraybuffer';\n\nvar msg = new Types.Foo({\n  text: 'hello world',\n  // ...,\n});\n\nvar buf = msg.serialize();\n\nxhr.send(new DataView(buf));\n```\n\nThe complete code is available under [examples/XMLHttpRequest](examples/XMLHttpRequest) directory.\n",
  "permissions": {
    "read": true,
    "write": false,
    "admin": false
  },
  "media_types": [
    "application/vnd.docker.container.image.v1+json"
  ],
  "content_types": [
    "image"
  ]
}