{
  "user": "smrealms",
  "name": "smr",
  "namespace": "smrealms",
  "repository_type": "image",
  "status": 1,
  "status_description": "active",
  "description": "SMR",
  "is_private": false,
  "is_automated": true,
  "can_edit": false,
  "star_count": 1,
  "pull_count": 6440,
  "last_updated": "2022-11-13T09:11:39.172535Z",
  "date_registered": "2017-07-20T01:24:55.355135Z",
  "collaborator_count": 0,
  "affiliation": null,
  "hub_user": "smrealms",
  "has_starred": false,
  "full_description": "[![Travis Build](https://travis-ci.org/smrealms/smr.svg?branch=master)](https://travis-ci.org/smrealms/smr)\n[![Test Coverage](https://codecov.io/gh/smrealms/smr/branch/master/graph/badge.svg)](https://codecov.io/gh/smrealms/smr)\n[![Docker Build](https://img.shields.io/docker/build/smrealms/smr.svg)](https://cloud.docker.com/swarm/smrealms/repository/docker/smrealms/smr)\n[![Scrutinizer Code Quality](https://scrutinizer-ci.com/g/smrealms/smr/badges/quality-score.png?b=master)](https://scrutinizer-ci.com/g/smrealms/smr/?branch=master)\n\n# Installation\n\n## Dependencies\nMake sure the following software is installed:\n* docker (version 18.06.0+)\n* docker-compose (version 1.22.0+)\n\nTo run unit tests on your machine:\n* Composer (2.0.5+)\n\n## Setup\nFirst, you will need to clone this repository. Then inside the clone, you\nwill need to create installation-specific copies of the following files:\n\n* `.env.sample` &rarr; `.env`\n* `config/config.specific.sample.php` &rarr; `config/config.specific.php`\n\nFor \"Caretaker\" (IRC) or \"Autopilot\" (Discord) functionality:\n* `config/irc/config.specific.sample.php` &rarr; `config/irc/config.specific.php`\n* `config/discord/config.specific.sample.php` &rarr; `config/discord/config.specific.php`\n\nFor NPC's:\n* `config/npc/config.specific.sample.php` &rarr; `config/npc/config.specific.php`\n\nThe sample versions have sensible defaults, but update the copies as necessary.\nThe options must be consistent between the various configuration files.\n\n## Populate the mysql database\nTo initialize the database or update it with new patches, run:\n```\ndocker-compose run --rm flyway\n```\n\nTo modify the database, add a file called `V<VERSION_NUMBER>__<NAME>.sql` into\n`db/patches` and rerun the command.\n\nYou can optionally start up [phpMyAdmin](https://www.phpmyadmin.net/) to\ninspect your mysql database in a web browser at `http://localhost/pma/`:\n```\ndocker-compose up --build -d pma\n```\n\n## Start up the services\nThen you can start up the persistent game services\n```\ndocker-compose up --build -d traefik smr\n```\n\nFor development, it may be desirable to automatically pick up source code changes without rebuilding the docker image. Simply use the `smr-dev` service instead of `smr`, i.e.:\n```\ndocker-compose up --build -d traefik smr-dev\n```\n\n\n# Runtime\n\n## Permissions\nIn order to create an admin account you should first create a standard account\nvia the register form, then run the following command to give that account\nadmin permissions:\n\n```bash\ndb/init_admin.sh\n```\n\nThe account should now have an \"Admin Tools\" link on the left whilst logged in,\nwhich will allow you to assign any extra permissions to yourself and others.\n\n## Creating a Game\nTo create a game you will have to have assigned yourself the \"1.6 Universe Generator\" and then access this link via the admin tools to create the game.\nOnce you are happy with the game you need to edit the \"game\" table and set the \"enabled\" flag for your game to 'TRUE' in order for it to appear in the list of games to join.\n\n# Coding Style\nThis is the coding style that should be used for any new code, although currently not all code currently follows these guidelines (the guidelines are also likely to require extension).\n\n* Opening races should be placed on the same line with a single space before\n* Single line if statements should still include braces\n\n\t```php\n\tif (true) {\n\t}\n\t```\n\n* Variable names should be camelCase normally, except when in templates when they should be UpperCamelCase (to enforce some mental separation between the two contexts).\n\n\t```php\n\t$applicationVar = 'value';\n\t$TemplateVar = 'value';\n\t```\n\n* Function names should be camelCase, class names should be UpperCamelCase\n\n\t```php\n\tfunction exampleFunction() {\n\n\t}\n\n\tclass ExampleClass {\n\t\tpublic function exampleMethod() {\n\t\t}\n\t}\n\t```\n\n* Associative array indices should be UpperCamelCase\n\n\t```php\n\t$container['SectorID'] = $sectorID;\n\t```\n\n# SMR-isms\n## File inclusion\nTo include a file use get_file_loc()\n\n```php\nrequire_once(get_file_loc('SmrAlliance.class.php'));\n```\n\n## Links\nIf possible use a function from Globals or a relevant object to generate links (eg Globals::getCurrentSectorHREF(), $otherPlayer->getExamineTraderHREF()), this is usually clearer and allows hooking into the hotkey system.\nTo create a link you first create a \"container\" using the create_container() function from smr.inc.php declared as\n\n```php\ncreate_container($file, $body = '', array $extra = array(), $remainingPageLoads = null)\n```\nThere are two common usages of this:\n- $container = create_container('skeleton.php', $displayOnlyPage) with $displayOnlyPage being something such as 'current_sector.php'\n- $container = create_container($processingPage) with $processingPage being something such as 'sector_move_processing.php'.\n\nYou can then call SmrSession::getNewHREF($container) to get a HREF which will load the given page or SmrSession::generateSN($container) to get just the sn.\nAlong with this you can also assign extra values to $container which will be available on the next page under $var\n\n```php\n$container = create_container('sector_move_processing.php');\n$container['target_sector'] = 1;\n$link = SmrSession::getNewHREF($container);\n```\n\n## Global variables\nAll pages are called with the following variables available (there may be more)\n\n### $db\nThis is a global instance of the SmrMySqlDatabase class. It can be used for\ndatabase queries anywhere, but be careful to avoid using it in two places\nsimultaneously (doing so will cause database errors).\n\n### $var\n$var contains all information passed using the $container from the previous page.\nThis *can* be assigned to, but only using SmrSession::updateVar($name, $value)\n\n### $template\nThe global instance of the Template class should be the _only_ instance, and\nit is used to assign variables for display processing.\n\n### $account\nThis contains the current SmrAccount object and should not be assigned to.\n\n### $player\n_[Scope: in game]_ This contains the current SmrPlayer object and should\nnot be assigned to.\n\n### $ship\n_[Scope: in game]_ This contains the current SmrShip object and should not be\nassigned to.\n\n### $sector\n_[Scope: in game]_ This contains the current SmrSector object and should not\nbe assigned to.\n\n\n## Request variables\nFor any page which takes input through POST or GET (or other forms?) they should store these values in $var using SmrSession::updateVar() and only access via $var, this is required as when auto-refresh updates the page it will *not* resend these inputs but still requires them to render the page correctly.\n\n## Abstract vs normal classes\nThis initially started out to be used in the \"standard\" way for NPCs but that idea has since been discarded.\nNow all core/shared \"Default\" code should be in the abstract version, with the normal class child implementing game type specific functionality/overrides, for instance \"lib/Semi Wars/SmrAccount\" which is used to make every account appear to be a \"vet\" account when playing semi wars.\n\n## Unit testing\nSMR uses [PHPUnit](https://phpunit.de/) to run unit tests.\n### Setup\n1. Ensure the MySQL container is running, and ready for any integration tests that touch the database:\n   * `composer start:integration-services`\n1. Run `composer run test` to execute the full suite of tests.\n1. Add new tests as needed in the `/test` directory.\n\n### Setting up your IDE to run tests\nThis information applies to IDEA-based IDEs, e.g. `IntelliJ`, `PHPStorm`. For other vendors, please refer to your vendor's documentation for running PHPUnit tests against a remote container.\n* In order to perform these next steps in `IntelliJ`, you must have the following Jetbrains-provided plugins installed:\n * [PHP](https://plugins.jetbrains.com/plugin/6610-php)\n * [PHP Docker](https://plugins.jetbrains.com/plugin/8595-php-docker)\n   * This should also install [PHP Remote Intepreter](https://plugins.jetbrains.com/plugin/7511-php-remote-interpreter)\n\n##### Configure a remote PHP interpreter for the project\n\n1. `File > Settings > Languages & Frameworks > PHP`. In the `CLI Interpreter` area, click the `...` button\n1. Press the \"+\" button in the top left, and select `From Docker, Vagrant, VM, WSL, Remote...`\n1. In the new window, choose `Docker Compose`, and in the `Service` area, select `smr-integration-test`. Press \"OK\".\n1. It will check the configuration by starting up the Docker container, and gathering PHP information. Once that's finished, you should be on a configuration screen for the new interpreter. It should have the PHP information from the Docker container, and also the `Xdebug` information.\n1. In the `Environment variables` box on the new intepreter's screen, paste in the values from `/test.env` in the project directory.\n1. The rest of the default settings should be fine, so you can press \"Apply\".\n1. On the settings navigation tree, underneath PHP, click the `Composer` item: In the `CLI Interpreter` drop down, select the new interpreter you've created. Press \"Apply\".\n1. On the settings navigation tree, underneath PHP, click the `Test Frameworks` item.\n1. Click the `+` button to create an entry, select the newly created interpreter from the drop down, and press \"OK\".\n1. In the `PHPUnit library` section, set the `Path to script` value to `/smr/vendor/autoload.php`\n1. In the `Test Runner` section, set the `Default configuration file` to `/smr/phpunit.xml`\n1. Press \"OK\", and you should be good to go for executing tests inside the IDE.\n\n### Writing integration tests\n1. To create an integration test that uses the database, your test should extend `SmrTest\\BaseIntegrationSpec`. This will ensure that any test data that gets written to the database will be cleaned up after each test.\n * The SMR database uses MyISAM for a storage engine, so we cannot simply rollback transactions after each test. Instead, the `BaseIntegrationSpec` will check for any tables that are populated from the `flyway` migration during startup, and truncate all other tables after your test.\n",
  "permissions": {
    "read": true,
    "write": false,
    "admin": false
  },
  "media_types": [
    "application/vnd.docker.container.image.v1+json"
  ],
  "content_types": [
    "image"
  ]
}