{
  "user": "chicagozer",
  "name": "rtdb",
  "namespace": "chicagozer",
  "repository_type": "image",
  "status": 1,
  "status_description": "active",
  "description": "RTDB is a real-time database implemented in Node.js.",
  "is_private": false,
  "is_automated": true,
  "can_edit": false,
  "star_count": 0,
  "pull_count": 241,
  "last_updated": "2022-04-07T18:42:57.722055Z",
  "date_registered": "2014-09-28T16:11:20.292558Z",
  "collaborator_count": 0,
  "affiliation": null,
  "hub_user": "chicagozer",
  "has_starred": false,
  "full_description": "# rtdb \n\n© 2016 by Rheosoft. All rights reserved. \nLicensed under the [RTDB Software License version 1.0](public/license.pdf).\n \nComments, questions? <info@rheosoft.com>\n\n## Overview\n\n**rtdb** is a real-time [JSON](http://www.json.org/) document database.\nData is made available via [map/reduce](http://en.wikipedia.org/wiki/MapReduce) queries.  \nQueries are updated in real-time and subscribers are notified instantly as data is added.\n\nThe open source version of **rtdb** takes big data principles and extends into the practical domain.\nThe map/reduce construct is applied for real-time data to provide a unique, live analytical view of data.  \n\nUse **rtdb** and leave polling behind!\n\n## Installing\n\n* Clone the [git](http://git-scm.com/) repository (use --recursive!)\n\n    git clone --recursive [https://github.com/chicagozer/rtdb.git](https://github.com/chicagozer/rtdb)  \n    \n* Then run *[npm](https://npmjs.org/) install*\n    \n    `cd rtdb`  \n    `npm install`\n\n* (New!) rtdb is avaliable through [docker](https://www.docker.com/).\n\n    `docker pull chicagozer/rtdb`\n    \n## Usage\n\nLaunch **rtdb** with [node.js](http://http://nodejs.org/). Application settings are supplied via json.\n\nnode rtdb.js --settings settings/settings.json\n\n## PaaS sites\n\nOnline demo versions of **rtdb** are available.\n\n[https://rtdb.herokuapp.com](https://rtdb.herokuapp.com)\n\n[https://rtdb-rheosoft.rhcloud.com](https://rtdb-rheosoft.rhcloud.com)\n\n[https://rtdb.mybluemix.net](https://rtdb.mybluemix.net)\n\n## Acknowledgements\n\n**rtdb** was inspired by and indebted to several projects.\n\nEspecially [couchdb](http://couchdb.apache.org/) and [node.js](http://nodejs.org/).\n\nThanks to [npm](https://npmjs.org/) and several excellent libraries. See package.json for more details. \n\nSome samples contain a freely licensed template from [MediaLoot](http://medialoot.com/item/html5-admin-template/).\n## Web interface\n\nWhen running locally, the main web interface is reachable at\n\n[http://localhost:9001/web/](http://localhost:9001/web/)\n\nThe web interface provides the ability to manage collections, views and subscriptions. \n\n## Architecture\n\n### Documents\n\n**rtdb** is a [document-oriented database](https://en.wikipedia.org/wiki/Document-oriented_database). A document may be any JSON object. \n\n### Collections\n\nDocuments are organized into \"Collections\". A collection is a specific type of document. There is no requirement that all documents\nbe the same JSON format but it does help somewhat that all documents in a given collection have similar structures when designing queries.  \n\n### Views\n\nEach collection contains \"Views\". A View represents a particular query into the Collection. All queries must be \"pre-registered\".\nThere is no \"ad-hoc\" query facility. However, as the data changes, registered queries are run continuously and subscribers are updated in real-time.\n\n### Subscriber\n\nA \"Subscriber\" represents a party (usually a browser) interested in receiving updates when the query results change. A query may have many subscribers.\nSubscribers are registered via HTML EventSources.\n\nThe hierarchy is straightforward.\n\nCollections → Views → Subscribers  \n ↳ Documents\n\n### Map/Reduce\n\nThe query within each view is implemented via map/reduce. Each query requires a map function and a reduce function.  \nOptionally, a finalize function and a personalize function can be added.\nFor incoming documents, the pipeline follows this pattern.\n\nMap → Reduce → Finalize → Personalize\n\n#### Map  \n\nThe map function is called once for each incoming document. The purpose is to initially categorize the data\nand it takes the following arguments.  \n\n* item - *item* is the document to process. \n* emit - *emit* is a function that is called to *map* the item. \n* database - a reference to the database for accessing other collections/views.\n\n*emit* takes two arguments.\n\n\t* key - the hash to store\n\t* value - the value to store\n\n*emit* may be called one or more times for each call to map.\n\n#### Reduce\n\nReduce is called once for each key *emitted* by *map*.  It takes the following arguments.\n\n* values - an array of values to reduce\n* rereduce - a boolean indicating if we are *rereducing*.\n* emit - a function that is called to *emit* the result.\n* database - a reference to the database for accessing other collections/views.\n\n*emit* takes one argument, the result of the reduction. \n*emit* should be called no more than once per *reduce*.\n\n**rtdb** uses the *re-reduce* approach to accomplish incremental map/reduce. The reduce function you supply must honor this flag.\n\n>\"[A] Reduce function has the requirement that not only must it be referentially transparent,\n>but it must also be commutative and associative for the array value input,\n>to be able reduce on its own output and get the same answer.\"  \n\n> [Damien Katz](http://damienkatz.net/2008/02/incremental_map.html)\n\nTherefore, again citing Damien, for a reduce function, \n\n     f(Key, Values) == f(Key, [ f(Key, Values) ] )\n\nMore discussion [here](http://wiki.apache.org/couchdb/Introduction_to_CouchDB_views#Reduce_vs_rereduce).\n\n#### Finalize\n\nThe *finalize* function may be used to sort and/or cull the result set before sending to subscribers.\nA common usage would be to sort and trim to a \"top 10\" list.\n\n*finalize* takes the following arguments.\n\n* reduction - an array of reduced values to *finalize*.\n* emit - a function that is called to *emit* the result. Pass the *finalized* reduction.\n* database - a reference to the database for accessing other collections/views.\n\n#### Personalize.\n\nThe *personalize* function is similar to *finalize* however is it called individually for each subscriber.\nThe intent is to allow the function to use HTTP header values to identify the subscriber and personalize the result set\nspecifically for the subscriber. A common usage pattern would be to filter the data based on the user.\n\n*personalize* takes the following arguments.\n\n* reduction - an array of reduced values to *finalize*.\n* headers - the HTTP headers of the current subscriber. See node.js [documentation](http://nodejs.org/api/http.html#http_message_headers). \n* emit - a function that is called to *emit* the result. Pass the *personalized* reduction.\n* database - a reference to the database for accessing other collections/views.\n\nSince *personalize* is called for each subscriber, consider the scalability of this feature as your user base grows.\n\n## Security \n\n**rtdb** has limited inherent security. This is by design.  \n\n**rtdb** is intended to be run behind a secure web server such as [Apache](http://httpd.apache.org/). \nApache and other web servers provide secure facilities applying granular, URL based security to **rtdb**.\nSee advanced topic, securing **rtdb**.\n\n\"Out of the box\", rtdb implements Basic Authentication security for the administration functions. \nThe user/password are set via environmental variables **RTDBADMIN_USER** and **RTDBADMIN_PWD**. \nIn a production environment where security has been delegated, the Basic Authentication may be disabled\nby changing the settings json parameter **disableBasicAuth** to **true**.\n\nIf rtdb is used over the internet, be sure to secure the traffic with https if you intend to rely on basic authentication.\n\n## REST API\n\n**rtdb** uses a simple REST API to manage and interact with the database. (The web interface even uses this REST API behind the scenes.\nFeel free to check out the HTML!)\n\nThe REST API speaks JSON and uses standard verbs.\n\n`GET` - return a JSON object.  \n`PUT` - update passing a JSON object.  \n`DELETE` - delete object according to url.  \n`POST` - insert JSON object or execute command according to URL.  \n\nEach collection, view and subscriber is given a Globally Unique Identifier (GUID).\nUsing a GUID guarantees uniqueness of the individual objects and allows separate databases to be combined if needed.\nThe GUID is used to reference specific objects via the REST API.\n\nThe web interface is an easy way to familiarize yourself with the GUIDs.\n\n### Operations on Collections  \n\n`POST /db/collections` - Add a new Collection.  \n`PUT /db/collections/[col_guid]` - Update Collection.  \n`DELETE /db/collections/[col_guid]` - Delete Collection.  \n`GET /db/collections` - List all collections.  \n`GET /db/collections/[col_guid]` - List specific collection.  \n`POST /db/collections[col_guid]/documents` - Add a Document or Array of Documents.  \n`DELETE /db/collections/[col_guid]/documents` - Delete all Documents.  \n\n### Operations on Views  \n\n`POST /db/collections[col_guid]/views` - Add a new View.  \n`PUT /db/collections/[col_guid]/views/[view_guid]` - Update View.  \n`DELETE /db/collections/[col_guid]/views/[view_guid]` - Delete View.  \n`GET /db/collections/[col_guid]/views` - List all Views.  \n`GET /db/collections/[col_guid]/views/[view_guid]` - List View.  \n`GET /db/collections/[col_guid]/views/[view_guid]/ticket` - fetch security ticket.  \n`GET /db/collections/[col_guid]/views/[view_guid]/subscribers` - List subscribers.  \n`GET /db/collections/[col_guid]/views/[view_guid]/reduction` - List query result.  \n\n### Miscellaneous Operations\n\n`GET /db/stream?view=[guid]` - Used by EventSource. Multiple view params are supported.  \n`GET /db/admin/stats` - Show database stats in JSON.  \n`POST /db/admin/stop` - Shutdown the database.  \n\n## Using rtdb\n\nSteps for using **rtdb** are:\n\n1. Use the web interface or REST API to create a collection.\n2. Create one or more views for the collection.\n3. Subscribers register via WebSocket or Server Sent Event API.\n4. Insert new JSON documents via the REST API. \n5. Subscribers receive updates as documents are inserted.\n\nUse the REST API to insert documents. An example CURL syntax to load a file *mydoc.json* would be \n\n    curl -X POST -H 'Content-Type: application/json' -d @mydoc.json http://localhost:9001/db/collections/[col_guid]/documents\n\nNote that for inserts, the **rtdb** REST API expects either a single JSON document or array of documents.\nTo maximize performance, the map/reduce is run once for the entire array.\nSo use arrays when inserting multiple documents at once.\n\nSubscribers, often a web browser application, register for streams via the [HTML5 event source API](http://www.w3.org/TR/eventsource/) or [WebSockets](http://www.w3.org/TR/websockets/).  \n\n### Server Sent Events (EventSources)\n\nEventSources provide a mechanism for the database to push updates to subscribers (usually a browser).\nThis eliminates the need for clients to poll the database, checking for updates. \n\nThe heart of **rtdb** is the ability to send aggregations to subscribers in real-time.\n\nOften a browser client may want to show multiple views on a single page. Intuitively, you may create an EventSource\nfor each interesting view. However in practice, web browsers\nlimit the number of active EventSources to a very small number.\nInstead of creating multiple EventSources, **rtdb** allows you to supply a list of views when registering a single\nEventSource. With this technique there is no browser imposed limit to the number of subscriptions.  \n\nWhen adding the EventListener, pass the GUID of each view as a param. Here we register two views.\n\n    var source = new EventSource(\n\t    \"/db/stream?view=6f57030d-ccad-41df-aa92-689292fa2c42&view=ec537999-60a5-41f3-9036-fcd3d5356ae2\");\n\t\t\t\t\n    source.addEventListener(\"6f57030d-ccad-41df-aa92-689292fa2c42\", function(event) {\n\t    console.log(event.data);\n\t    }, false);\n\t\n    source.addEventListener(\"ec537999-60a5-41f3-9036-fcd3d5356ae2\", function(event) {\n\t    console.log(event.data);\n\t    }, false);\n\t    \n### Securing Subscriptions\n\n**rtdb** provides a ticket based security model. ACL based security is enabled via the settings.json by setting\n**useACLTicket** to **true**. In this case, a ticket must first be retrieved for each view via a REST call.\n\n\t/db/collections/[col_id]/views/[view_guid]/ticket\n\t\nThe \"ticket\" provides the proper authorization to initiate the subscription. This pattern is in place so that an upstream\nACL security mechanism can check the URL and do the authentication.\nSince collections and views have unique GUIDs, access to the resource\ncan be secured at a quite granular level.\n\nTickets are passed to the EventSource as a param. If more than one view is required, pass multiple view and ticket params.\n\n    var source = new EventSource(\n\t    \"/db/stream?view=6f57030d-ccad-41df-aa92-689292fa2c42&ticket=\" + ticket);\n\t    \nThe ticket has a short expiration (less than one minute) so that it may not be cached or passed around.\nIt should be used once,\nimmediately after requesting it. \n\t    \n### WebSockets\n\nSubscriber data only flows in a single direction in **rtdb**. Therefore Server Sent Events are\nan excellent choice for a transport. It is more widely supported in PaaS environments and may behave better with proxies.\nHowever, in some cases, WebSockets are preferable and may even be required to support certain browsers such as Internet\nExplorer.\n\n**rtdb** uses the excellent socket.io package for WebSocket support. The connection steps are as follows: \n\nFirst secure a ticket for the view or views if ACL security is enabled. This process is identical to using Server Sent Events.\n\t\nOnce the ticket is secured, the socket is created.\n\n    var view, var ticket; \n    var socket = io.connect(); \n\nIn the socket connect event, we use **emit** to call the server and \"subscribe\" to the view, passing the ticket.\nIf you are subscribing to multiple views, pass an array of view/ticket JSON objects.\n\n    socket.on('connect', function () {\n      socket.emit('subscribe', { ticket: ticket, view: view });\n      \n      socket.on(view,\n         function(data) {\n         ...do something with data...\n         }\n         );\n      });\n\nThe demos discussed below serve as references for a complete implementation.\n      \t    \n## Demos\n\n**rtdb** comes with two sample collections and a web front-end accessible at\n\n[http://localhost:9001/demo/apples](http://localhost:9001/demo/apples)\n\n[http://localhost:9001/demo/parcels](http://localhost:9001/demo/parcels)\n\nThese two demos utilize Server Sent Events to receive real-time updates. Documents are added through the REST API. \n\nThe \"Apples\" demo provides a simple front end for adding new documents and viewing the aggregations.\nIt is more interesting when running simultaneously on multiple browsers.\n\nThe \"Parcels\" demo uses a small sample of public domain property tax parcel data and inserts documents\nrepeatedly to provide constantly updating aggregations. The inserts are initiated by cfs/parcels.js.\nBe sure to remove or move this file in a production environment.\n\nNote that an online connection is required to load the Google libraries used for charting.\n\nAlso included are mobile versions of the demos. Accessible via the navigation menu or loaded by default\nif accessing the demo from a mobile platform.\n\n### Websocket Demos\n\nAdditional samples have been provided illustrating Websocket support.\n\n[http://localhost:9001/demo/applesws](http://localhost:9001/demo/applesws)\n\n[http://localhost:9001/demo/parcelsws](http://localhost:9001/demo/parcelsws)\n\n## Advanced Topics\n\n### rtdb files and directories\n\nHere is a summary of the **rtdb** project file structure.  \n\n\t /package.json - packaging file for NPM  \n\t /README.md - this file   \n\t /rtdb.js - the main class  \n\t /collection.js - collection class  \n\t /identity.js - helper class for guid identity  \n\t /view.js - view class  \n\t /db.js - database class\n\t /license.pdf - the license  \n\t /cfs - the pluggable file systems  \n\t \t/cfslocal.js - local file storage  \n\t \t/cfss3.js - Amazon S3 storage  \n\t \t/parcels.js - loader for parcel demo. \n\t node_modules - required Node modules installed by NPM\n\t /public - static files served by the web server  \n\t /settings - startup options in JSON format  \n\t    /settings.json - basic settings  \n\t    /mocha.json - settings for running mocha tests  \n\t /test - mocha tests  \n\t /views - Jade templates used by the web interface\n\t /sampledb - the sample collections used by the demos  \n\nThere are two default settings files in /settings\n\nsettings.json - a basic startup settings file. It will run the demo database provided\nin the sampledb subdirectory.  \nmocha.json - used for [mocha](http://mochajs.org/) testing. \nNote, to run all the mocha tests successfully, you will need to provide valid S3 connection params in this file.  \n\n### Database file structure\n\nThe database is a hierarchy of JSON files. Each JSON file is uniquely named [guid].json. \nWhere [guid] is the GUID assigned to the object.  \n\n`/collections` - contains one file for each collection in format [col_guid].json  \n`/collection/[col_guid]/documents` - contains one json file per document.  \n`/collection/[col_guid]/views` - contains one file for each view in format [view_guid].json  \n`/collection/[col_guid]/view/[view_guid]/reduction` - for \"transient\" collections, each reduction is saved at shutdown.  \n\n### Securing rtdb\n\n**rtdb** is designed to work with standard web-based security mechanisms.  \n\nUser and group authentication should be considered for any production deployment.\n\nThe REST API may be secured by specific URL to limit or control access at the collection or view level.  \n\nIn production environments, admin functions should be secured by HTTP method and URL.\n\n### Collection attributes\n\nThere are several attributes on a collection worth mentioning.\n\n#### Document Expirations\n\nA collection may be given an document *expiration* in milliseconds.\nThis can be useful for implementing queries based on sliding windows. (i.e. trends for the last hour, last day, etc).  \nIf you only want the last hour's worth of data, set the expiration to 3600000.\nThe views associated with the collection will be automatically map/reduced when the expiration is triggered.  \n\nNote, the *expiration* value is used to signal when to map/reduce.\nIt is expected that the persistence provider perform the actual removal of the stale documents. \nIn the case of the local filesystem CFS, an external task, such as a cron entry, should be used to delete stale files.\n\nTo illustrate the sequence, here is an example.\n\n10:05am - insert 5 documents; assume expiration is 3660 secs. (1 hour + 1 minute)  \n10:15am - insert 5 more documents \n11:05am - cron runs, deleting all files older than 60 mins.   \n11:06am - expiration timer will fire; collection will be map/reduced. Initial documents added at 10:05 will have fallen off.  \n\nUsing *expiration* can be expensive. As each batch of documents expires, the full collection must be map-reduced.\nBut *Expiration* will ensure the collection is map-reduced the minimum number of times required. \nIf you are inserting large volumes of documents, consider forcing a map-reduce via the REST API on a regular interval instead.\n\nIf you are concerned about the expense of performing a full map-reduce on a frequent basis, \nconsider clearing the collection on a timed interval. \nThe effect is a bit different than a sliding window, but very efficient.\n\n#### Using Transient  \n\nWhen a collection is marked as *transient*, collections are reduced, but documents are not persisted.\nThis can be useful for high volume or when the data is persisted elsewhere.  \n\nOne caveat is that when views are added or updated, the reduction can only happen on \"new\" documents.\n\nReductions are persisted when the database is shutdown so that current state of reductions are preserved when the database is restarted.\n\nNote that collections that use *expiration* cannot use *transient*.\nThese two flags are mutually exclusive.  \n\n#### Using Priority \n\nWhen a collection will be used for lookups (aka master tables), it must be loaded before its dependent collections.  \nUse the *Priority* to order how collections are loaded. Lower numbers are loaded first. Find further discussion\nbelow on referencing other collections from within a query.\n\n### Using Deltas\n\nOften the amount of data that changes between events is small compared to the overall size of the reduction.\nRTDB offers a form of compression for this case and sends just the difference between the last reduction and latest one.\n\nThis mode is enabled by passing the query parm *delta* when subscribing to a stream. i.e.  \n\n    /db/stream?view=6f57030d-ccad-41df-aa92-689292fa2c42&delta=true\n    \nOr in the case of a WebSocket, send \n\n\tdelta: true\n\t\nin the subscription event.\n    \nIn *delta* mode **rtdb** will initially send a full JSON reduction, then all subsequent updates will be *diffs*.\nThe [symmetry](https://github.com/Two-Screen/symmetry) Javascript library may be used to patch the reduction with the latest diff.\n\n    var reduction = Symmetry.patch(lastreduction,JSON.parse(event.data));  \n    \nA *delta* version of the demo may be found [here](http://localhost:9001/demo/apples_delta).\n    \nUse *delta* mode when the overall size of the reduction is large compared to the amount of incremental change.\nHowever, depending on the view, using delta mode may be less efficient than sending the full reduction.\n\n### Referencing other Collections in a Query\n\nUnlike a relational database, there is no *join* syntax to combine collections.\nHowever the global database object is passed to the map/reduce methods and \nthis can be useful for referencing other collections when a lookup is required. \nYou will need to provide a \"lookup\" reduction on the collection containing the master data.\n\n    // myobject will contain the key used for the lookup\n    var myobject;\n    // Use a GUID to get a reference to the collection containing master data\n    var c=database.collectionAt('be2aec31-3d1d-4674-bc20-106d5c46e220'); \n    // Use a GUID to get the intended view\n    var v = c.viewAt('e3ef472a-1f7e-469e-98f9-cf759cc05352'); \n    // do the lookup by using \"myobject\" as the hash\n    var r = v.reductionAt(myobject);\n    // use the return value \"r\" as needed.\n\n### IPv6\n\n**rtdb** supports IPv6. Supply an IPv6 listen address for the **hosts** param in the settings json.\n\n\t\"hosts\": [\"::1\"]\n\nThis field takes an array so you may supply both an IPv4 address and IPv6 if desired.\n\n    \"hosts\": [\"::1\",\"localhost\"]\n    \nIf you wish to use the parcels demo with IPv6, you will also need to update the hosts value in **parcels.js**.\n\n### Settings\n\nThe settings json file is the mechanism to supply database parameters.\n\n\thosts: an array of hosts to listen on. May be IPv4 or IPv6.\n\tport: The port to listen on.\n\tuseACLTicket: boolean to enable the ACL/ticket security mechanism.\n\tdisableBasicAuth: boolean to disable basic authentication for DB admin functions.\n\tcfs: the persistence layer to use.\n\tcfsinit: json object passed to persistence layer for initialization params.\n\treduceInterval: minimum interval between subscriber updates.\n\texpirationInterval: expiration interval for transient collections.\n\n### Jade\n\nThe excellent [Jade](http://jade-lang.com/) templating engine is used for the web administration and the demos. \nThe templates are contained in the /views subdirectory. Templates may be added or modified dynamically.\n(i.e. no need to restart rtdb.)\n\n### Licensing\n\n**rtdb** is licensed under the [RTDB Software License version 1.0](public/license.pdf).\nCommercial licenses and support are also available @<info@rheosoft.com>.\n\n### Custom Persistence\n\n**rtdb** uses a plugin architecture for persistence. A local filesystem (cfslocal) implementation and Amazon S3 (cfss3) are provided.  \nTo add your own provider, implement the following methods for your provider and install \nthe javascript module into the /cfs subdirectory. \nUse either *cfslocal.js* or *cfss3.js* as a template.\n\n    function name()  - return a unique name for this provider\n    function init(parms)  - initialize with params from settings.json\n    function exists(dir, callback)  - does this exist? \n    function get(key, callback)  - return object by key\n    function del(key, callback)   - delete object by key\n    function put(prefix, item, callback, expires)   - put object\n    function list(prefix, callback)  - list objects\n    \n## cfslocal\n\n*cfslocal* is the default persistence layer. Database objects are writen to the local file system.\nThe *cfslocal* persistence layer takes a single initialization param.\n\n\t\"root\" : \"sampledb/\"\n\nSet this value to to the location of the local directory to contain the database files.\n\n## cfss3\n\n*cfss3* allows writing to the [Amazon S3](http://aws.amazon.com/s3/) file system. Supply your credentials accordingly in the settings json.\n\n\t\"config\" : { \"accessKeyId\" : \"xxx\", \n\t\t\"secretAccessKey\": \"xxx\", \n\t\t\"region\": \"us-east-1\" \n\t\t\t},\n\t\"params\" : {\n\t\t\"Bucket\" : \"xxxxxx\"\n\t\t}\n\n[ ![Codeship Status for chicagozer/rtdb](https://codeship.io/projects/3d221940-29ae-0132-a513-726bdf280447/status)](https://codeship.io/projects/38106)\n[![Build Status](https://travis-ci.org/chicagozer/rtdb.svg?branch=master)](https://travis-ci.org/chicagozer/rtdb)\n",
  "permissions": {
    "read": true,
    "write": false,
    "admin": false
  },
  "media_types": [
    "application/vnd.docker.container.image.v1+json"
  ],
  "content_types": [
    "image"
  ]
}