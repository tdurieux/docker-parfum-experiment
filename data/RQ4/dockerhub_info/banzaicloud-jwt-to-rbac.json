{
  "user": "banzaicloud",
  "name": "jwt-to-rbac",
  "namespace": "banzaicloud",
  "repository_type": "image",
  "status": 1,
  "status_description": "active",
  "description": "",
  "is_private": false,
  "is_automated": false,
  "can_edit": false,
  "star_count": 0,
  "pull_count": 6159,
  "last_updated": "2020-09-15T06:49:24.500306Z",
  "date_registered": "2019-02-26T13:28:36.366811Z",
  "collaborator_count": 0,
  "affiliation": null,
  "hub_user": "banzaicloud",
  "has_starred": false,
  "full_description": "[![CircleCI](https://circleci.com/gh/banzaicloud/jwt-to-rbac/tree/master.svg?style=shield)](https://circleci.com/gh/banzaicloud/jwt-to-rbac/tree/master)\n[![Go Report Card](https://goreportcard.com/badge/github.com/banzaicloud/jwt-to-rbac)](https://goreportcard.com/report/github.com/banzaicloud/jwt-to-rbac)\n[![Docker Automated build](https://img.shields.io/docker/cloud/automated/banzaicloud/jwt-to-rbac.svg)](https://hub.docker.com/r/banzaicloud/jwt-to-rbac)\n\n\n## JWT-to-RBAC\n\nJWT-to-RBAC lets you automatically generate RBAC resources based on JWT token.\n\n### Context\n\nFor authentication we use [Dex](https://github.com/dexidp/dex) with the LDAP and GitHub connectors. The users in LDAP have group memberships, GitHub users can be members of a team in an organization and Dex issues a JWT token containing these memberships. The JWT-to-RBAC project can create `ServiceAccount`, `ClusterRoles` and `ClusterroleBindings` based on JWT tokens. When we create a new `ServiceAccount` K8s automatically generates a `service account token`.\n\nFor more information and context please read the [Provider agnostic authentication and authorization in Kubernetes](https://banzaicloud.com/blog/k8s-rbac/) post.\n\nJWT-to-RBAC is a core part of [Banzai Cloud Pipeline](https://banzaicloud.com/), a Cloud Native application and devops platform that natively supports multi- and hybrid-cloud deployments with multiple authentication backends. Check out the developer beta:\n<p align=\"center\">\n  <a href=\"https://beta.banzaicloud.io\">\n  <img src=\"https://camo.githubusercontent.com/a487fb3128bcd1ef9fc1bf97ead8d6d6a442049a/68747470733a2f2f62616e7a6169636c6f75642e636f6d2f696d672f7472795f706970656c696e655f627574746f6e2e737667\">\n  </a>\n</p>\n\n### Requirements:\n\nThere are some pre-requirements to kick this of for your own testing.\n\n* Configured Dex server which issues JWT tokens. If you want to issue tokens with Dex you have to configure it with LDAP connector. You can use the Banzai Cloud [Dex chart](https://github.com/banzaicloud/banzai-charts/tree/master/dex).\n* GitHub account assigned for an organization or configured LDAP server - you can use the [openldap](https://github.com/osixia/docker-openldap) Docker image\n* Authentication application which uses Dex as an OpenID connector (in our case is [Pipeline](https://github.com/banzaicloud/pipeline).\n\n> Dex acts as a shim between a client app and the upstream identity provider. The client only needs to understand OpenID Connect to query Dex.\n\nThe whole process is broken down to two main parts:\n\n* Dex auth flow\n* jwt-to-rbac ServiceAccount creation flow\n\n**Dex authentication flow:**\n\n1. User visits Authentication App.\n2. Authentication App redirects user to Dex with an OAuth2 request.\n3. Dex determines user's identity.\n4. Dex redirects user to Authentication App with a code.\n5. Authentication App exchanges code with Dex for an ID token.\n\n**jwt-to-rbac Flow:**\n\n1. Authentication App has ID token (JWT)\n2. POST ID token to jwt-to-rbac App\n3. jwt-to-rbac validates ID token with Dex\n4. jwt-to-rbac extracts username, groups and so on from the token\n5. jwt-to-rbac calls API server to crate `ServiceAccount`, `ClusterRoles` and `ClusterRoleBindings`\n6. jwt-to-rbac get service account token and sends it to Authentication App\n7. Authentication App sends back the service account token to User\n8. User authenticate on K8s using `service account token`\n\n**The ID token issued by Dex has a following content:**\n```json\n{\n  \"iss\": \"http://dex/dex\",\n  \"sub\": \"CiNjbj1qYW5lLG91PVBlb3BsZSxkYz1leGFtcGxlLGRjPW9yZxIEbGRhcA\",\n  \"aud\": \"example-app\",\n  \"exp\": 1549661603,\n  \"iat\": 1549575203,\n  \"at_hash\": \"_L5EkeNocRsG7iuUG-pPpQ\",\n  \"email\": \"janedoe@example.com\",\n  \"email_verified\": true,\n  \"groups\": [\n    \"admins\",\n    \"developers\"\n  ],\n  \"name\": \"jane\",\n  \"federated_claims\": {\n    \"connector_id\": \"ldap\",\n    \"user_id\": \"cn=jane,ou=People,dc=example,dc=org\"\n  }\n}\n```\n\nAfter jwt-to-rbac extracts the information from the token, creates `ServiceAccount` and `ClusterRoleBinding` using one of the default K8s `ClusterRole` as `roleRef` or generate one defined in configuration if it does't exist.\n\n### Default K8s ClusterRoles used by `jwt-to-rbac`\n\nThe [JWT-to-RBAC](https://github.com/banzaicloud/jwt-to-rbac) dos not create a new `ClusterRole` in every case; for example if a user is a member of admin group, it doesn't create this `ClusterRole` because K8s has already one by default.\n\nDefault ClusterRole | Description\n--------------------|------------\ncluster-admin       | Allows super-user access to perform any action on any resource.\nadmin               | Allows admin access, intended to be granted within a namespace using a RoleBinding.\nedit                | Allows read/write access to most objects in a namespace.\nview                | Allows read-only access to see most objects in a namespace.\n\n### jwt-to-rbac crate custom `ClusterRole` defined in config\n\nIn most of the cases there are different LDAP groups, so custom groups can be configured with custom rules.\n\n```toml\n[[rbachandler.customGroups]]\ngroupName = \"developers\"\n[[rbachandler.customGroups.customRules]]\nverbs = [\n  \"get\",\n  \"list\"\n]\nresources = [\n  \"deployments\",\n  \"replicasets\",\n  \"pods\"\n]\napiGroups = [\n  \"\",\n  \"extensions\",\n  \"apps\"\n]\n```\n\n### define GitHub custom roles in config\n\n```toml\n[[rbachandler.customGroups]]\ngroupName = \"githubOrg-githubTeam\"\n[[rbachandler.customGroups.customRules]]\nverbs = [\n  \"get\",\n  \"list\"\n]\nresources = [\n  \"deployments\",\n  \"replicasets\",\n  \"pods\"\n]\napiGroups = [\n  \"\",\n  \"extensions\",\n  \"apps\"\n]\n```\n\n### or specify GitHub organization as default org\n\n```toml\n[rbachandler]\ngithubOrg = \"github_organization\"\n[[rbachandler.customGroups]]\ngroupName = \"githubTeam\"\n[[rbachandler.customGroups.customRules]]\nverbs = [\n  \"get\",\n  \"list\"\n]\nresources = [\n  \"deployments\",\n  \"replicasets\",\n  \"pods\"\n]\napiGroups = [\n  \"\",\n  \"extensions\",\n  \"apps\"\n]\n```\n\n### Example configuration in yaml using default GitHub org\n**issued jwt:**\n```json\n{\n  \"iss\": \"http://dex/dex\",\n  \"sub\": \"xxxxxxxxxxxxxxxxxxxxx\",\n  \"aud\": \"example-app\",\n  \"exp\": 1551179050,\n  \"iat\": 1551092650,\n  \"at_hash\": \"xxxxxxxxxxxxxxxxxxx\",\n  \"email\": \"p.balogh.sa@gmail.com\",\n  \"email_verified\": true,\n  \"groups\": [\n    \"pokeorg\",\n    \"pokeorg:admin\",\n    \"pokeorg:developer\"\n  ],\n  \"name\": \"Peter Balogh\",\n  \"federated_claims\": {\n    \"connector_id\": \"github\",\n    \"user_id\": \"13311234\"\n  }\n}\n```\n**example config:**\n```yaml\napp:\n  addr: \":5555\"\n\nlog:\n  level: \"4\"\n  format: \"json\"\n  noColor: true\n\ntokenhandler:\n  dex:\n    clientID: example-app\n    issuerURL: \"http://dex/dex\"\n\nrbachandler:\n  githubOrg: \"pokeorg\"\n  customGroups:\n  - groupName: developer\n    customRules:\n    - verbs: [ \"get\", \"list\" ]\n      resources: [ \"deployments\", \"replicasets\", \"pods\" ]\n      apiGroups: [ \"\", \"extensions\", \"apps\" ]\n    namespaces: [\"example_namespace\"] # Only if you want to isolate the customRules to some namespaces, if you want that the customRules to apply to all namespaces delete this hole line...\n  kubeConfig: \"/Users/poke/.kube/config\"\n```\n\n### Define custom CA cert or set insecure connection\n```toml\n[tokenhandler]\ncaCertPath = \"/path/to/tls.crt\"\ninsecure = false\n```\n**Setting insecure conection in command line:**\n```shel\njwt-to-rbac --tokenhandler.insecure=true\n```\n\nSo to conclude on the open source [JWT-to-RBAC](https://github.com/banzaicloud/jwt-to-rbac) project - follow these stpes if you would like to try it or check it out already in action by subscribing to our free developer beta at https://beta.banzaicloud.io/.\n\n### 1. Deploy jwt-to-rbac to Kubernetes\n\nAfter you cloning the [GitHub repository](https://github.com/banzaicloud/jwt-to-rbac) you can compile a code and make a `docker image` with one command.\n\n```shell\nmake docker\n```\n\nIf you are using docker-for-desktop or minikube, you'll be able to deploy it using locally with the newly built image.\n```shell\nkubectl create -f deploy/rbac.yaml\nkubectl create -f deploy/configmap.yaml\nkubectl create -f deploy/deployment.yaml\nkubectl create -f deploy/service.yaml\n# port-forward locally\nkubectl port-forward svc/jwt-to-rbac 5555\n```\n\nNow you can communicate with the jwt-to-rbac app.\n\n### 2. POST ID token issued by Dex to jwt-to-rbac API\n```shell\ncurl --request POST \\\n  --url http://localhost:5555/rbac/ \\\n  --header 'Content-Type: application/json' \\\n  --data '{\"token\": \"example.jwt.token\"}'\n\n# response:\n{\n    \"Email\": \"janedoe@example.com\",\n    \"Groups\": [\n        \"admins\",\n        \"developers\"\n    ],\n    \"FederatedClaims\": {\n        \"connector_id\": \"ldap\",\n        \"user_id\": \"cn=jane,ou=People,dc=example,dc=org\"\n    }\n}\n```\n\nThe `ServiceAccount`, `ClusterRoles` (if ID token has some defined custom groups we discussed) and `ClusterRoleBindings` are created.\n\n**Listing the created K8s resources:**\n```shell\ncurl --request GET \\\n  --url http://localhost:5555/rbac \\\n  --header 'Content-Type: application/json'\n\n#response:\n{\n    \"sa_list\": [\n        \"janedoe-example-com\"\n    ],\n    \"crole_list\": [\n        \"developers-from-jwt\"\n    ],\n    \"crolebind_list\": [\n        \"janedoe-example-com-admin-binding\",\n        \"janedoe-example-com-developers-from-jwt-binding\"\n    ]\n}\n```\n\n### 3. GET the default K8s token of `ServiceAccount`\n```shell\ncurl --request GET \\\n  --url http://localhost:5555/tokens/janedoe-example-com \\\n  --header 'Content-Type: application/json'\n\n# response:\n[\n    {\n        \"name\": \"janedoe-example-com-token-m4gbj\",\n        \"data\": {\n            \"ca.crt\": \"example-ca-cer-base64\",\n            \"namespace\": \"ZGVmYXVsdA==\",\n            \"token\": \"example-k8s-sa-token-base64\"\n        }\n    }\n]\n```\n\n### 4. Generate a ServiceAccount token with TTL\n```shell\ncurl --request POST \\\n  --url http://localhost:5555/tokens/janedoe-example-com \\\n  --header 'Content-Type: application/json'\n  --data '{\"duration\": \"12h30m\"}'\n\n# response:\n[\n    {\n        \"name\": \"janedoe-example-com-token-df3re\",\n        \"data\": {\n            \"ca.crt\": \"example-ca-cer-base64\",\n            \"namespace\": \"ZGVmYXVsdA==\",\n            \"token\": \"example-k8s-sa-token-with-ttl-base64\"\n        }\n    }\n]\n```\n\nNow you have a base64 encoded `service account token`.\n\n### 5. Accessing with ServiceAccount token\n\nYou can use `service account token` from command line:\n```shell\nkubectl --token $TOKEN_TEST --server $APISERVER get po\n```\n\nOr create `kubectl` context with it:\n```shell\nexport TOKEN=$(echo \"example-k8s-sa-token-base64\" | base64 -D)\nkubectl config set-credentials \"janedoe-example-com\" --token=$TOKEN\n# with kubectl config get-clusters you can get cluster name\nkubectl config set-context \"janedoe-example-com-context\" --cluster=\"clustername\" --user=\"janedoe-example-com\" --namespace=default\nkubectl config use-context janedoe-example-com-context\nkubectl get pod\n```\n\n> As a final note - since we use Dex, which is an identity service that uses OpenID Connect to drive authentication for other apps, any other supported connector can be used for authentication to Kubernetes.\n",
  "permissions": {
    "read": true,
    "write": false,
    "admin": false
  },
  "media_types": [
    "application/vnd.docker.container.image.v1+json"
  ],
  "content_types": [
    "image"
  ]
}