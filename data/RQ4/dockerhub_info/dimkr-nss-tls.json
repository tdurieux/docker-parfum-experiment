{
  "user": "dimkr",
  "name": "nss-tls",
  "namespace": "dimkr",
  "repository_type": "image",
  "status": 1,
  "status_description": "active",
  "description": "CI machine for nss-tls - deprecated, use ghcr.io/dimkr/nss-tls/ci-container",
  "is_private": false,
  "is_automated": true,
  "can_edit": false,
  "star_count": 0,
  "pull_count": 1200,
  "last_updated": "2021-07-14T07:57:51.965342Z",
  "date_registered": "2018-11-16T20:42:07.332706Z",
  "collaborator_count": 0,
  "affiliation": null,
  "hub_user": "dimkr",
  "has_starred": false,
  "full_description": "```\n                     _   _\n _ __  ___ ___      | |_| |___\n| '_ \\/ __/ __|_____| __| / __|\n| | | \\__ \\__ \\_____| |_| \\__ \\\n|_| |_|___/___/      \\__|_|___/\n```\n\n[![Build Status](https://github.com/dimkr/nss-tls/actions/workflows/build.yml/badge.svg?branch=master)](https://github.com/dimkr/nss-tls/actions/workflows/build.yml)\n\n__This is the deprecated 0.x branch of nss-tls, which uses RFC 8484 incompliant, JSON-based resolving. Unless you have a good reason to use this version, use a later version.__\n\n## Motivation\n\nUnlike most web browser traffic, which is encrypted thanks to HTTPS, the resolving of domain names to internet addresses still happens through DNS, an old, unencrypted protocol. This benefits analytics companies, advertisers, internet providers and attackers, but not the end-user, who seeks online privacy and security.\n\n## Overview\n\nnss-tls is an alternative, encrypted name resolving library for [Linux](http://www.kernel.org/) distributions with [glibc](https://www.gnu.org/software/libc/), which uses [DNS-over-HTTPS (DoH)](https://tools.ietf.org/html/rfc8484).\n\nThe glibc name resolver can be configured through nsswitch.conf(5) to use nss-tls instead of the DNS resolver, or fall back to DNS when nss-tls fails.\n\nThis way, all applications that use the standard resolver API (getaddrinfo(), gethostbyname(), etc'), are transparently migrated from DNS to encrypted means of name resolving, with zero application-side changes and minimal resource consumption footprint. However, nss-tls does not deal with applications that use their own, built-in DNS resolver.\n\n## Architecture\n\nnss-tls consists of three parts:\n\n* nss-tlsd runs in the background and receives name resolving requests over a Unix socket.\n* libnss_tls.so is a tiny client library, which delegates the resolving work to nss-tlsd through the Unix socket and passes the results back to the application, without dependencies other than libc. This way, applications that resolve through nss-tls are not affected by the complexity and resource consumption of runtime libraries (e.g. libstdc++) and dependency libraries, or the constraints they impose on applications that load them (like signal or thread safety issues).\n* tlslookup is equivalent to nslookup(1), but uses libnss_tls.so instead of DNS.\n\n## Security and Privacy\n\nAn unprivileged user can start a private, unprivileged instance of nss-tlsd and libnss-tls.so will automatically use that one, instead of the system-wide instance of nss-tlsd. Each user's nss-tls instance holds its own cache of lookup results, to speed up resolving. Because the cache is not shared with other users, it remains \"hot\" even if other users resolve many names.\n\nUsers who don't have such a private instance will continue to use the system-wide instance, which does not perform caching, to prevent a user from extracting the browsing history of another user, using timing-based methods. In addition, nss-tlsd drops its privileges to greatly reduce its attack surface.\n\nAlso, nss-tls is capable of using multiple DoH servers, with a deterministic algorithm that chooses which server to use to resolve a domain. This way, no DoH server can track the user's entire browsing history.\n\n## Dependencies\n\nnss-tls depends on:\n* [glibc](https://www.gnu.org/software/libc/)\n* [GLib](https://wiki.gnome.org/Projects/GLib)\n* [libsoup](https://wiki.gnome.org/Projects/libsoup)\n* [JSON-GLib](https://wiki.gnome.org/Projects/JsonGlib)\n\nIf [systemd](https://www.freedesktop.org/wiki/Software/systemd/) is present, the installation of nss-tls includes unit files for nss-tlsd.\n\nHowever, nss-tlsd does not depend on [systemd](https://www.freedesktop.org/wiki/Software/systemd/). When [systemd](https://www.freedesktop.org/wiki/Software/systemd/) is not present, other means of running a nss-tlsd instance for each user (e.g. xinitrc) and root (e.g. an init script) should be used.\n\nnss-tls uses [Meson](http://mesonbuild.com/) as its build system.\n\nOn [Debian](http://www.debian.org/) and derivatives, these dependencies can be obtained using:\n\n    apt install libglib2.0-dev libsoup2.4-dev libjson-glib-dev ninja-build python3-pip\n    pip3 install meson\n\n## Usage\n\nAssuming your system runs [systemd](https://www.freedesktop.org/wiki/Software/systemd/):\n\n    meson --prefix=/usr --buildtype=release -Dstrip=true build\n    ninja -C build install\n    systemctl daemon-reload\n    systemctl enable nss-tlsd\n    systemctl start nss-tlsd\n    systemctl --user --global enable nss-tlsd\n    systemctl --user start nss-tlsd\n    ldconfig\n\nThen, add \"tls\" to the \"hosts\" entry in /etc/nsswitch.conf, before \"dns\" or anything else that contains \"dns\".\n\nThis will enable a system nss-tlsd instance for all non-interactive processes (which runs as an unprivileged user) and a private instance of nss-tlsd for each user. Name resolving will happen through nss-tls and DNS will be attempted only if nss-tls fails.\n\n## Choosing a DoH Server\n\nBy default, nss-tls performs all name lookup through [cloudflare-dns.com/dns-query](https://developers.cloudflare.com/1.1.1.1/dns-over-https/).\n\nTo use a different DoH server, use the \"resolvers\" build option:\n\n    meson configure -Dresolvers=dns9.quad9.net:5053/dns-query\n\n## Using Multiple DoH Servers\n\nIt is also possible to use multiple DoH servers:\n\n    meson configure -Dresolvers=cloudflare-dns.com/dns-query,dns9.quad9.net:5053/dns-query\n\nWhen nss-tls is configured like this, it pseudo-randomly chooses one of the servers, for each name lookup. The pseudo-random choice of the server is deterministic: if the same domain is resolved twice (e.g. for its IPv4 and IPv6 addresses, respectively), nss-tlsd will use the same DoH server for both queries. If nss-tlsd is restarted, it will keep using the same DoH server to resolve that domain. This contributes to privacy, since every DoH server sees only a portion of the user's browsing history.\n\nPreviously, nss-tls was limited to a single server, specified using the now deprecated \"resolver\" build option.\n\n## DoH Without Fallback to DNS\n\nTo use nss-tls for name resolving, without falling back to DNS if resolving fails, build nss-tls with DoH servers specified using their addresses, e.g.:\n\n    meson configure -Dresolvers=1.1.1.1/dns-query,9.9.9.9:5053/dns-query\n\nThis way, nss-tls will not depend on other means of name resolving to resolve a DoH server address.\n\nThen, remove all DNS resolvers from the \"hosts\" entry in /etc/nsswitch.conf and keep \"tls\".\n\n## Performance\n\nDNS over HTTPS is much slower than DNS. Therefore, by default, each user's nss-tls instance maintains an internal cache of lookup results.\n\nHowever, one may wish to use a system-wide cache; nscd(8) can do that.\n\nTo disable the internal cache, use the \"cache\" build option:\n\n    meson configure -Dcache=false\n\nTo enable system-wide DNS cache on [Debian](http://www.debian.org/) and derivatives:\n\n    apt install unscd\n\nSet \"enable-cache\" for \"hosts\" to \"yes\" in /etc/nscd.conf. Then:\n\n    systemctl enable unscd\n    systemctl start unscd\n\n## Legal Information\n\nnss-tls is free and unencumbered software released under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version license.\n\nnss-tls is not affiliated with 1.1.1.1, [Cloudflare](https://www.cloudflare.com/) or [Quad9](https://www.quad9.net/).\n\nThe ASCII art logo at the top was made using [FIGlet](http://www.figlet.org/).\n",
  "permissions": {
    "read": true,
    "write": false,
    "admin": false
  },
  "media_types": [
    "application/vnd.docker.container.image.v1+json"
  ],
  "content_types": [
    "image"
  ]
}