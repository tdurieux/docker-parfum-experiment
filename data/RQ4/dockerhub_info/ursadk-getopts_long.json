{
  "user": "ursadk",
  "name": "getopts_long",
  "namespace": "ursadk",
  "repository_type": "image",
  "status": 1,
  "status_description": "active",
  "description": "An \"upgrade\" to BASH built-in getopts, with support for GNU-style long option.",
  "is_private": false,
  "is_automated": false,
  "can_edit": false,
  "star_count": 0,
  "pull_count": 66,
  "last_updated": "2021-02-01T17:11:48.254518Z",
  "date_registered": "2020-05-07T11:22:57.198873Z",
  "collaborator_count": 0,
  "affiliation": null,
  "hub_user": "ursadk",
  "has_starred": false,
  "full_description": "<div align=\"center\">\n\n  [![getopts_long logo](https://raw.githubusercontent.com/UrsaDK/getopts_long/master/docs/images/logo.png)](#)<br>\n\n  [![stable branch](https://img.shields.io/badge/dynamic/json.svg?color=lightgrey&label=stable&query=%24.default_branch&url=https%3A%2F%2Fapi.github.com%2Frepos%2FUrsaDK%2Fgetopts_long&logo=github)](https://github.com/UrsaDK/getopts_long/tree/master)\n  [![latest release](https://img.shields.io/badge/dynamic/json.svg?color=blue&label=release&query=%24.name&url=https%3A%2F%2Fapi.github.com%2Frepos%2FUrsaDK%2Fgetopts_long%2Freleases%2Flatest&logo=docker)](https://hub.docker.com/r/ursadk/getopts_long)\n  [![test coverage](https://codecov.io/gh/UrsaDK/getopts_long/graph/badge.svg)](https://codecov.io/gh/UrsaDK/getopts_long)\n  [![donate link](https://img.shields.io/badge/donate-coinbase-gold.svg?colorB=ff8e00&logo=bitcoin)](https://commerce.coinbase.com/checkout/17ae30c2-9c3f-45fb-a911-36d01a3c81b6)\n\n</div>\n\n# getopts_long\n\nThis is a pure BASH implementation of `getopts_long` function, which \"upgrades\" the built-in `getopts` with support for GNU-style long options, such as:\n\n  - `--option`\n  - `--option value`\n  - `--option=value`\n\nThis function is 100% compatible with the built-in `getopts`. It is implemented with no external dependencies, and relies solely on BASH built-in tools to provide all of its functionality.\n\nTable of Content\n----------------\n\n<!-- TOC START min:2 max:4 link:true asterisk:false update:true -->\n- [Table of Content](#table-of-content)\n- [Installation](#installation)\n  - [Source the library](#source-the-library)\n  - [Paste the content](#paste-the-content)\n  - [Run in docker](#run-in-docker)\n- [Usage](#usage)\n  - [Extended OPTSPEC](#extended-optspec)\n  - [Example script](#example-script)\n- [How It Works](#how-it-works)\n  - [Internal variables](#internal-variables)\n  - [Error reporting](#error-reporting)\n    - [Verbose mode](#verbose-mode)\n    - [Silent mode](#silent-mode)\n<!-- TOC END -->\n\n## Installation\n\nThe function is distributed via a single self-contained file:\n```\nlib/getopts_long.bash\n```\n\nThere are a number of ways to make it available to your script, all of them come with their own advantages and disadvantages. Consider carefully all of the following and pick the method of installation that suits your needs best.\n\n### Source the library\n\nThis is the recommended way of providing `getopts_long` functionality to your script. To use it, clone this repository somewhere on your system:\n\n```\ngit clone https://github.com/UrsaDK/getopts_long.git\n```\n\nThen update your script to source the function code:\n\n```\n. \"__PATH_TO__/getopts_long/lib/getopts_long.bash\"\n```\n\nThis method allows you to receive any future updates and all fixes to the function by simply running `git pull` within the repository. However, if you customise the function for your own needs, you might end up having to fix git merge conflicts in the future.\n\n### Paste the content\n\nAn alternative method of installation is to simply copy-n-paste the content of `lib/getopts_long.bash` into your script.\n\nThis will make the function available to a single script and you will easily be able to customise it for your own needs. However, you will need to keep an eye on this repository and manually upgrade the function whenever an update is released.\n\n### Run in docker\n\nA more advanced way to run your script with getopts_long is to mount its directory into the getopts_long docker container:\n\n```\ndocker container run --rm --init -it -v ${YOUR_SCRIPT_DIR}:/mnt ursadk/getopts_long -l\n```\n\nYour project is available under `/mnt` directory, and `getopts_long` function can be sourced from `/home/lib/getopts_long.bash`.\n\nThe container also provides the following tools:\n\n  - `shellcheck` - https://github.com/koalaman/shellcheck\n  - `bats-core` - https://github.com/bats-core/bats-core\n  - `kcov` - https://github.com/SimonKagstrom/kcov\n  - `/home/bin/bats` - a custom wrapper around the above three tools that allows you to run test and generates a coverage report as long as the root directory of your project includes `bin`, `lib`, and `test` directories, which are used accordingly.\n  - `/home/bin/kcov` - a custom wrapper around the `kcov` command which cleans up output reports\n\nPlease note that `/home/bin` directory in _pre-pended_ to the shell's PATH variable. As such, all files placed in `/home/bin` will be executed in preference to the system tools. For example, executing `kcov` runs `/home/bin/kcov` not `/usr/local/bin/kcov`.\n\n## Usage\n\nThe syntax for `getopts_long` is the same as the syntax for the built-in `getopts`:\n\n```\ngetopts_long OPTSPEC VARNAME [ARGS...]\n```\n\nwhere:\n\n| Name    | Description |\n| ------- | ----------- |\n| OPTSPEC | An extended list of expected options and their arguments. |\n| VARNAME | A shell-variable to use for option reporting. |\n| ARGS    | An optional list of arguments to parse. If omitted, then `getopts_long` will parse arguments supplied to the script. |\n\n### Extended OPTSPEC\n\nAn OPTSPEC string tells `getopts_long` which options to expect and which of them must have an argument. The syntax is very simple:\n\n- single-character options are named first (identical to the built-in `getopts`);\n- long options follow the single-character options, they are named as is and are separated from each other and the single-character options by a space.\n\nJust like with the original `getopts`, when you want `getopts_long` to expect an argument for an option, just place a `:` (colon) after the option.\n\nFor example, given `'af: all file:'` as the OPTSPEC string, `getopts_long` will recognise the following options:\n\n- `-a` - a single character (short) option with no argument;\n- `-f ARG` - a single character (short) option with an argument;\n- `--all` - a multi-character (long) option with no argument;\n- `--file ARG` - a multi-character (long) option with an argument.\n\nIf the very first character of the optspec-string is a `:` (colon), which would normally be nonsense because there's no option letter preceding it, `getopts_long` switches to \"silent error reporting mode\" (See [Error Reporting](#error-reporting) for more info).\n\nIn production scripts, \"silent mode\" is usually what you want because it allows you to handle errors yourself without being distracted by default error messages. It's also easier to handle, since the failure cases are indicated by assigning distinct characters to `VARNAME`.\n\n### Example script\n\nA good example is worth a thousand words, so here is an example of how you could use the function within a script:\n\n``` bash\n#!/usr/bin/env bash\nsource \"${PATH_TO_REPO}/lib/getopts_long.bash\"\n\nwhile getopts_long ':af: all file:' OPTKEY; do\n    case ${OPTKEY} in\n        'a'|'all')\n            echo 'all triggered'\n            ;;\n        'f'|'file')\n            echo \"file supplied -- ${OPTARG}\"\n            ;;\n        '?')\n            echo \"INVALID OPTION -- ${OPTARG}\" >&2\n            exit 1\n            ;;\n        ':')\n            echo \"MISSING ARGUMENT for option -- ${OPTARG}\" >&2\n            exit 1\n            ;;\n        *)\n            echo \"UNIMPLEMENTED OPTION -- ${OPTKEY}\" >&2\n            exit 1\n            ;;\n    esac\ndone\n\nshift $(( OPTIND - 1 ))\n[[ \"${1}\" == \"--\" ]] && shift\n\n...\n```\n\n## How It Works\n\nIn general the use of `getopts_long` is identical to that of the built-in `getopts`. Just like the built-in function, you need to call `getopts_long` several times. Each time it will use the next positional parameter and a possible argument, if parsable, and provide it to you. The function will not change the set of positional parameters. If you want to shift them, it must be done manually:\n\n``` bash\nshift $(( OPTIND - 1 ))\n# now do something with $@\n```\n\nJust like `getopts`, `getopts_long` sets an exit status to FALSE when there's nothing left to parse. Thus, it's easy to use in a while-loop:\n\n``` bash\nwhile getopts ...; do\n  ...\ndone\n```\n\nIdentical to `getopts`, `getopts_long` will parse options and their possible arguments. It will stop parsing on the first non-option argument (a string that doesn't begin with a hyphen (`-`) that isn't an argument for any option in front of it). It will also stop parsing when it sees the `--` (double-hyphen), which means end of options.\n\n### Internal variables\n\nLike the original `getopts`, `getopts_long` sets the following variables:\n\n| Variable | Description |\n| -------- | ----------- |\n| OPTIND   | Holds the index to the next argument to be processed. This is how the function \"remembers\" its own status between invocations. OPTIND is initially set to 1, and **needs to be re-set to 1 if you want to parse anything again with getopts**. |\n| OPTARG   | This variable is set to any argument for an option found by `getopts_long`. It also contains the option flag of an unknown option. |\n| OPTERR   | (Values 0 or 1) Indicates if Bash should display error messages generated by `getopts_long`. The value is initialised to 1 on every shell startup - so be sure to always set it to 0 if you don't want to see annoying messages! <br><br> OPTERR is not specified by POSIX for the getopts built-in utility â€” only for the C getopt() function in unistd.h (opterr). OPTERR is bash-specific and not supported by shells such as ksh93, mksh, zsh, or dash. |\n\n### Error reporting\n\nRegarding error-reporting, there are two modes `getopts_long` can run in:\n\n  - verbose mode\n  - silent mode\n\nIn production scripts I recommend using the silent mode, because it allows you to handle errors yourself without being distracted by default error messages. It's also easier to handle, since the failure cases are indicated by assigning distinct characters to `VARNAME`.\n\n#### Verbose mode\n\n| Error type                  | What happens |\n| --------------------------- | ------------ |\n| invalid option              | `VARNAME` is set to `?` (question-mark) and `OPTARG` is unset. |\n| required argument not found | `VARNAME` is set to `?` (question-mark), `OPTARG` is unset and an _error message is printed_. |\n\n#### Silent mode\n\n| Error type                  | What happens |\n| --------------------------- | ------------ |\n| invalid option              | `VARNAME` is set to `?` (question-mark) and `OPTARG` is set to the (invalid) option character. |\n| required argument not found | `VARNAME` is set to `:` (colon) and `OPTARG` contains the option in question. |\n",
  "permissions": {
    "read": true,
    "write": false,
    "admin": false
  },
  "media_types": [
    "application/vnd.docker.container.image.v1+json"
  ],
  "content_types": [
    "image"
  ]
}