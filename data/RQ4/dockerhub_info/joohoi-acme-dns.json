{
  "user": "joohoi",
  "name": "acme-dns",
  "namespace": "joohoi",
  "repository_type": "image",
  "status": 1,
  "status_description": "active",
  "description": "Limited DNS server to automate ACME DNS challenges without exposing your DNS zone credentials.",
  "is_private": false,
  "is_automated": true,
  "can_edit": false,
  "star_count": 10,
  "pull_count": 5818313,
  "last_updated": "2022-08-08T14:08:37.256854Z",
  "date_registered": "2018-02-01T09:32:13.219846Z",
  "collaborator_count": 0,
  "affiliation": null,
  "hub_user": "joohoi",
  "has_starred": false,
  "full_description": "[![Build Status](https://travis-ci.org/joohoi/acme-dns.svg?branch=master)](https://travis-ci.org/joohoi/acme-dns) [![Coverage Status](https://coveralls.io/repos/github/joohoi/acme-dns/badge.svg?branch=master)](https://coveralls.io/github/joohoi/acme-dns?branch=master) [![Go Report Card](https://goreportcard.com/badge/github.com/joohoi/acme-dns)](https://goreportcard.com/report/github.com/joohoi/acme-dns)\n# acme-dns\n\nA simplified DNS server with a RESTful HTTP API to provide a simple way to automate ACME DNS challenges.\n\n## Why?\n\nMany DNS servers do not provide an API to enable automation for the ACME DNS challenges. Those which do, give the keys way too much power.\nLeaving the keys laying around your random boxes is too often a requirement to have a meaningful process automation.\n\nAcme-dns provides a simple API exclusively for TXT record updates and should be used with ACME magic \"\\_acme-challenge\" - subdomain CNAME records. This way, in the unfortunate exposure of API keys, the effects are limited to the subdomain TXT record in question.\n\nSo basically it boils down to **accessibility** and **security**.\n\nFor longer explanation of the underlying issue and other proposed solutions, see a blog post on the topic from EFF deeplinks blog: https://www.eff.org/deeplinks/2018/02/technical-deep-dive-securing-automation-acme-dns-challenge-validation\n\n## Features\n- Simplified DNS server, serving your ACME DNS challenges (TXT)\n- Custom records (have your required A, AAAA, NS, etc. records served)\n- HTTP API automatically acquires and uses Let's Encrypt TLS certificate\n- Limit /update API endpoint access to specific CIDR mask(s), defined in the /register request\n- Supports SQLite & PostgreSQL as DB backends\n- Rolling update of two TXT records to be able to answer to challenges for certificates that have both names: `yourdomain.tld` and `*.yourdomain.tld`, as both of the challenges point to the same subdomain.\n- Simple deployment (it's Go after all)\n\n## Usage\n\nA client application for acme-dns with support for Certbot authentication hooks is available at: [https://github.com/acme-dns/acme-dns-client](https://github.com/acme-dns/acme-dns-client).\n\n[![asciicast](https://asciinema.org/a/94903.png)](https://asciinema.org/a/94903)\n\nUsing acme-dns is a three-step process (provided you already have the self-hosted server set up):\n\n- Get credentials and unique subdomain (simple POST request to eg. https://auth.acme-dns.io/register)\n- Create a (ACME magic) CNAME record to your existing zone, pointing to the subdomain you got from the registration. (eg. `_acme-challenge.domainiwantcertfor.tld. CNAME a097455b-52cc-4569-90c8-7a4b97c6eba8.auth.example.org` )\n- Use your credentials to POST new DNS challenge values to an acme-dns server for the CA to validate from.\n- Crontab and forget.\n\n## API\n\n### Register endpoint\n\nThe method returns a new unique subdomain and credentials needed to update your record.\nFulldomain is where you can point your own `_acme-challenge` subdomain CNAME record to.\nWith the credentials, you can update the TXT response in the service to match the challenge token, later referred as \\_\\_\\_validation\\_token\\_received\\_from\\_the\\_ca\\_\\_\\_, given out by the Certificate Authority.\n\n**Optional:**: You can POST JSON data to limit the `/update` requests to predefined source networks using CIDR notation.\n\n```POST /register```\n\n#### OPTIONAL Example input\n```json\n{\n    \"allowfrom\": [\n        \"192.168.100.1/24\",\n        \"1.2.3.4/32\",\n        \"2002:c0a8:2a00::0/40\"\n    ]\n}\n```\n\n\n```Status: 201 Created```\n```json\n{\n    \"allowfrom\": [\n        \"192.168.100.1/24\",\n        \"1.2.3.4/32\",\n        \"2002:c0a8:2a00::0/40\"\n    ],\n    \"fulldomain\": \"8e5700ea-a4bf-41c7-8a77-e990661dcc6a.auth.acme-dns.io\",\n    \"password\": \"htB9mR9DYgcu9bX_afHF62erXaH2TS7bg9KW3F7Z\",\n    \"subdomain\": \"8e5700ea-a4bf-41c7-8a77-e990661dcc6a\",\n    \"username\": \"c36f50e8-4632-44f0-83fe-e070fef28a10\"\n}\n```\n\n### Update endpoint\n\nThe method allows you to update the TXT answer contents of your unique subdomain. Usually carried automatically by automated ACME client.\n\n```POST /update```\n\n#### Required headers\n| Header name   | Description                                | Example                                               |\n| ------------- |--------------------------------------------|-------------------------------------------------------|\n| X-Api-User    | UUIDv4 username received from registration | `X-Api-User: c36f50e8-4632-44f0-83fe-e070fef28a10`    |\n| X-Api-Key     | Password received from registration        | `X-Api-Key: htB9mR9DYgcu9bX_afHF62erXaH2TS7bg9KW3F7Z` |\n\n#### Example input\n```json\n{\n    \"subdomain\": \"8e5700ea-a4bf-41c7-8a77-e990661dcc6a\",\n    \"txt\": \"___validation_token_received_from_the_ca___\"\n}\n```\n\n#### Response\n\n```Status: 200 OK```\n```json\n{\n    \"txt\": \"___validation_token_received_from_the_ca___\"\n}\n```\n\n### Health check endpoint\n\nThe method can be used to check readiness and/or liveness of the server. It will return status code 200 on success or won't be reachable.\n\n```GET /health```\n\n## Self-hosted\n\nYou are encouraged to run your own acme-dns instance, because you are effectively authorizing the acme-dns server to act on your behalf in providing the answer to the challenging CA, making the instance able to request (and get issued) a TLS certificate for the domain that has CNAME pointing to it.\n\nSee the INSTALL section for information on how to do this.\n\n\n## Installation\n\n1) Install [Go 1.13 or newer](https://golang.org/doc/install).\n\n2) Build acme-dns: \n```\ngit clone https://github.com/joohoi/acme-dns\ncd acme-dns\nexport GOPATH=/tmp/acme-dns\ngo build\n```\n\n3) Move the built acme-dns binary to a directory in your $PATH, for example:\n`sudo mv acme-dns /usr/local/bin`\n\n4) Edit config.cfg to suit your needs (see [configuration](#configuration)). `acme-dns` will read the configuration file from `/etc/acme-dns/config.cfg` or `./config.cfg`, or a location specified with the `-c` flag.\n\n5) If your system has systemd, you can optionally install acme-dns as a service so that it will start on boot and be tracked by systemd. This also allows us to add the `CAP_NET_BIND_SERVICE` capability so that acme-dns can be run by a user other than root.\n\n    1) Make sure that you have moved the configuration file to `/etc/acme-dns/config.cfg` so that acme-dns can access it globally.\n\n    2) Move the acme-dns executable from `~/go/bin/acme-dns` to `/usr/local/bin/acme-dns` (Any location will work, just be sure to change `acme-dns.service` to match).\n\n    3) Create a minimal acme-dns user: `sudo adduser --system --gecos \"acme-dns Service\" --disabled-password --group --home /var/lib/acme-dns acme-dns`.\n\n    4) Move the systemd service unit from `acme-dns.service` to `/etc/systemd/system/acme-dns.service`.\n\n    5) Reload systemd units: `sudo systemctl daemon-reload`.\n\n    6) Enable acme-dns on boot: `sudo systemctl enable acme-dns.service`.\n\n    7) Run acme-dns: `sudo systemctl start acme-dns.service`.\n\n6) If you did not install the systemd service, run `acme-dns`. Please note that acme-dns needs to open a privileged port (53, domain), so it needs to be run with elevated privileges.\n\n### Using Docker\n\n1) Pull the latest acme-dns Docker image: `docker pull joohoi/acme-dns`.\n\n2) Create directories: `config` for the configuration file, and `data` for the sqlite3 database.\n\n3) Copy [configuration template](https://raw.githubusercontent.com/joohoi/acme-dns/master/config.cfg) to `config/config.cfg`.\n\n4) Modify the `config.cfg` to suit your needs.\n\n5) Run Docker, this example expects that you have `port = \"80\"` in your `config.cfg`:\n```\ndocker run --rm --name acmedns                 \\\n -p 53:53                                      \\\n -p 53:53/udp                                  \\\n -p 80:80                                      \\\n -v /path/to/your/config:/etc/acme-dns:ro      \\\n -v /path/to/your/data:/var/lib/acme-dns       \\\n -d joohoi/acme-dns\n```\n\n### Docker Compose\n\n1) Create directories: `config` for the configuration file, and `data` for the sqlite3 database.\n\n2) Copy [configuration template](https://raw.githubusercontent.com/joohoi/acme-dns/master/config.cfg) to `config/config.cfg`.\n\n3) Copy [docker-compose.yml from the project](https://raw.githubusercontent.com/joohoi/acme-dns/master/docker-compose.yml), or create your own.\n\n4) Edit the `config/config.cfg` and `docker-compose.yml` to suit your needs, and run `docker-compose up -d`.\n\n## DNS Records\n\nNote: In this documentation:\n- `auth.example.org` is the hostname of the acme-dns server\n- acme-dns will serve `*.auth.example.org` records\n- `198.51.100.1` is the **public** IP address of the system running acme-dns  \n\nThese values should be changed based on your environment.\n\nYou will need to add some DNS records on your domain's regular DNS server:\n- `NS` record for `auth.example.org` pointing to `auth.example.org` (this means, that `auth.example.org` is responsible for any `*.auth.example.org` records)\n- `A` record for `auth.example.org` pointing to `198.51.100.1`\n- If using IPv6, an `AAAA` record pointing to the IPv6 address.\n- Each domain you will be authenticating will need a `_acme-challenge` `CNAME` subdomain added. The [client](README.md#clients) you use will explain how to do this.\n\n## Testing It Out\n\nYou may want to test that acme-dns is working before using it for real queries.\n\n1) Confirm that DNS lookups for the acme-dns subdomain works as expected: `dig auth.example.org`.\n\n2) Call the `/register` API endpoint to register a test domain:\n```\n$ curl -X POST https://auth.example.org/register\n{\"username\":\"eabcdb41-d89f-4580-826f-3e62e9755ef2\",\"password\":\"pbAXVjlIOE01xbut7YnAbkhMQIkcwoHO0ek2j4Q0\",\"fulldomain\":\"d420c923-bbd7-4056-ab64-c3ca54c9b3cf.auth.example.org\",\"subdomain\":\"d420c923-bbd7-4056-ab64-c3ca54c9b3cf\",\"allowfrom\":[]}\n```\n\n3) Call the `/update` API endpoint to set a test TXT record. Pass the `username`, `password` and `subdomain` received from the `register` call performed above:\n```\n$ curl -X POST \\\n  -H \"X-Api-User: eabcdb41-d89f-4580-826f-3e62e9755ef2\" \\\n  -H \"X-Api-Key: pbAXVjlIOE01xbut7YnAbkhMQIkcwoHO0ek2j4Q0\" \\\n  -d '{\"subdomain\": \"d420c923-bbd7-4056-ab64-c3ca54c9b3cf\", \"txt\": \"___validation_token_received_from_the_ca___\"}' \\\n  https://auth.example.org/update\n```\n\nNote: The `txt` field must be exactly 43 characters long, otherwise acme-dns will reject it\n\n4) Perform a DNS lookup to the test subdomain to confirm the updated TXT record is being served:\n```\n$ dig -t txt @auth.example.org d420c923-bbd7-4056-ab64-c3ca54c9b3cf.auth.example.org\n```\n\n## Configuration\n\n```bash\n[general]\n# DNS interface. Note that systemd-resolved may reserve port 53 on 127.0.0.53\n# In this case acme-dns will error out and you will need to define the listening interface\n# for example: listen = \"127.0.0.1:53\"\nlisten = \"127.0.0.1:53\"\n# protocol, \"both\", \"both4\", \"both6\", \"udp\", \"udp4\", \"udp6\" or \"tcp\", \"tcp4\", \"tcp6\"\nprotocol = \"both\"\n# domain name to serve the requests off of\ndomain = \"auth.example.org\"\n# zone name server\nnsname = \"auth.example.org\"\n# admin email address, where @ is substituted with .\nnsadmin = \"admin.example.org\"\n# predefined records served in addition to the TXT\nrecords = [\n    # domain pointing to the public IP of your acme-dns server \n    \"auth.example.org. A 198.51.100.1\",\n    # specify that auth.example.org will resolve any *.auth.example.org records\n    \"auth.example.org. NS auth.example.org.\",\n]\n# debug messages from CORS etc\ndebug = false\n\n[database]\n# Database engine to use, sqlite3 or postgres\nengine = \"sqlite3\"\n# Connection string, filename for sqlite3 and postgres://$username:$password@$host/$db_name for postgres\n# Please note that the default Docker image uses path /var/lib/acme-dns/acme-dns.db for sqlite3\nconnection = \"/var/lib/acme-dns/acme-dns.db\"\n# connection = \"postgres://user:password@localhost/acmedns_db\"\n\n[api]\n# listen ip eg. 127.0.0.1\nip = \"0.0.0.0\"\n# disable registration endpoint\ndisable_registration = false\n# listen port, eg. 443 for default HTTPS\nport = \"443\"\n# possible values: \"letsencrypt\", \"letsencryptstaging\", \"cert\", \"none\"\ntls = \"letsencryptstaging\"\n# only used if tls = \"cert\"\ntls_cert_privkey = \"/etc/tls/example.org/privkey.pem\"\ntls_cert_fullchain = \"/etc/tls/example.org/fullchain.pem\"\n# only used if tls = \"letsencrypt\"\nacme_cache_dir = \"api-certs\"\n# optional e-mail address to which Let's Encrypt will send expiration notices for the API's cert\nnotification_email = \"\"\n# CORS AllowOrigins, wildcards can be used\ncorsorigins = [\n    \"*\"\n]\n# use HTTP header to get the client ip\nuse_header = false\n# header name to pull the ip address / list of ip addresses from\nheader_name = \"X-Forwarded-For\"\n\n[logconfig]\n# logging level: \"error\", \"warning\", \"info\" or \"debug\"\nloglevel = \"debug\"\n# possible values: stdout, TODO file & integrations\nlogtype = \"stdout\"\n# file path for logfile TODO\n# logfile = \"./acme-dns.log\"\n# format, either \"json\" or \"text\"\nlogformat = \"text\"\n```\n\n## HTTPS API\n\nThe RESTful acme-dns API can be exposed over HTTPS in two ways:\n\n1. Using `tls = \"letsencrypt\"` and letting acme-dns issue its own certificate\n   automatically with Let's Encrypt.\n1. Using `tls = \"cert\"` and providing your own HTTPS certificate chain and\n   private key with `tls_cert_fullchain` and `tls_cert_privkey`.\n\nWhere possible the first option is recommended. This is the easiest and safest\nway to have acme-dns expose its API over HTTPS.\n\n**Warning**: If you choose to use `tls = \"cert\"` you must take care that the\ncertificate *does not expire*! If it does and the ACME client you use to issue the\ncertificate depends on the ACME DNS API to update TXT records you will be stuck\nin a position where the API certificate has expired but it can't be renewed\nbecause the ACME client will refuse to connect to the ACME DNS API it needs to\nuse for the renewal.\n\n## Clients\n\n- acme.sh: [https://github.com/Neilpang/acme.sh](https://github.com/Neilpang/acme.sh)\n- Certify The Web: [https://github.com/webprofusion/certify](https://github.com/webprofusion/certify)\n- cert-manager: [https://github.com/jetstack/cert-manager](https://github.com/jetstack/cert-manager)\n- Lego: [https://github.com/xenolf/lego](https://github.com/xenolf/lego)\n- Posh-ACME: [https://github.com/rmbolger/Posh-ACME](https://github.com/rmbolger/Posh-ACME)\n- Sewer: [https://github.com/komuw/sewer](https://github.com/komuw/sewer)\n- Traefik: [https://github.com/containous/traefik](https://github.com/containous/traefik)\n- Windows ACME Simple (WACS): [https://www.win-acme.com](https://www.win-acme.com)\n\n### Authentication hooks\n\n- acme-dns-client with Certbot authentication hook: [https://github.com/acme-dns/acme-dns-client](https://github.com/acme-dns/acme-dns-client)\n- Certbot authentication hook in Python:  [https://github.com/joohoi/acme-dns-certbot-joohoi](https://github.com/joohoi/acme-dns-certbot-joohoi)\n- Certbot authentication hook in Go: [https://github.com/koesie10/acme-dns-certbot-hook](https://github.com/koesie10/acme-dns-certbot-hook)\n\n### Libraries\n\n- Generic client library in Python ([PyPI](https://pypi.python.org/pypi/pyacmedns/)): [https://github.com/joohoi/pyacmedns](https://github.com/joohoi/pyacmedns)\n- Generic client library in Go: [https://github.com/cpu/goacmedns](https://github.com/cpu/goacmedns)\n\n\n## Changelog\n\n- v0.8\n   - NOTE: configuration option: \"api_domain\" deprecated!\n   - New\n      - Automatic HTTP API certificate provisioning using DNS challenges making acme-dns able to acquire certificates even with HTTP api not being accessible from public internet.\n      - Configuration value for \"tls\": \"letsencryptstaging\". Setting it will help you to debug possible issues with HTTP API certificate acquiring process. This is the new default value.\n   - Changed\n      - Fixed: EDNS0 support\n      - Migrated from autocert to [certmagic](https://github.com/mholt/certmagic) for HTTP API certificate handling\n- v0.7.2\n   - Changed\n      - Fixed: Regression error of not being able to answer to incoming random-case requests.\n      - Fixed: SOA record added to a correct header field in NXDOMAIN responses.\n- v0.7.1\n   - Changed\n      - Fixed: SOA record correctly added to the TCP DNS server when using both, UDP and TCP servers.\n- v0.7\n   - New\n      - Added an endpoint to perform health checks\n   - Changed\n      - A new protocol selection for DNS server \"both\", that binds both - UDP and TCP ports.\n      - Refactored DNS server internals.\n      - Handle some aspects of DNS spec better.\n- v0.6\n   - New\n      - Command line flag `-c` to specify location of config file.\n      - Proper refusal of dynamic update requests.\n      - Release signing\n   - Changed\n      - Better error messages for goroutines\n- v0.5\n   - New\n      - Configurable certificate cache directory\n   - Changed\n      - Process wide umask to ensure created files are only readable by the user running acme-dns\n      - Replaced package that handles UUIDs because of a flaw in the original package\n      - Updated dependencies\n      - Better error messages\n- v0.4 Clear error messages for bad TXT record content, proper handling of static CNAME records, fixed IP address parsing from the request, added option to disable registration endpoint in the configuration.\n- v0.3.2 Dockerfile was fixed for users using autocert feature\n- v0.3.1 Added goreleaser for distributing binary builds of the releases\n- v0.3 Changed autocert to use HTTP-01 challenges, as TLS-SNI is disabled by Let's Encrypt\n- v0.2 Now powered by httprouter, support wildcard certificates, Docker images\n- v0.1 Initial release\n\n## TODO\n\n- Logging to a file\n- DNSSEC\n- Want to see something implemented, make a feature request!\n\n## Contributing\n\nacme-dns is open for contributions.\nIf you have an idea for improvement, please open an new issue or feel free to write a PR!\n\n## License\n\nacme-dns is released under the [MIT License](http://www.opensource.org/licenses/MIT).\n",
  "permissions": {
    "read": true,
    "write": false,
    "admin": false
  },
  "media_types": [
    "application/vnd.docker.container.image.v1+json"
  ],
  "content_types": [
    "image"
  ]
}