{
  "user": "aramperes",
  "name": "onetun",
  "namespace": "aramperes",
  "repository_type": "image",
  "status": 1,
  "status_description": "active",
  "description": "Userland WireGuard proxy",
  "is_private": false,
  "is_automated": false,
  "can_edit": false,
  "star_count": 0,
  "pull_count": 274,
  "last_updated": "2022-09-25T21:32:29.74096Z",
  "date_registered": "2021-10-16T04:12:00.586656Z",
  "collaborator_count": 0,
  "affiliation": null,
  "hub_user": "aramperes",
  "has_starred": false,
  "full_description": "<img align=\"right\" alt=\"onetun\" width=\"150\" src=\"https://raw.githubusercontent.com/aramperes/onetun/master/.github/onetun.png\">\n\n# onetun\n\nA cross-platform, user-space WireGuard port-forwarder that requires no system network configurations.\n\n[![crates.io](https://img.shields.io/crates/v/onetun.svg)](https://crates.io/crates/onetun)\n[![MIT licensed](https://img.shields.io/crates/l/onetun.svg)](./LICENSE)\n[![Build status](https://github.com/aramperes/onetun/actions/workflows/build.yml/badge.svg)](https://github.com/aramperes/onetun/actions)\n[![Latest Release](https://img.shields.io/github/v/tag/aramperes/onetun?label=release)](https://github.com/aramperes/onetun/releases/latest)\n\n## Use-case\n\n- You have an existing WireGuard endpoint (router), accessible using its UDP endpoint (typically port 51820); and\n- You have a peer on the WireGuard network, running a TCP or UDP service on a port accessible to the WireGuard network; and\n- You want to access this TCP or UDP service from a second computer, on which you can't install WireGuard because you\n  can't (no root access) or don't want to (polluting OS configs).\n\nFor example, this can be useful to access a port on your WireGuard network from a dev machine that doesn't have WireGuard installed.\n\n## Download\n\nonetun is available to install from [crates.io](https://crates.io/crates/onetun) with Rust ≥1.55:\n\n```shell\n$ cargo install onetun\n```\n\nYou can also download the binary for Windows, macOS (Intel), and Linux (amd64) from\nthe [Releases](https://github.com/aramperes/onetun/releases) page.\n\nYou can also run onetun using [Docker](https://hub.docker.com/r/aramperes/onetun):\n\n```shell\n$ docker run --rm --name onetun --user 1000 -p 8080:8080 aramperes/onetun \\\n    0.0.0.0:8080:192.168.4.2:8080 [...options...]\n```\n\nYou can also build onetun locally, using Rust ≥1.55:\n\n```shell\n$ git clone https://github.com/aramperes/onetun && cd onetun\n$ cargo build --release\n$ ./target/release/onetun\n```\n\n## Usage\n\n**onetun** opens a TCP or UDP port on your local system, from which traffic is forwarded to a port on a peer in your\nWireGuard network. It requires no changes to your operating system's network interfaces: you don't need to have `root`\naccess, or install any WireGuard tool on your local system for it to work.\n\nThe only prerequisite is to register a peer IP and public key on the remote WireGuard endpoint; those are necessary for\nthe WireGuard endpoint to trust the onetun peer and for packets to be routed.\n\n```\nonetun [src_host:]<src_port>:<dst_host>:<dst_port>[:TCP,UDP,...] [...]    \\\n    --endpoint-addr <public WireGuard endpoint address>                   \\\n    --endpoint-public-key <the public key of the peer on the endpoint>    \\\n    --private-key <private key assigned to onetun>                        \\\n    --source-peer-ip <IP assigned to onetun>                              \\\n    --keep-alive <optional persistent keep-alive in seconds>              \\\n    --log <optional log level, defaults to \"info\">\n```\n\n> Note: you can use environment variables for all of these flags. Use `onetun --help` for details.\n\n### Example\n\nSuppose your WireGuard endpoint has the following configuration, and is accessible from `140.30.3.182:51820`:\n\n```\n# /etc/wireguard/wg0.conf\n\n[Interface]\nPrivateKey = ********************************************\nListenPort = 51820\nAddress = 192.168.4.1\n\n# A friendly peer that hosts the TCP service we want to reach\n[Peer]\nPublicKey = AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAllowedIPs = 192.168.4.2/32\n\n# Peer assigned to onetun\n[Peer]\nPublicKey = BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\nAllowedIPs = 192.168.4.3/32\n```\n\nWe want to access a web server on the friendly peer (`192.168.4.2`) on port `8080`. We can use **onetun** to open a\nlocal port, say `127.0.0.1:8080`, that will tunnel through WireGuard to reach the peer web server:\n\n```shell\nonetun 127.0.0.1:8080:192.168.4.2:8080                                    \\\n    --endpoint-addr 140.30.3.182:51820                                    \\\n    --endpoint-public-key 'PUB_****************************************'  \\\n    --private-key 'PRIV_BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB'          \\\n    --source-peer-ip 192.168.4.3                                          \\\n    --keep-alive 10\n```\n\nYou'll then see this log:\n\n```\nINFO  onetun > Tunneling TCP [127.0.0.1:8080]->[192.168.4.2:8080] (via [140.30.3.182:51820] as peer 192.168.4.3)\n```\n\nWhich means you can now access the port locally!\n\n```\n$ curl 127.0.0.1:8080\nHello world!\n```\n\n### Multiple tunnels in parallel\n\n**onetun** supports running multiple tunnels in parallel. For example:\n\n```\n$ onetun 127.0.0.1:8080:192.168.4.2:8080 127.0.0.1:8081:192.168.4.4:8081\nINFO  onetun::tunnel > Tunneling TCP [127.0.0.1:8080]->[192.168.4.2:8080] (via [140.30.3.182:51820] as peer 192.168.4.3)\nINFO  onetun::tunnel > Tunneling TCP [127.0.0.1:8081]->[192.168.4.4:8081] (via [140.30.3.182:51820] as peer 192.168.4.3)\n```\n\n... would open TCP ports 8080 and 8081 locally, which forward to their respective ports on the different peers.\n\n### UDP Support\n\n**onetun** supports UDP forwarding. You can add `:UDP` at the end of the port-forward configuration, or `UDP,TCP` to support\nboth protocols on the same port (note that this opens 2 separate tunnels, just on the same port)\n\n```\n$ onetun 127.0.0.1:8080:192.168.4.2:8080:UDP\nINFO  onetun::tunnel > Tunneling UDP [127.0.0.1:8080]->[192.168.4.2:8080] (via [140.30.3.182:51820] as peer 192.168.4.3)\n\n$ onetun 127.0.0.1:8080:192.168.4.2:8080:UDP,TCP\nINFO  onetun::tunnel > Tunneling UDP [127.0.0.1:8080]->[192.168.4.2:8080] (via [140.30.3.182:51820] as peer 192.168.4.3)\nINFO  onetun::tunnel > Tunneling TCP [127.0.0.1:8080]->[192.168.4.2:8080] (via [140.30.3.182:51820] as peer 192.168.4.3)\n```\n\nNote: UDP support is totally experimental. You should read the UDP portion of the **Architecture** section before using\nit in any production capacity.\n\n### IPv6 Support\n\n**onetun** supports both IPv4 and IPv6. In fact, you can use onetun to forward some IP version to another, e.g. 6-to-4:\n\n```\n$ onetun [::1]:8080:192.168.4.2:8080\nINFO  onetun::tunnel > Tunneling TCP [[::1]:8080]->[192.168.4.2:8080] (via [140.30.3.182:51820] as peer 192.168.4.3)\n```\n\nNote that each tunnel can only support one \"source\" IP version and one \"destination\" IP version. If you want to support\nboth IPv4 and IPv6 on the same port, you should create a second port-forward:\n\n```\n$ onetun [::1]:8080:192.168.4.2:8080 127.0.0.1:8080:192.168.4.2:8080\nINFO  onetun::tunnel > Tunneling TCP [[::1]:8080]->[192.168.4.2:8080] (via [140.30.3.182:51820] as peer 192.168.4.3)\nINFO  onetun::tunnel > Tunneling TCP [127.0.0.1:8080]->[192.168.4.2:8080] (via [140.30.3.182:51820] as peer 192.168.4.3)\n```\n\n### Packet Capture\n\nFor debugging purposes, you can enable the capture of IP packets sent between onetun and the WireGuard peer.\nThe output is a libpcap capture file that can be viewed with Wireshark.\n\n```\n$ onetun --pcap wg.pcap 127.0.0.1:8080:192.168.4.2:8080\nINFO  onetun::pcap > Capturing WireGuard IP packets to wg.pcap\nINFO  onetun::tunnel > Tunneling TCP [127.0.0.1:8080]->[192.168.4.2:8080] (via [140.30.3.182:51820] as peer 192.168.4.3)\n```\n\nTo capture packets sent to and from the onetun local port, you must use an external tool like `tcpdump` with root access:\n\n```\n$ sudo tcpdump -i lo -w local.pcap 'dst 127.0.0.1 && port 8080'\n```\n\n## Architecture\n\n**In short:** onetun uses [smoltcp's](https://github.com/smoltcp-rs/smoltcp) TCP/IP and UDP stack to generate IP packets\nusing its state machine (\"virtual interface\"). The generated IP packets are\nencrypted by [boringtun](https://github.com/cloudflare/boringtun) and sent to the WireGuard endpoint. Encrypted IP packets received\nfrom the WireGuard endpoint are decrypted using boringtun and sent through the smoltcp virtual interface state machine.\nonetun creates \"virtual sockets\" in the virtual interface to forward data sent from inbound connections,\nas well as to receive data from the virtual interface to forward back to the local client.\n\n---\n\nonetun uses [tokio](https://github.com/tokio-rs/tokio), the async runtime, to listen for new TCP connections on the\ngiven port.\n\nWhen a client connects to the onetun's TCP port, a \"virtual client\" is\ncreated in a [smoltcp](https://github.com/smoltcp-rs/smoltcp) \"virtual\" TCP/IP interface, which runs fully inside the onetun\nprocess. An ephemeral \"virtual port\" is assigned to the \"virtual client\", which maps back to the local client.\n\nWhen the real client opens the connection, the virtual client socket opens a TCP connection to the virtual server\n(a dummy socket bound to the remote host/port).  The virtual interface in turn crafts the `SYN` segment and wraps it in an IP packet.\nBecause of how the virtual client and server are configured, the IP packet is crafted with a source address\nbeing the configured `source-peer-ip` (`192.168.4.3` in the example above),\nand the destination address matches the port-forward's configured destination (`192.168.4.2`).\n\nBy doing this, we let smoltcp handle the crafting of the IP packets, and the handling of the client's TCP states.\nInstead of actually sending those packets to the virtual server,\nwe can intercept them in the virtual interface and encrypt the packets using [boringtun](https://github.com/cloudflare/boringtun),\nand send them to the WireGuard endpoint's UDP port.\n\nOnce the WireGuard endpoint receives an encrypted IP packet, it decrypts it using its private key and reads the IP packet.\nIt reads the destination address, re-encrypts the IP packet using the matching peer's public key, and sends it off to\nthe peer's UDP endpoint.\n\nThe peer receives the encrypted IP and decrypts it. It can then read the inner payload (the TCP segment),\nforward it to the server's port, which handles the TCP segment. The TCP server responds with `SYN-ACK`, which goes back through\nthe peer's local WireGuard interface, gets encrypted, forwarded to the WireGuard endpoint, and then finally back to onetun's UDP port.\n\nWhen onetun receives an encrypted packet from the WireGuard endpoint, it decrypts it using boringtun.\nThe resulting IP packet is dispatched to the corresponding virtual interface running inside onetun;\nthe IP packet is then read and processed by the virtual interface, and the virtual client's TCP state is updated.\n\nWhenever data is sent by the real client, it is simply \"sent\" by the virtual client, which kicks off the whole IP encapsulation\nand WireGuard encryption again. When data is sent by the real server, it ends up routed in the virtual interface, which allows\nthe virtual client to read it. When the virtual client reads data, it simply pushes the data back to the real client.\n\nThis work is all made possible by [smoltcp](https://github.com/smoltcp-rs/smoltcp) and [boringtun](https://github.com/cloudflare/boringtun),\nso special thanks to the developers of those libraries.\n\n### UDP\n\nUDP support is experimental. Since UDP messages are stateless, there is no perfect way for onetun to know when to release the\nassigned virtual port back to the pool for a new peer to use. This would cause issues over time as running out of virtual ports\nwould mean new datagrams get dropped. To alleviate this, onetun will cap the amount of ports used by one peer IP address;\nif another datagram comes in from a different port but with the same IP, the least recently used virtual port will be freed and assigned\nto the new peer port. At that point, any datagram packets destined for the reused virtual port will be routed to the new peer,\nand any datagrams received by the old peer will be dropped.\n\nIn addition, in cases where many IPs are exhausting the UDP virtual port pool in tandem, and a totally new peer IP sends data,\nonetun will have to pick the least recently used virtual port from _any_ peer IP and reuse it. However, this is only allowed\nif the least recently used port hasn't been used for a certain amount of time. If all virtual ports are truly \"active\"\n(with at least one transmission within that time limit), the new datagram gets dropped due to exhaustion.\n\nAll in all, I would not recommend using UDP forwarding for public services, since it's most likely prone to simple DoS or DDoS.\n\n## License\n\nMIT License. See `LICENSE` for details. Copyright &copy; 2021-2022 Aram Peres.",
  "permissions": {
    "read": true,
    "write": false,
    "admin": false
  },
  "media_types": [
    "application/vnd.docker.container.image.v1+json"
  ],
  "content_types": [
    "image"
  ]
}