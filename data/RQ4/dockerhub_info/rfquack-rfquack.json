{
  "user": "rfquack",
  "name": "rfquack",
  "namespace": "rfquack",
  "repository_type": "image",
  "status": 1,
  "status_description": "active",
  "description": "RFQuack: the versatile RF-analysis tool that quacks!",
  "is_private": false,
  "is_automated": false,
  "can_edit": false,
  "star_count": 1,
  "pull_count": 277,
  "last_updated": "2021-06-04T08:30:16.457075Z",
  "date_registered": "2020-03-03T23:57:03.290871Z",
  "collaborator_count": 0,
  "affiliation": null,
  "hub_user": "rfquack",
  "has_starred": false,
  "full_description": "[![RFQuack DEMO - Packet capture and filtering via interactive CLI](https://img.youtube.com/vi/_59SRwfS6PU/0.jpg)](https://www.youtube.com/watch?v=_59SRwfS6PU)\n\nRFQuack is the only versatile RF-analysis tool that quacks!\n\nIt's a library firmware that allows you to sniff, manipulate, and transmit data over the air. And if you're not happy how the default firmware functionalities or you want to **change the hardware**, we made it **easy to extend**. Consider it as the hardware-agnostic and developer-friendly version of the great [YardStick One](https://greatscottgadgets.com/yardstickone/), which is based on the CC1101 radio chip. Differently from the other RF dongles, RFQuack is designed to be agnostic with respect to the radio chip. So if you want to use, say, the RF69, you can do it. If you need to use the CC1101L or CC1120, you can do it. Similarly to RFCat, RFQuack has a [console-based, Python-scriptable client](https://github.com/rfquack/RFQuack-cli) that allows you to set parameters, receive, transmit, and so on.\n\nWe assume you know what you're doing ü§ì\n\n- [Demos for the Impatients](#demos-for-the-impatients)\n- [Join the Community](#join-the-community)\n- [Another RF-analysis Dongle?](#another-rf-analysis-dongle)\n- [Quick Start Usage](#quick-start-usage)\n  - [Prepare Your Hardware](#prepare-your-hardware)\n  - [Install via Docker](#install-via-docker)\n    - [Building firmware image](#building-firmware-image)\n    - [Flashing via serial port](#flashing-via-serial-port)\n    - [Under the hood](#under-the-hood)\n  - [Install from Source](#install-from-source)\n- [Interact with the RFQuack Hardware](#interact-with-the-rfquack-hardware)\n- [Architecture](#architecture)\n- [Firmware Modules (a.k.a. plug-ins)](#firmware-modules-aka-plug-ins)\n  - [Radio Module](#radio-module)\n    - [Modem Configuration](#modem-configuration)\n    - [Transmit and Receive](#transmit-and-receive)\n    - [Register Access](#register-access)\n  - [Packet Filtering Module](#packet-filtering-module)\n  - [Packet Modification Module](#packet-modification-module)\n  - [Automatic Frequency Tuning and Bitrate Estimation](#automatic-frequency-tuning-and-bitrate-estimation)\n  - [Other Modules](#other-modules)\n  - [Frequency Synthesizer Calibration](#frequency-synthesizer-calibration)\n- [Docker Container Configuration](#docker-container-configuration)\n  - [General configuration](#general-configuration)\n  - [Radio configuration](#radio-configuration)\n- [License](#license)\n- [Talks & Publications about RFQuack](#talks--publications-about-rfquack)\n- [Research Projects that used RFQuack](#research-projects-that-used-rfquack)\n- [Disclaimer](#disclaimer)\n\n# Demos for the Impatients\n\n[![RFQuack DEMO - Packet capture and filtering via interactive CLI](https://img.youtube.com/vi/_59SRwfS6PU/0.jpg)](https://www.youtube.com/watch?v=_59SRwfS6PU)\n\n[![RFQuack DEMO - Analyzing 2.4GHz RF protocols](https://img.youtube.com/vi/XNLTjWi7cPo/0.jpg)](https://www.youtube.com/watch?v=XNLTjWi7cPo)\n\n# Join the Community\n* Slack team: https://join-rfquack-slack.herokuapp.com\n* Twitter: https://twitter.com/rfquack\n# Another RF-analysis Dongle?\nNot really. RFQuack is midway between software-defined radios (SDRs), which offer great\nflexibility at the price of a fatter code base, and RF dongles, which offer\ngreat speed and a plug-and-play experience at the price of less flexibility\n(you can't change the radio module).\n\nRFQuack is unique in these ways:\n\n* It's a **library** firmware, with many settings, sane defaults, and rich logging and debugging functionalities.\n* Supports **multiple radio chips**: nRF24, CC1101, basically all the chips supported by [RadioLib](https://github.com/jgromes/RadioLib), and we're adding more.\n* Does not require a **wired connection** to the host computer: the serial port is used only to display debugging messages, but the interaction between the client and the node is over TCP using WiFi (via Arduino WiFi) and GPRS (via [TinyGSM](https://github.com/vshymanskyy/TinyGSM) library) as physical layers.\n* The [RFQuack client](https://github.com/rfquack/RFQuack-cli) allows both **high- and low-level operations**: change frequency, change modulation, etc., as well as to interact with the radio chip via registers.\n* The firmware and its API support the concept of **packet-filtering** and **packet-modification rules**, which means that you can instruct the firmware to listen for a packet matching a given signature (in addition to the usual sync-word- and address-based filtering, which normally happen in the radio hardware), optionally modify it right away, and re-transmit it.\n\nSo, if you need to analyze a weird RF protocol with that special packet format\nor that very special modulation scheme, with mixed symbol encodings (yes, I'm\nlooking at you, CC1120 in 4-FSK mode ü§¨), with RFQuack you just swap the radio\nshield and you can just start working right away. And if we don't support that\nspecial radio chip, you can just craft your shield and add support to the software!\n\n# Quick Start Usage\nRFQuack is quite experimental, expect glitches and imperfections. So far we're quite happy with it, and used it successfully to analyze some industrial radio protocols (read the [Trend Micro Research white paper](https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/attacks-against-industrial-machines-via-vulnerable-radio-remote-controllers-security-analysis-and-recommendations) or the [DIMVA 2019 paper](https://www.dimva2019.org) for details).\n\n## Prepare Your Hardware\n* Choose the radio chip and board that you want to use among the supported ones: we tested the CC1101, nRF24 and ESP32-based boards (namely the Adafruit Feather HUZZAH32).\n* Assemble the board and the radio chip together: if you choose the Adafruit Feather system, all you have to do is stack the boards together, and do some minor soldering.\n* Connect the board to the USB port.\n\n| **Main board** | **Radio daughter board** | **Network connectivity** | **Cellular connectivity** |\n|----------------|-------------------------------------|----------------------|-----------------------|\n| Feather HUZZAH32 | Feather nRF24 | ESPWiFi | Not tested |\n| Feather HUZZAH32 | Feather CC1101 | ESPWiFi | Not tested |\n| Feather FONA | Radio FeatherWing RFM69HW 433 MHz | None | Tested with early versions of RFQuack |\n\nYou could play around with other combinations, of course. And if you feel generous, you can fork this repository, add support for untested hardware, and send us a pull request (including schematics for new daughter-boards)! üëè\n\n<img src=\"docs/imgs/base.jpg\" width=\"30%\" /><img src=\"docs/imgs/mcu-huzzah32.jpg\" width=\"30%\" /><img src=\"docs/imgs/mcu-huzzah32-cc1101-433.jpg\" width=\"30%\" /><img src=\"docs/imgs/mcu-huzza32-433-868.jpg\" width=\"30%\" /><img src=\"docs/imgs/mcu-teensy-cc1101-433.jpg\" width=\"30%\" /><img src=\"docs/imgs/mcu-teensy-rf24-cc1101.jpg\" width=\"30%\" /><img src=\"docs/imgs/mcu-teensy-cc1120-cc1101.jpg\" width=\"30%\" /><img src=\"docs/imgs/battery.jpg\" width=\"30%\" />\n\n## Install via Docker\nThe quickest way to get started is by mean of our Docker image. It will automatically build and upload the code to any supported board.\n* Make sure you have [Docker](https://docs.docker.com/get-started/) installed.\n* Run the Docker container: it'll upload RFQuack to any connected board. Use the cheat sheet and look for your configuration:\n\nWe provilde a helper `Makefile` and a `build.env` to set the variables.\n\n### Building firmware image\n\n```bash\n$ make docker-build  # or make docker-build-nc to force re-building\n$ make build\n```\n### Flashing via serial port\n\n```bash\n$ PORT=/dev/ttyUSB0 make flash\n```\n\n### Under the hood\n\nThis is what the helper `Makefile` is doing.\n\n| **Command**    | **Description**           |\n|----------------|---------------------------|\n|`docker run -e BOARD=HUZZAH32 -e RADIOA=CC1101 -e RADIOA_CS=2 -e RADIOA_IRQ=5 --rm -it rfquack/rfquack` | Build an RFQuack image for an Adafruit HUZZAH32 target, with a `CC1101` (`Chip Select` on PIN2, `GDO0` on PIN5) |\n|`docker run --device=/dev/ttyUSB0:/board -e BOARD=HUZZAH32 -e RADIOA=CC1101 -e RADIOA_CS=2 -e RADIOA_IRQ=5 --rm -it rfquack/rfquack` | Build and upload RFQuack to an Adafruit HUZZAH32 target (on `/dev/ttyUSB0`), with a `CC1101` (`Chip Select` on PIN2, `GDO0` on PIN5) |\n|`docker run --device=/dev/ttyUSB0:/board -e BOARD=HUZZAH32 -e RADIOA=nRF24  -e RADIOA_CS=5 -e RADIOA_IRQ=4 -e RADIOA_CE=2 --rm -it rfquack/rfquack` | Build and upload RFQuack for an Adafruit HUZZAH32 target (on `/dev/ttyUSB0`), with a `nRF24` (`Chip Select` on PIN5, `IRQ` on PIN4, `Chip Enable` on PIN2) |\n\n   Please, change the CS, IRQ and CE pins according to your wiring. ([More about container's variables](#docker-container))\n\n* Done üòé RFQuack is installed on your hardware and reachable via *serial*. It's time to [test it!](#test-it)\n\n## Install from Source\nRFQuack comes in the form of a firmware *library*, which means that you need to write your own \"main\" to define a minimum set of parameters. Don't worry, there's not much to write in there, and we provide a [few working examples](https://github.com/trendmicro/RFQuack/tree/RadioLib/examples).\n\n* Clone this repository\n* Make sure you have `platformio` and `protoc` installed.\n* Install `Nanopb 0.3.9.2` using `platformio lib -g install git+https://github.com/nanopb/nanopb.git#0.3.9.2`\n* Enter the main directory: `cd RFQuack`\n* Generate protobuf implementations: `make proto`\n* Install the RFQuack library via `platformio lib -g install file://./` (if you want to install it globally)\n\n  **NOTE** Platformio will *copy* the library to its internal storage. Any change to sources will not be reflected.\n* To talk to your RFQuack dongle, you have two options:\n  * **MQTT Transport (and hardware serial console):** install or have access to an MQTT broker (Mosquitto is just perfect for this):\n    * PROs:\n      * you don't need cables (hint: your RFQuack hardware can be battery powered)\n      * if you want to connect the RFQuack hardware to your computer, you get a free (hardware) serial console for monitoring on the USB port\n    * CONs:\n      * you need network connectivity (WiFi or cellular)\n      * there's latency\n  * **Hardware Serial Transport (and software serial console):** connect the dongle via USB\n    * PROs:\n      * there's little latency\n      * you don't need to rely on network stability\n    * CONs:\n      * if you want full monitoring and debugging capabilities, you'll need to hookup a UART cable to the RFQuack hardware (by default, a software serial device is used, and will write on pins 16, 12 (RX, TX); this can be changed by defining `RFQUACK_LOG_SS_RX_PIN` and `RFQUACK_LOG_SS_TX_PIN` before `#include <rfquack.h>`)\n      * your range is limited by the length of your USB cable (you don't say! üòÆ)\n* configure the firmware: best if you use one of the proposed examples.\n\n# Interact with the RFQuack Hardware\nNow you can use RFQuack via the IPython shell. We highly recommend tmux to keep an eye on the output log.\n\nYou need to install the [RFQuack CLI package](https://github.com/rfquack/RFQuack-cli). For the sake of simplicity we'll run it through Docker:\n\n```bash\n$ docker run --rm -it rfquack/cli --help\nUsage: rfquack [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  -l, --loglevel [CRITICAL|ERROR|WARNING|INFO|DEBUG|NOTSET]\n  -h, --help                      Show this message and exit.\n\nCommands:\n  mqtt  RFQuack client with MQTT transport.\n  tty   RFQuack client with serial transport.\n```\n\n```bash\n$  docker run --rm -it rfquack/cli mqtt --help\nUsage: rfquack mqtt [OPTIONS]\n\n  RFQuack client with MQTT transport. Assumes one dongle per MQTT broker.\n\nOptions:\n  -i, --client_id TEXT\n  -H, --host TEXT\n  -P, --port INTEGER\n  -u, --username TEXT\n  -p, --password TEXT\n  -h, --help            Show this message and exit.\n```\n\n```bash\n$ docker run --rm -it rfquack/cli tty --help\nUsage: rfquack tty [OPTIONS]\n\n  RFQuack client with serial transport.\n\nOptions:\n  -b, --baudrate INTEGER\n  -s, --bytesize INTEGER\n  -p, --parity [M|S|E|O|N]\n  -S, --stopbits [1|1.5|2]\n  -t, --timeout INTEGER\n  -P, --port TEXT           [required]\n  --help                    Show this message and exit.\n```\n\nMore concretely:\n\n```bash\n$ docker run --device /dev/ttyUSB0 --rm -it rfquack/cli tty -P /dev/ttyUSB0\n2019-04-10 18:04:31 local RFQuack[20877] INFO Transport initialized\n2019-04-10 18:04:31 local RFQuack[20877] INFO Transport pipe initialized (QoS = 2): mid = 2\n\n...\n\nRFQuack(/dev/ttyUSB0, 115200,8,N,1)> q.radioA.set_modem_config(modulation=\"OOK\", carrierFreq=434.437)\n\nresult = 0\nmessage = 2 changes applied and 0 failed.\n\nRFQuack(/dev/ttyUSB0, 115200,8,N,1)> q.radioA.rx()\n\nresult = 0\nmessage =\n...\n\n```\n\nAt this point you're good to go from here!\n\n![RFQuack Console](docs/imgs/console1.png)\n![RFQuack Console](docs/imgs/console2.png)\n\n# Architecture\n\n![RFQuack Architecture](docs/imgs/RFQuack%20Architecture.png)\n\nRFQuack has a modular software and hardware architecture comprising:\n\n* a radio chip (usually within a module)\n* a micro-controller unit (MCU)\n* an optional network adapter (cellular or WiFi)\n\nThe communication layers are organized as follows:\n\n* The Python client encodes the message for RFQuack with Protobuf (via [nanopb](https://github.com/nanopb/nanopb)): this ensures data-type consistency across firmware (written in C) and client (written in Python), light data validation, and consistent development experience.\n* The serialized messages are transported over MQTT (which allows multi-node and multi-client scenarios) or serial (when you need minimal latency).\n* The connectivity layer is just a thin abstraction over various cellular modems and the Arduino/ESP WiFi (or simply serial).\n* The message is decoded and handled by a software [module](#modules)\n\n# Firmware Modules (a.k.a. plug-ins)\nRFQuack's functionalities are built as pluggable modules, developed on top of a generic API.\nWhen you fire up the Python shell, you can interact with the connected dongle through the `q` object; try auto-completion *(tab is your friend)* and discover each loaded module.\n\nEach module has a built-in, super handy, helper function:\n```python\nRFQuack(/dev/ttyUSB0, 115200,8,N,1)> q.frequency_scanner.help()  \n\nHelper for 'frequency_scanner' module:\n> q.frequency_scanner.freq_step\nAccepts: rfquack_FloatValue\nFrequency step in Mhz (default: 1)\n\n> q.frequency_scanner.start()\nAccepts: rfquack_VoidValue\nStarts frequency scan\n\n...\n```\n\nFor sure, you already understood how it works: `q.frequency_scanner.freq_step` is a `float` property; you are free to **get** it.\n```python\nRFQuack(/dev/ttyUSB0, 115200,8,N,1)> q.frequency_scanner.freq_step\nvalue = 1.0\n```\n\nor **set** it:\n\n\n```python\nRFQuack(/dev/ttyUSB0, 115200,8,N,1)> q.frequency_scanner.freq_step = 5.0\nresult = 0\nmessage =\n```\n\nWhile `q.frequency_scanner.start()` is a `function(void)` :\n```python\nRFQuack(/dev/ttyUSB0, 115200,8,N,1)> q.frequency_scanner.start()\nresult = 0\nmessage = Nothing detected\n```\n\nThat's all!\n\nIf unsure which parameters a function/property can take please check the `src/rfquack.proto` protocol definition. Since we're using reflection, IPython can't offer completion here (if you know a way to have completion on dynamic attributes, please let us know!).\n\nIn the following, we explore the main functionalities of each - built in - module through some examples.\n\n## Radio Module\nEach connected radio will pop up as a module, progressively named after `radioA`, `radioB`, `radioC`, `radioD`, `radioE`.\n\nRFQuack's radio sub-system is based on [RadioLib](https://github.com/jgromes/RadioLib), so for most aspects you can refer to the RadioLib documentation. (yep, even for error codes).\n\n### Modem Configuration\nNot all radio modules support modem configuration. Sub-gigahertz modems usually do. The `q.radioA.set_modem_config()` function takes as argument a `rfquack_ModemConfig`, which is built of the following optional parameters:\n\n* `carrierFreq`: this is the carrier frequency, easy; make sure you comply to the radio module you chosen.\n* `txPower`: control the transmission power; set them wisely and make sure to follow the laws that apply to your country.\n* `preambleLen`: control the length of the radio's preamble.\n* `syncWords`: sync-word matching is a basic functionality of most packet-radio modules, which allow to efficiently filter packets that match the sync words and just ignore the rest, in order to keep the radio chip and the MCU busy only when an expected packet is received; depending on the radio module, the sync words can be set to zero (promiscuous mode) or up to a certain number of octects (e.g., 4); in promiscuous mode, the radio and MCU will be *very* busy, because they will pick up *everything*, including noise.\n* `isPromiscuous`: handy way to automatically set neat parameters and enter a fully *promiscuous* mode: sets syncword, disable crc filtering, disables automatic acknowledges, ...\n* `modulation`: this is the carrier modulation (ASK, OOK, FSK, GSK ...); make sure you comply to the radio module you chosen.\n* `useCRC`: whatever to enable or disable CRC filtering.\n* `bitRate`: this is the symbol bitrate (in kbps); make sure you comply to the radio module you chosen.\n* `rxBandwidth`: Sets receiver bandwidth (in kHz); make sure you comply to the radio module you chosen.\n\nUsage example (on a `CC1101` radio):\n\n```python\nRFQuack(/dev/ttyUSB0, 115200,8,N,1)> \\\n  q.radioA.set_modem_config(modulation=\"OOK\",\n                            carrierFreq=434.437,\n                            bitRate=3.41296,\n                            useCRC=False,\n                            syncWords=b\"\\x99\\x9A\",\n                            rxBandwidth=58)\nresult = 0\nmessage = 6 changes applied and 0 failed.\n```\n\nIt's not over üòõ\n\nUsually, radios receive and transmit *packets*. You can set the radio to expect a *fixed length* packet or, if it's supported, you can ask the radio to look for the packet length in the payload itself. All of this can be done using the `set_packet_len` function.\n\nUsage example (on a `CC1101` radio):\n\n```python\nRFQuack(/dev/ttyUSB0, 115200,8,N,1)> \\\n  q.radioA.set_packet_len(\n    isFixedPacketLen=True,\n    packetLen=102) # Sets len to 102 bytes.\nresult = 0\nmessage =\n```\n\n### Transmit and Receive\nThe `tx()`, `rx()`, `idle()` functions are self-explanatory: they set the module in transmit, receive and idle mode, respectively. To actually transmit data, you can use `send(data=b\"\\xAA\\xBB\")`, where data must be a list of raw octect values; there's a limit in the length, which is imposed by the radio module, so make sure you check the documentation.\n\n```python\nRFQuack(/dev/ttyUSB0, 115200,8,N,1)> \\\n  q.radioA.tx() # Enters TX mode.\n\nresult = 0\nmessage =\n\nRFQuack(/dev/ttyUSB0, 115200,8,N,1)> \\\n  q.radioA.send(data=bytes.fromhex(\"555555d42d\"))\n\nresult = 0\nmessage =\n```\n\nBy default, a packet is transmitted only once. If you want to repeat it, just set `repetitions` to whatever you want, and RFQuack will repeat the transmission as fast as possible (bound by the MCU clock, of course).\n\n### Register Access\nWhile RadioLib has gone very far in abstracting the interaction with the radio,\n\nSome radio chips are really \"unique,\" so to speak. In these cases, the only option is to grab a large cup of your favorite beverage, read through the datasheet, read again, again, and again.\n\nOnce you understand enough of how the radio works at the low level, you want to get-set registers in order to use it. In principle, you can do pretty much everything via registers.\n\nRFQuack is meant to be as generic as possible. What's not directly abstracted within a module can be accomplished by setting the registers via the `set_register` and `get_register` function.\n\nUsage example: retrieve the content of register `0x02`\n```python\nRFQuack(/dev/ttyUSB0, 115200,8,N,1)> q.radioA.get_register(int(\"0x02\",16))  \naddress = 2\nvalue = 3\n0x02 = 0b00000011 (0x03, 3)\n```\n\nOr alter it:\n```python\nRFQuack(/dev/ttyUSB0, 115200,8,N,1)> q.radioA.set_register(address=int(\"0x02\",16), value=int(\"0xFF\",16))  \nresult = 0\nmessage =\n```\nRecall that Python lets you do nice things like `q.radioA.set_register(address=int(\"0x02\", 16), value=0x01001100)` so you don't have to do any conversions.\n\nNote that every call to `set_modem_config()` will **alter the modem state, including several registers** to their default values (according to the datasheet). Also, many radio chips need to be in an \"idle\" state while setting certain registers. Please check the datasheet and use `idle()` before setting registers to be on the safe side. Last, be wise and double check that the values you set are actually there, using `get_register` after each `set_register`.\n\nWe noticed some timing issues with some radio chips. So, allow a small delay if you're setting many registers in a row (e.g., `for addr, value in regs: q.radioA.set_register(address=addr, value=value); time.sleep(0.2)`).\n\n\n## Packet Filtering Module\nOne of the main reasons why we created RFQuack is that we wanted to automate certain tasks in a flexible and fast way. For instance, we were building a PoC for a vulnerability in a radio protocol that, with a change in two bytes of the payload, the vulnerable receiver would execute another command. So, all we had to do was: stay in RX mode, wait for a packet matching a pattern, alter it, and re-transmit it.\n\nMost of this could be done with an SDR or with a RF-dongle and RFCat, but in both cases you'd have to \"pay\" the round-trip time from the radio, to the client, and back. For certain protocols, this timing is not acceptable. RFQuack's firmware implements this functionality natively, and exposes a simple API to configure packet filtering and manipulation.\n\n**Important:** filtering and patterns are applied past any filtering performed by the radio (e.g., based on sync words, address, CRC, RSSI, LQI). If you want to consider any packet, including noise, you'll have to disable these low-level filters enabling *promiscuous mode*)\n\n* `q.packet_filter.add(pattern=\"\", negateRule=bool)` takes two parameters: a regular-expression pattern complying with the [tiny-regex-c](https://github.com/kokke/tiny-regex-c) library (most common patterns are supported); adding a pattern means that RFQuack will discard any payload not matching that regex (or matching it, using `negateRule`); you can add multiple filters, they'll be applied one next the other (AND logic).\n* `q.packet_filter.reset()` will delete any stored filtering rule.\n* `q.packet_filter.dump()` will dump to CLI any stored rule.\n* `q.packet_filter.enabled` boolean that controls whatever the module is enabled, **do not forget to set it!**\n\n\n**NOTE** Packet's payload will be treated as a hex string.\n\nExample:\n```python\nRFQuack(/dev/ttyDUMMY, 115200,8,N,1)> \\\n  q.packet_filter.add(\n      # Accept only packets starting this way.\n      pattern=\"^aaaaaaaaaa999aa56a\",\n      negateRule=False\n      )\nresult = 0\nmessage = Rule added, there is 1 filtering rule.\n\nRFQuack(/dev/ttyDUMMY, 115200,8,N,1)> \\\n  # Do not forget to enable the module!\n  q.packet_filter.enabled = True \nresult = 0\nmessage =\n```\n\n## Packet Modification Module\nRFQuacks comes with a powerful packet modification module:\n\n * `q.packet_modification.add()` takes several parameters:\n    * `position` (number, optional) indicates the position in the payload that will be modified (e.g., 3rd byte);\n    * `content` (byte, optional) indicates the content that will be modified (e.g., all octects which value is `'A'`);\n    * `pattern` (optional) same as for the filter: only packets matching the pattern will be modified; if no pattern is specified, all packets will be modified.\n    * `operation` (enum) is the action to be performed, available operations are:\n      * (AND, OR, XOR, NOT, SLEFT, SRIGHT) + `operand` field.\n      * (PREPEND, APPEND, INSERT) + `payload` field.\n      * NOT.\n    * `operand` (byte) is the \"right\" value for the operations that need it *(AND, OR, XOR, NOT, SLEFT, SRIGHT)*.\n    * `payload` (byte) is the \"payload\" value for the operations that need it *(PREPEND, APPEND, INSERT)*.\n    * `pattern` (string) a regular-expression pattern complying with the [tiny-regex-c](https://github.com/kokke/tiny-regex-c), to restrict modifications to matching packets only.\n * `q.packet_modification.reset()` will delete any stored rule.\n * `q.packet_modification.dump()` will dump to CLI any stored rule.\n * `q.packet_modification.auto_shift` (boolean), if enabled the module will automatically left shifts packets matching `^5555` to get `^aaaa` packets.\n * `q.packet_modification.enabled` (boolean), controls whatever the module is enabled, **do not forget to set it!**\n\n\n**Example:** Let's say that you want to invert byte 3 of all packets that end with `'XYZ'` and XOR with `0x44` all bytes which value is `'A'` (and in position 5) of all packets that start with `'AAA'`. And you want to ignore any packet that do not contain at least 3 digits in their payload. You're going to need two modifications and one filter:\n\n```pyth",
  "permissions": {
    "read": true,
    "write": false,
    "admin": false
  },
  "media_types": [
    "application/vnd.docker.container.image.v1+json"
  ],
  "content_types": [
    "image"
  ]
}