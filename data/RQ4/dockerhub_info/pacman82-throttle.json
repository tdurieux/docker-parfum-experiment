{
  "user": "pacman82",
  "name": "throttle",
  "namespace": "pacman82",
  "repository_type": "image",
  "status": 1,
  "status_description": "active",
  "description": "Provide semaphores for distributed systems via an http interface",
  "is_private": false,
  "is_automated": false,
  "can_edit": false,
  "star_count": 0,
  "pull_count": 138,
  "last_updated": "2022-06-07T21:30:13.054185Z",
  "date_registered": "2021-05-16T16:45:59.252038Z",
  "collaborator_count": 0,
  "affiliation": null,
  "hub_user": "pacman82",
  "has_starred": false,
  "full_description": "# Throttle\n\nSemaphores for distributed systems.\n\n## Motivation\n\nThrottle provides semaphores as a service via an http interface. As the name indicates the primary usecase in mind is to throttle a systems access to a resource, by having the elements of that system to ask for permission (i.e. acquiring a lease) first. If the system consists of several process running on different machines, or virtual machines in the same Network, throttle might fit the bill.\n\nThrottle aims to be easy to operate, well-behaved in edge cases and works without a persistence backend.\n\n## Features\n\n* Server builds and runs on Windows, Linux, and OS-X.\n* Clients\n  * Python: A high level client with blocking API.\n  * Rust: Low level client with async API.\n* Prevents Deadlocks, through enforcing lock hierarchies.\n* Fairness (longer waiting peers have priority)\n* Locks with large count, won't be starved by lots of others with a small counts.\n* Resilient against Network outages.\n  * Locks expire to prevent leaking semaphore count due to Network errors or client crashes.\n  * Locks can be prolonged indefinetly using heartbeats which are send to the server.\n* Observability\n  * Prometheus Metrics\n  * Logging to stderr or gelf server\n* No persistence backend is required.\n  * Server keeps state in memory.\n  * Clients restore state to the server, in case of server reboot.\n\n## Installation\n\n### Server\n\n#### Cargo\n\nThe server binary is published to [crates.io](https://crates.io) and thus installable via cargo.\n\n```bash\ncargo install throttle-server\n```\n\n#### Pip\n\nAlternativly there are ready to use binaries deployed to PyPI, which can be installed via pip:\n\n```bash\npip install throttle-server\n```\n\nThis has been done manly for the convinience of Python users, who want to try out the client without installing a Rust toolchain.\n\n#### Docker\n\nThe throttle sever is also released as a small container image to docker hub.\n\n```shell\ndocker pull pacman82/throttle\n```\n\nAssuming you have a `throttle.toml` configuration file in the current working directory you could then run the server using:\n\n```shell\ndocker run --rm -v ${PWD}:/cfg -p 8000:8000 pacman82/throttle -c cfg/throttle.toml\n```\n\n### Python Client\n\nPython client is published to [PyPi](https://pypi.org) and can be installed using pip.\n\n```bash\npip install throttle-client\n```\n\n## Usage\n\n### Operating a Throttle server\n\n#### Starting and Shutdown\n\nAssuming the throttle executable to be in your path environment variable, you start a throttle sever by executing it. You can display the availible command line options using the `--help` flag. Starting it without any arguments is going to boot the server with default configuration.\n\n```bash\nthrottle\n```\n\nThis starts the server in the current process. Navigate with a browser to `localhost:8000` to see a welcoming message. You can shut Throttle down gracefully by pressing `Ctrl + C`.\n\n#### Default logging to stderr\n\nSet the `THROTTLE_LOG` environment variable to see more output on standard error. Valid values are `ERROR`, `WARN`, `INFO`, `DEBUG` and `TRACE`.\n\nIn bash:\n\n```bash\nTHROTTLE_LOG=WARN\n```\n\nor PowerShell:\n\n```shell\n$env:THROTLLE_LOG=\"INFO\"\n```\n\nStarting the server now yields more information.\n\n```log\n[2020-04-12T18:56:23Z INFO  throttle] Hello From Throttle\n[2020-04-12T18:56:23Z WARN  throttle] No semaphores configured.\n[2020-04-12T18:56:23Z INFO  actix_server::builder] Starting 8 workers\n[2020-04-12T18:56:23Z INFO  actix_server::builder] Starting \"actix-web-service-127.0.0.1:8000\" service on 127.0.0.1:8000\n[2020-04-12T18:56:23Z INFO  throttle::litter_collection] Start litter collection with interval: 300s\n```\n\n*Hint:* Enabling Gelf logging currently disables logging to standard error.\n\n#### Toml configuration file\n\nTo actually serve semaphores, we need to configure their names and full count. By default Throttle is looking for a configuration in the working directories `throttle.toml` file should it exist.\n\n```toml\n# Sample throttle.cfg Explaining the options\n\n# The time interval in which the litter collection backgroud thread checks for expired leases.\n# Default is set to 5 minutes.\nlitter_collection_interval = \"5min\"\n\n[semaphores]\n# Specify name and full count of semaphores. Below line creates a semaphore named A with a full\n# count of 42. Setting the count to 1 would create a Mutex.\nA = 42\n\n\n# Optional logging config, to log into graylog\n[logging.gelf]\nname = \"MyThrottleServer\"\nhost = \"my_graylog_instance.cloud\"\nport = 12201\n# Set this to either ERROR, WARN, INFO, DEBUG or TRACE.\nlevel = \"INFO\"\n\n\n## Optional logging config, to log to stderr. Can be overwritten using the `THROTTLE_LOG`\n## environment variable.\n# [logging.stderr]\n# Set this to either ERROR, WARN, INFO, DEBUG or TRACE.\n# level = \"INFO\"\n```\n\n#### Metrics\n\nThrottle supports Prometheus metrics, via the `/metrics` endpoint. Depending on your configuration and state they may e.g. look like this:\n\n```prometheus\n# HELP throttle_acquired Sum of all acquired locks.\n# TYPE throttle_acquired gauge\nthrottle_acquired{semaphore=\"A\"} 0\n# HELP throttle_longest_pending_sec Time the longest pending peer is waiting until now, to acquire a lock to a semaphore.\n# TYPE throttle_longest_pending_sec gauge\nthrottle_longest_pending_sec{semaphore=\"A\"} 0\n# HELP throttle_max Maximum allowed lock count for this semaphore.\n# TYPE throttle_max gauge\nthrottle_max{semaphore=\"A\"} 42\n# HELP throttle_num_404 Number of Get requests to unknown resource.\n# TYPE throttle_num_404 counter\nthrottle_num_404 0\n# HELP throttle_pending Sum of all pending locks\n# TYPE throttle_pending gauge\nthrottle_pending{semaphore=\"A\"} 0\n```\n\n### Python client\n\nThrottle ships with a Python client. Here is how to use it in a nutshell.\n\n```python\nfrom throttle_client import Peer, lock\n\n# Configure endpoint to throttle server\nurl = \"http://localhost:8000\"\n\n# Acquire a lock (with count 1) to semaphore A\nwith lock(url, \"A\"):\n    # Do stuff while holding lock to \"A\"\n    # ...\n\n# For acquiring lock count != 1 the count can be explicitly specified.\nwith lock(url, \"A\", count=4):\n    # Do stuff while holding lock to \"A\"\n    # ...\n\n# A is released at the end of with block\n```\n\n### Preventing Deadlocks with lock hierarchies\n\nAssume two semaphores `A` and `B`.\n\n```toml\n[semaphores]\nA = 1\nB = 1\n```\n\nYou want to acquire locks to them in a nested fashion:\n\n```python\nfrom throttle_client import Peer, lock\n\n# Configure endpoint to throttle server\nurl = \"http://localhost:8000\"\n\n# Acquire a lock to semaphore A\nwith lock(url, \"A\"):\n    # Do stuff while holding lock to \"A\"\n    # ...\n    with lock(url, \"B\") # <-- This throws an exception: \"Lock Hierarchy Violation\".\n      # ...\n\n```\n\nThe throttle server helps you preventing deadlocks. If `A` and `B` are not always locked in the same\norder, your system might deadlock at some point. Such errors can be hard to Debug, which is why\nthrottle fails early at any chance of deadlock. To enable the use case above, give `A` a lock level\nhigher than `B`.\n\n```toml\n[semaphores]\nA = { max=1, level=1 }\n# Level 0 is default. So the short notation is still good for B.\nB = 1\n```\n\n### Http routes\n\n* GET `/`: Prints a greeting message\n* GET `/health`: Always answers with `200 OK`\n* GET `/metrics:`: Metrics for prometheus\n* GET `/version`: Returns server version.\n\n#### Routes for managing peers and locks\n\n* POST `new_peer`: Creates a new peer. The body to this request must contain a human readable time duration with dimension in quotes. E.g.: `\"expires_in\": \"5m\"`, `\"expires_in\": \"30s\"` or `\"expires_in\": \"12h\"`. This is the time after which the peer is going to expire if not kept alive by prolonging its expiration time. Every lock acquired is always associated with a peer. If a peer expires, all locks are released. The request returns a random integer as peer id.\n* DELETE `/peer/{id}`: Removes the peer, releasing all its locks in the process. Every call to `new_peer` should be matched by a call to this route, so other peers do not have to wait for this peer to expire in order to acquire locks to the same semaphores.\n* PUT `/peer/{id}/{semaphore}`: Acquires lock to a semaphore for an existing peer. The body must contain the desired lock count. Throttle will answer either with `200 Ok` in case the lock could be acquired, or `202 Accepted` in case the lock can not be acquired until other peers release their lock. Specifying a lock count higher than the full count of the lock message or violating lock hierarchy will result in a `409 Conflict` error. Requesting a lock for an unknown semaphore or unknown peer is going to result in `400 Bad Request`. This request is idempotent, so acquiring locks can be repeated in case of a timeout, without risk of draining the semaphore. If waiting for a lock on the client side, busy waiting can be avoided using the optional `block_for` query parameter. E.g. `/peer/{id}/{semaphore}?block_for=10s`. The semantics for acquiring a lock with count `0` would be akward, so it's forbidden for now.\n* DELETE `/peer/{id}/{semaphore}`: Releases one specific lock for a peer.\n* POST `/restore`: Can be used by the client to react to a `400 Bad Request` those body contains `Unknown Semaphore`. This error indicates that the server does not remeber the clients state (e.g. the client may have expired due to prolonged connection loss). In this situation the client may choose to restore its previous state and acquired locks to the server. The body contains a JSON like this:\n\n  ```json\n  {\n    \"expires_in\": \"5m\",\n    \"peer_id\": 42,\n    \"acquired\": {\n      \"A\": 3,\n      \"B\": 1\n    }\n  }\n  ```\n\n  This would restore a client with id `42` and a lifetime of 5 minutes. It has a lock with count 3 to `A` and one with count 1 to `B`.\n* `Get` `/remainder?semaphore={semaphore}`: Answers the maximum semaphore count minus the sum of all acquired locks for this semaphore. Response is a plain text integer.\n* `Get` `/peers/{id}/is_acquired`: Answers `false` if peer has a pending lock. If all the locks of the peer are acquired the answer is `true`.\n",
  "permissions": {
    "read": true,
    "write": false,
    "admin": false
  },
  "media_types": [
    "application/vnd.docker.container.image.v1+json"
  ],
  "content_types": [
    "image"
  ]
}