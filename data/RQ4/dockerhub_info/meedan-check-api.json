{
  "user": "meedan",
  "name": "check-api",
  "namespace": "meedan",
  "repository_type": "image",
  "status": 1,
  "status_description": "active",
  "description": "Check API service https://meedan.com/check\n\nVerify breaking news online.",
  "is_private": false,
  "is_automated": true,
  "can_edit": false,
  "star_count": 0,
  "pull_count": 4607,
  "last_updated": "2019-01-31T09:40:22.73921Z",
  "date_registered": "2017-08-08T01:37:02.705481Z",
  "collaborator_count": 0,
  "affiliation": null,
  "hub_user": "meedan",
  "has_starred": false,
  "full_description": "## Check\n\n[![Code Climate](https://codeclimate.com/repos/58bdc058359261025a0020fa/badges/be660888a1cd1f246167/gpa.svg)](https://codeclimate.com/repos/58bdc058359261025a0020fa/feed)\n[![Test Coverage](https://codeclimate.com/repos/58bdc058359261025a0020fa/badges/be660888a1cd1f246167/coverage.svg)](https://codeclimate.com/repos/58bdc058359261025a0020fa/coverage)\n[![Issue Count](https://codeclimate.com/repos/58bdc058359261025a0020fa/badges/be660888a1cd1f246167/issue_count.svg)](https://codeclimate.com/repos/58bdc058359261025a0020fa/feed)\n[![Travis](https://travis-ci.org/meedan/check-api.svg?branch=develop)](https://travis-ci.org/meedan/check-api/)\n\nVerify breaking news online.\n\n### Installation\n\n#### Non-Docker-based\n\n* Configure `config/config.yml`, `config/database.yml`, `config/initializers/errbit.rb` and `config/initializers/secret_token.rb` (check the example files)\n* Run `bundle install`\n* Run `bundle exec rake db:migrate`\n* Create an API key: `bundle exec rake lapis:api_keys:create`\n* Start the server: `rails s`\n* Go to [http://localhost:3000/api](http://localhost:3000/api) and use the API key you created\n\nYou can optionally use Puma, which allows you to restart the Rails server by doing: `touch tmp/restart.txt`. In order to do that, instead of `rails s`, start the server with `bundle exec pumactl start`.\n\n#### Docker-based\n\n* You can also start the application on Docker by running `rake lapis:docker:run` (it will run on port 3000 and your local hostname) - you first need to create an API key after entering the container (`lapis:docker:shell`) before using the web interface\n\n### Theming\n\n#### Themeing the sign in page\n\nThe log in page is a separate static page. Edit `app/assets/sass/home.scss` and compile the CSS with node sass. This is not currently supported in the docker container. From outside the container install node-sass: `npm install -g node-sass` then `node-sass --watch ./app/assets/sass/home.scss ./public/css/home.css`\n\n#### Themeing inside the app\n\nAll pages except the sign in page use a customized Rails Admin Material UI theme. You can customize it by editing the Sass files in `app/stylesheets/rails_admin/custom/`. The Rails asset pipeline should parse them automatically.\n\nYou can force recompilation with: `rake assets:clean && rake assets:precompile`.\n\n#### Restarting while theming\n\nChanging configuration files requires a restart of the API.\n\nFrom inside the container: `touch tmp/restart.txt`.\n\n### Running the tests\n\n* `bundle install --without nothing`\n* `RAILS_ENV=test bundle exec rake db:migrate`\n* `RAILS_ENV=test bundle exec rake test:coverage`\n\n### Running the tests in parallel\n\n* `bundle install --without nothing`\n* `./test/setup-parallel-env.sh`\n* `RAILS_ENV=test bundle exec rake \"parallel:test[3]\"` (replace `3` by the number of threads you want)\n\n### Integration\n\nOther applications can communicate with this service (and test this communication) using the client library, which can be automatically generated. Other applications can also use functions exposed by this application in the client library. In order to do this, just add a tag `@expose` before the method definition, like this:\n\n```ruby\n  # Other comments come here\n  # @expose\n  def this_function_will_be_exposed(params)\n    # It's important that the exposed function can work standalonely\n  end\n```\n\n### Rake tasks\n\nThere are rake tasks for a few tasks (besides Rails' default ones). Run them this way: `bundle exec rake <task name>`\n\n* `test:coverage`: Run all tests and calculate test coverage\n* `application=<application name> lapis:api_keys:create`: Create a new API key for an application\n* `lapis:api_keys:delete_expired`: Delete all expired keys\n* `lapis:error_codes`: List all error codes that this application can return\n* `lapis:licenses`: List the licenses of all libraries used by this project\n* `lapis:client:ruby`: Generate a client Ruby gem, that allows other applications to communicate and test this service\n* `lapis:client:php`: Generate a client PHP library, that allows other applications to communicate and test this service\n* `lapis:docs`: Generate the documentation for this API, including models and controllers diagrams, Swagger, API endpoints, licenses, etc.\n* `lapis:docker:run`: Run the application in Docker\n* `lapis:docker:shell`: Enter the Docker container\n* `lapis:graphql:schema`: Update the GraphQL schema JSON\n* `swagger:docs:markdown`: Generate the documentation in markdown format\n* `transifex:localize`: Localize the application using Transifex and I18n\n\n### GraphQL\n\nThere is a GraphQL interface that exposes the data model as a GraphQL schema. The GraphQL files should be under `app/graph`.\n\nYou can update the schema file by running `rake lapis:graphql:schema`.\n\n### Background processing\n\nSome tasks run in background, for example: Slack notifications. They are processed using Sidekiq. Start Sidekiq with `bundle exec sidekiq` and monitor through the web interface at `/sidekiq`. We suggest that you protect that path with HTTP authentication.\n\n### Virus validation for uploaded files\n\nIn order to look for viruses on the files uploaded by users, you need to setup the configuration option `clamav_service_path`, which should be something like: `host:port`. A ClamAV service should be running at that address. If that configuration option is not set, uploaded files will skip the safety validation.\n\nYou can also test your instance of ClamAV REST this way:\n\n* Set the *test* configuration `clamav_service_path` to point to your instance\n* Run this: `bundle exec ruby test/models/uploaded_file_test.rb -n /real/`\n* Two tests should pass\n\nThe test uses a EICAR file (a test file which is recognized as a virus by scanners even though it's not really a virus).\n\n### Integration with Pender archives\n\n* Add a migration that creates a new dynamic annotation for the archiver\n* Declare this new type at `app/models/bot/keep.rb`\n* Add the readable name of that archiver to `config/locales/en.yml`\n\n### Implement a new workflow\n\n**IMPORTANT: Your annotation type must match your workflow class name... for example, Workflow::YourStatus for your class name and your_status for the annotation type**\n\n* Add a class `Workflow::YourStatus` to `app/models/workflow/your_status.rb` that inherits from `Workflow::Base`\n* Add a migration to create that dynamic annotation type (type should be the same name as the class, e.g., `your_status`)\n* Add translations to `config/locales/*.yml`\n* Add core values to `config/core_statuses.yml`\n* Add the new class to the list `Workflow::Workflow.workflows`\n* Take a look at existing implementations under `app/models/workflow/*`\n\n### Localization\n\nLocalization is powered by Transifex + I18n. In order to localize the application, you need to set the `transifex_user` and `transifex_password` configuration options on `config/config.yml`. Then, when you run `rake transifex:localize`, the following will happen automatically:\n\n* The supported languages on Transifex will be set as the available languages for I18n on `config/application.rb`\n* New translations will be downloaded from Transifex and saved under `config/locales`\n* New localizable strings will be parsed from code, saved on `config/locales/en.yml` and sent to Transifex\n\nWe call \"localizable strings\" any call to the `I18n.t` function like this: `I18n.t(:string_unique_id, default: 'English string')`.\n\nClients should send the `Accept-Language` header in order to get localized content. If you want to serve everything in English, just add `locale: 'en'` to your `config/config.yml`.\n\n#### Update CLDR data\n\nCLDR data lives in `data/` and contains data from CLDR download by `ruby-cldr`. In order to update its contents (as explained [here](https://github.com/svenfuchs/ruby-cldr/issues/24#issuecomment-65855492)), run this in Rails console:\n\n```ruby\nrequire 'cldr/thor'\nthor = Cldr::Thor.new\nthor.download\nthor.export\n```\n\n### Admin UI\n\n#### Add new settings fields\n\n* Create a method on model to receive the data and set it to the setting field. For example, in `app/models/team.rb`:\n\n```ruby\n  def media_verification_statuses=(statuses)\n    self.send(:set_media_verification_statuses, statuses)\n  end\n```\n\n* Configure the fields on Admin UI (`config/initializers/rails_admin.rb`)\n\n**`show` block**: on config for the model (as example, `Team`) configure the type of field (as example, `json`) and the label to be displayed. Fields that are supposed to be Array or Hash could be configured as `json` be easier to read.\n\n```ruby\nshow do\n  configure :get_media_verification_statuses, :json do\n    label 'Media verification statuses'\n  end\n  (...)\nend\n```\n\n**`edit` block**: on config for the model (as example, `Team`) configure the type of field (as example, `yaml`), the label to be displayed and the help with a description.\nFields that are supposed to be Array or Hash could be configured as `yaml`, that is more flexible than JSON format.\n\nFor `yaml` fields the content should be displayed on a `textarea` and have an example for the field. Just include `render_settings('text')` and add an example in a partial file, like `app/views/rails_admin/main/_media_verification_statuses.html.erb`\n\n```ruby\nedit do\n  field :media_verification_statuses, :yaml do\n    label 'Media verification statuses'\n    render_settings('text')\n    help \"A list of custom verification statuses for items that match your team's journalistic guidelines.\"\n  end\nend\n```\n\nFor `string` fields the content should be displayed on a `text_field` and have an example for the field. Just include `render_settings('field')` and add an example in a partial file, like `app/views/rails_admin/main/_suggested_tags.html.erb`. Also, the `formatted_value` should be included like `formatted value { bindings[:object].get_suggested_tags }`.\n\n```ruby\nedit do\n  field :suggested_tags do\n    label 'Suggested tags'\n    formatted_value { bindings[:object].get_suggested_tags }\n    help \"A list of common tags to be used with items and sources in your team.\"\n    render_settings('field')\n  end\nend\n```\n\n### Checkdesk migration\n\n#### Checkdesk side\n\n* Run `drush vset \"check_story_ids\" --format=json [id1,id2,id3]` to migrate specific stories\n* Run `drush eval \"_checkdesk_core_export_data_csv();\"` : This command will output a directory inside `[files directory]/checkdesk_migration/[[instance-name]]`.\n* [instance-name] directory contain the following CSV files\n  - `00_teams.csv` : id, team_name, slug, logo\n  - `01_users.csv` : name, email, password, profile_image, skip_confirmation_mail, uuid, provider, created_at, login\n  - `02_team_users.csv` : team_id, user_id, role, status, created_at, updated_at\n  - `03_projects.csv` : id, title, team_id, user_id, description, lead_image, created_at, updated_at\n  - `04_project_medias.csv` : id, project_id, url, user_id, created_at, updated_at\n  - `05_tags.csv` : annotator_id, annotator_type, annotated_id, annotated_type, tag, created_at, updated_at\n  - `06_comments.csv` : annotator_id, annotator_type, annotated_id, annotated_type, comment, created_at, updated_at\n  - `07_statuses.csv` : annotator_id, annotator_type, annotated_id, annotated_type, status, created_at, updated_at\n  - `08_flags.csv` : annotator_id, annotator_type, annotated_id, annotated_type, flag, created_at, updated_at\n* Copy the output from the above step `[instance-name]` into Check `db/data`.\n\n#### Check side\n\n* Run `rake db:migrate:checkdesk`.\n* Rake command will generate `mapping_ids.yml` to log Checkdesk => Check mapping and mark migrated model.\n\n### Apollo integration\n\n* Copy `config/apollo-engine-proxy.json.example` to `config/apollo-engine-proxy.json` and add your API key\n* Point the clients (e.g., `check-web`) to the proxy host and port\n\n### Credits\n\nMeedan (hello@meedan.com)\n",
  "permissions": {
    "read": true,
    "write": false,
    "admin": false
  },
  "media_types": [
    "application/vnd.docker.container.image.v1+json"
  ],
  "content_types": [
    "image"
  ]
}