{
  "user": "cloudflare",
  "name": "complainer",
  "namespace": "cloudflare",
  "repository_type": "image",
  "status": 1,
  "status_description": "active",
  "description": "Complainer's job is to send notifications to different services when tasks fail on Mesos cluster.",
  "is_private": false,
  "is_automated": true,
  "can_edit": false,
  "star_count": 0,
  "pull_count": 55746,
  "last_updated": "2018-03-04T20:33:50.858787Z",
  "date_registered": "2016-06-03T14:02:54.108004Z",
  "collaborator_count": 0,
  "affiliation": null,
  "hub_user": "cloudflare",
  "has_starred": false,
  "full_description": "# Complainer\n\nComplainer's job is to send notifications to different services when tasks\nfail on Mesos cluster. While your system should be reliable to failures of\nindividual tasks, it's nice to know when things fail and why.\n\nSupported log upload services:\n\n* No-op - keeps URLs to Mesos slave sandbox.\n* S3 - both AWS S3 and on-premise S3-compatible API.\n\nSupported reporting services:\n\n* [Sentry](https://getsentry.com/) - a great crash reporting software.\n* [Hipchat](https://www.hipchat.com/) - not so great communication platform.\n* [Slack](https://slack.com/) - another communication platform.\n* File - regular file stream output, including stdout/stderr.\n\n## Quick start\n\nStart sending all failures to Sentry:\n\n```\ndocker run -it --rm cloudflare/complainer \\\n  -masters=http://mesos.master:5050 \\\n  -uploader=noop \\\n  -reporters=sentry \\\n  -sentry.dsn=https://foo:bar@sentry.dsn.here/8\n```\n\nRun this on Mesos itself!\n\n![Sentry screenshot](screenshots/sentry.png)\n\n## Reporting configuration\n\nComplainer needs two command line flags to configure itself:\n\n* `name` - Complainer instance name (default is `default`).\n* `default` - Whether to use `default` instance for each reporter implicitly.\n* `masters` - Mesos master URL list (ex: `http://host:port,http://host:port`).\n* `listen` - Listen address for HTTP (ex: `127.0.0.1:8888`).\n\nThese settings can be applied by env vars as well:\n\n* `COMPLAINER_NAME` - Complainer instance name (default is `default`).\n* `COMPLAINER_DEFAULT` - Whether to use `default` instance for each reporter implicitly.\n* `COMPLAINER_MASTERS` - Mesos master URL list (ex: `http://host:port,http://host:port`).\n* `COMPLAINER_LISTEN` - Listen address for HTTP (ex: `127.0.0.1:8888`).\n\n\n## Filtering based on the failures framework\n\nIf you're in the situation where you have multiple marathons running against\na mesos, and want to segregate out which failures go where, the following\noptions are of interest. Each option can be specified multiple times.\n\n* `framework-whitelist` - This is a regex option; if given, the failures\n  framework must match at least one whitelist. If no whitelist is specified,\n  then it's treated as if '.*' had been passed- all failures are whitelisted\n  as long as they don't match a blacklist.\n* `framework-blacklist` - This is a regex option; if given, any failure that\n  matches this are ignored.\n\nNote that the order of evaluation is such that blacklists are applied first,\nthen whitelists.\n\n### HTTP interface\n\nComplainer provides HTTP interface. You have to enable it with `-listen`\ncommand line flag or with `COMPLAINER_LISTEN` env variable.\n\nThis interface is used for the following:\n\n* Health checks\n* [pprof](https://golang.org/pkg/net/http/pprof/) endpoint\n\n#### Health checks\n\n`/health` endpoint reports `200 OK` when things are operating mostly normally\nand `500 Internal Server Error` when complainer cannot talk to Mesos.\n\nWe don't check for other issues (uploader and reporter failures) because they\nare not guaranteed to be happening continuously to recover themselves.\n\n#### version endpoint\n\n`/version` endpoint reports `200 OK` and outputs the current version of this application.\n\n```\ncomplainer (default) v1.7.0\n```\n\n#### pprof endpoint\n\n`/debug/pprof` endpoint exposes the regular `net/http/pprof` interface:\n\n* https://golang.org/pkg/net/http/pprof/\n\n### Log upload services\n\nLog upload service is specified by command line flag `uploader`.\nAlternatively you can specify this by env var `COMPLAINER_UPLOADER`.\nOnly one uploader can be specified per complainer instance.\n\n#### no-op\n\nUploader name: `noop`\n\nNo-op uploader just echoes Mesos slave sandbox URLs.\n\n#### S3 AWS\n\nUploader name: `s3aws`.\n\nThis uploader uses official AWS SDK and should be used if you use AWS.\n\nStdout and stderr logs get uploaded to S3 and signed URLs provided to reporters.\nLogs are uploaded into the following directory structure by default:\n\n* `${YYYY-MM-DD}/complainer/${task_name}/${YYYY-MM-DDTHH:mm:ssZ}-${task_id}/{stdout,stderr}`\n\nCommand line flags:\n\n* `s3aws.access_key` - S3 access key.\n* `s3aws.secret_key` - S3 secret key.\n* `s3aws.region` - S3 region.\n* `s3aws.bucket` - S3 bucket name.\n* `s3aws.prefix` - S3 prefix template (`Failure` struct is available).\n* `s3aws.timeout` - Timeout for signed S3 URLs (ex: `72h`).\n\nYou can set value of any command line flag via environment variable. Example:\n\n* Flag `s3aws.access_key` becomes env variable `S3_ACCESS_KEY`\n\nFlags override env variables if both are supplied.\n\nThe minimum AWS policy for complainer is `s3:PutObject`:\n\n* https://docs.aws.amazon.com/AmazonS3/latest/dev/using-with-s3-actions.html\n\n##### S3 Compatible APIs\n\nUploader name: `s3goamz`.\n\nThis uploader uses goamz package and supports S3 compatible APIs that use\nv2 style signatures. This includes Ceph Rados Gateway.\n\nStdout and stderr logs get uploaded to S3 and signed URLs provided to reporters.\nLogs are uploaded into the following directory structure by default:\n\n* `${YYYY-MM-DD}/complainer/${task_name}/${YYYY-MM-DDTHH:mm:ssZ}-${task_id}/{stdout,stderr}`\n\n* `s3goamz.access_key` - S3 access key.\n* `s3goamz.secret_key` - S3 secret key.\n* `s3goamz.endpoint` - S3 endpoint (ex: `https://complainer.s3.example.com`).\n* `s3goamz.bucket` - S3 bucket name.\n* `s3goamz.prefix` - S3 prefix template (`Failure` struct is available).\n* `s3goamz.timeout` - Timeout for signed S3 URLs (ex: `72h`).\n\nYou can set value of any command line flag via environment variable. Example:\n\n* Flag `s3goamz.access_key` becomes env variable `S3_ACCESS_KEY`\n\nFlags override env variables if both are supplied.\n\n### Reporting services\n\nReporting services are specified by command line flag `reporters`.\nAlternatively you can specify this by env var `COMPLAINER_REPORTERS`.\nSeveral services can be specified, separated by comma.\n\n#### Sentry\n\nCommand line flags:\n\n* `sentry.dsn` - Default Sentry DSN to use for reporting.\n\nLabels:\n\n* `dsn` - Sentry DSN to use for reporting.\n\nIf label is unspecified, command line flag value is used.\n\n#### Hipchat\n\nCommand line flags:\n\n* `hipchat.base_url` - Base Hipchat URL, needed for on-premise installations.\n* `hipchat.room` - Default Hipchat room ID to send notifications to.\n* `hipchat.token` - Default Hipchat token to authorize requests.\n* `hipchat.format` - Template to use in messages.\n\nLabels:\n\n* `base_url` - Hipchat URL, needed for on-premise installations.\n* `room` - Hipchat room ID to send notifications to.\n* `token` - Hipchat token to authorize requests.\n\nIf label is unspecified, command line flag value is used.\n\nTemplates are based on [`text/template`](https://golang.org/pkg/text/template/).\nThe following fields are available:\n\n* `failure` - Failure struct.\n* `stdoutURL` - URL of the stdout stream.\n* `stderrURL` - URL of the stderr stream.\n\n#### Slack\n\nCommand line flags:\n\n* `slack.hook_url` - Webhook URL, needed to post something (required).\n* `slack.channel` - Channel to post into, e.g. #mesos (optional).\n* `slack.username` - Username to post with, e.g. \"Mesos Cluster\" (optional).\n* `slack.icon_emoji` - Icon Emoji to post with, e.g. \":mesos:\" (optional).\n* `slack.icon_url` - Icon URL to post with, e.g. \"http://my.com/pic.png\" (optional).\n* `slack.format` - Template to use in messages.\n\nLabels:\n\n* `hook_url` - Webhook URL, needed to post something (required).\n* `channel` - Channel to post into, e.g. #mesos (optional).\n* `username` - Username to post with, e.g. \"Mesos Cluster\" (optional).\n* `icon_emoji` - Icon Emoji to post with, e.g. \":mesos:\" (optional).\n* `icon_url` - Icon URL to post with, e.g. \"http://my.com/avatar.png\" (optional).\n\nIf label is unspecified, command line flag value is used.\n\nFor more details see [Slack API docs](https://api.slack.com/incoming-webhooks).\n\nTemplates are based on [`text/template`](https://golang.org/pkg/text/template/).\nThe following fields are available:\n\n* `failure` - Failure struct.\n* `stdoutURL` - URL of the stdout stream.\n* `stderrURL` - URL of the stderr stream.\n\n### Jira\n\nCommand line flags:\n\n* `jira.url` - Default JIRA instance url (required).\n* `jira.username` - JIRA user to authenticate as (required).\n* `jira.password` - JIRA password for the user to authenticate (required).\n* `jira.issue_closed_status` - The status of JIRA issue when it is considered closed.\n* `jira.fields` - JIRA fields in `key:value;...` format seperated by `;`,\n   this configuration MUST contain `Project`, `Summary` and `Issue Type`.\n\nExample `jira.fields`:\n\n```\nProject:COMPLAINER;Issue Type:Bug;Summary:Task {{ .failure.Name }} died with status {{ .failure.State }};Description:[stdout|{{ .stdoutURL }}], [stderr|{{ .stderrURL }}], ID={{ .failure.ID }}\n```\n\nTemplates are based on [`text/template`](https://golang.org/pkg/text/template/).\nThe following fields are available:\n\n* `failure` - Failure struct.\n* `stdoutURL` - URL of the stdout stream.\n* `stderrURL` - URL of the stderr stream.\n\n#### File\n\nCommand line flags:\n\n* `file.name` - File name to output logs.\n* `file.format` - Template to use in output logs.\n\nTemplates are based on [`text/template`](https://golang.org/pkg/text/template/).\nThe following fields are available:\n\n* `failure` - Failure struct.\n* `stdoutURL` - URL of the stdout stream.\n* `stderrURL` - URL of the stderr stream.\n\n### Label configuration\n\n#### Basics\n\nTo support flexible notification system, Mesos task labels are used. Marathon\ntask labels get copied to Mesos labels, so these are equivalent.\n\nThe minimal set of labels needed is an empty set. You can configure default\nvalues in Complainer's command line flags and get all notifications with\nthese settings. In practice, you might want to have different reporters for\ndifferent apps.\n\nFull format for complainer label name looks like this:\n\n* `complainer_${name}_${reporter}_instance_${instance}_${key}`\n\nExample (`dsn` set for `default` Sentry of `default` Complainer):\n\n* `complainer_default_sentry_instance_default_dsn`\n\nThis is long and complex, so default parts can be skipped:\n\n* `complainer_sentry_dsn`\n\n#### Advanced labels\n\nThe reason for having long label name version is to add the flexibility.\nImagine you want to report app failures to the internal Sentry, two internal\nHipchat rooms (default and project-specific) and the external Sentry.\n\nSet of labels would look like this:\n\n* `complainer_sentry_dsn: ABC` - for internal Sentry.\n* `complainer_hipchat_instances: default,myapp` - adding instance `myapp`.\n* `complainer_hipchat_instance_myapp_room: 123`- setting room for `myapp`.\n* `complainer_hipchat_instance_myapp_token: XYZ`- setting token for `myapp`.\n* `complainer_external_sentry_dsn: FOO` - for external Sentry.\n\nInternal and external complainers can have different upload services.\n\nImplicit instances are different, depending on how you run Complainer.\n\n* `-default=true` (default) - `default` instance is implicit.\n* `-default=false` - no instances are configured implicitly.\n\nThe latter is useful for opt-in monitoring, including monitoring of Complainer\nitself (also known as dogfooding).\n\n#### Templating\n\nTemplates are based on [`text/template`](https://golang.org/pkg/text/template/).\nThe following fields are available:\n\n* `nl` - Newline symbol (`\\n`).\n* `config` - Function to get labels for the reporter.\n* `failure` - Failure struct: https://godoc.org/github.com/cloudflare/complainer#Failure\n* `stdoutURL` - URL of the stdout stream.\n* `stderrURL` - URL of the stderr stream.\n\nWith `config` you can use labels in templates. For example, the following\ntemplate for the Slack reporter:\n\n```\nTask {{ .failure.Name }} ({{ .failure.ID }}) died | {{ config \"mentions\" }}{{ .nl }}\n```\n\nWith the label `complainer_slack_mentions=@devs` will be evaluated to:\n\n```\nTask foo.bar (bar.foo.123) died | @devs\n```\n\n#### Dogfooding\n\nTo report errors for complainer itself you need to run two instances:\n\n* `default` to monitor all other tasks.\n* `dogfood` to monitor the `default` Complainer.\n\nYou'll need the following labels for the `default` instance:\n\n```yaml\nlabels:\n  complainer_dogfood_sentry_instances: default\n  complainer_dogfood_hipchat_instances: default\n```\n\nFor the `dogfood` instance you'll need to:\n\n* Add `-name=dogfood` command line flag.\n* Add `-default=false` command line flag.\n\nSince the `dogfood` Complainer ignores apps with not configured instances,\nit will ignore every failure except for the `default` instance failures.\n\nIf the `dogfood` instance fails, `default` reports it just like any other task.\n\nIf both instances fail at the same time, you get nothing.\n\n## Copyright\n\n* Copyright 2016 CloudFlare\n\n## License\n\nMIT\n",
  "permissions": {
    "read": true,
    "write": false,
    "admin": false
  },
  "media_types": [
    "application/vnd.docker.distribution.manifest.v1+prettyjws",
    "application/vnd.docker.container.image.v1+json"
  ],
  "content_types": [
    "image"
  ]
}