{
  "user": "xenserver",
  "name": "planex",
  "namespace": "xenserver",
  "repository_type": "image",
  "status": 1,
  "status_description": "active",
  "description": "Planex is a toolkit for building collections of interdependent RPMs.",
  "is_private": false,
  "is_automated": true,
  "can_edit": false,
  "star_count": 1,
  "pull_count": 2015,
  "last_updated": "2019-01-30T08:38:48.5753Z",
  "date_registered": "2016-07-26T12:31:25.61685Z",
  "collaborator_count": 0,
  "affiliation": null,
  "hub_user": "xenserver",
  "has_starred": false,
  "full_description": "# Planex [![Build Status](https://travis-ci.org/xenserver/planex.svg?branch=master)](https://travis-ci.org/xenserver/planex)\n\nPlanex is a toolkit for building medium-sized collections of RPM packages which may depend on each other.\nIt fills the gap between tools to build individual RPMs, such as `rpmbuild` and `mock`, and tools to build entire distributions, such as [koji](https://fedoraproject.org/wiki/Koji).\n\n## Installing Planex \n\nThe easiest way to install Planex is to use `pip` in a Python virtualenv.\n\nPlanex uses the Python bindings for `librpm`, which must be installed separately using the system package manager.\n```\n$ dnf install python2-rpm\n```\n\nIf you want to install Planex in a virtualenv, remember to pass the `--system-site-packages` so the `librpm` bindings are available in the virtualenv.\n\n```\n$ virtualenv venv --system-site-packages\nNew python executable in /tmp/venv/bin/python2\nAlso creating executable in /tmp/venv/bin/python\nInstalling setuptools, pip, wheel...done.\n$ source venv/bin/activate\n```\n\nClone the source, install the requirements and install Planex\n```\n$ git clone https://github.com/xenserver/planex\nCloning into 'planex'...\nremote: Counting objects: 11951, done.\nremote: Compressing objects: 100% (78/78), done.\nremote: Total 11951 (delta 143), reused 176 (delta 130), pack-reused 11743\nReceiving objects: 100% (11951/11951), 2.17 MiB | 931.00 KiB/s, done.\nResolving deltas: 100% (8368/8368), done.\n$ cd planex\n$ pip install -r requirements.txt\n...\n$ python setup.py install\n```\n\nFor development work, also install the test requirements and use `python setup.py develop`, which symlinks the code so you do not have to run `python setup.py install` after every edit.\n```\n$ pip install -r test-requirements.txt\n...\n$ python setup.py develop\n$ nosetests\n```\n\n## Design principles\n\n### Small, single purpose tools sequenced by make\n\nPlanex is a set of single-purpose tools designed to be run by a generic Makefile.\nWe arrived at this structure after previous experience with a monolithic Makefile which described the entire build process in make, and a monolithic Python system which described the entire build process in Python.\nPlanex is intended to be a mid-point between these two extremes.\n\n* We use make to figure out which files to rebuild and in what order.   All we need to do is generate the dependency graph, after which we can benefit from features such as incremental, parallel builds with no extra work.\n* Small, single purpose tools are easier to write, understand and maintain than monlithic scripts.  Although the Planex tools are intended to be run by make, they can easily be run by hand for testing and development. \n* Where make cannot understand part of our build process, we can use small tools to adapt it.   For instance, it is impossible to use a URL as a make prerequisite - make only understands files on disk - so we cannot write a rule which directly downloads a source tarball.   Instead, we have a tool (`planex-fetch`) which downloads a source defined in a spec file.   Make calls `planex-fetch`, passing it the spec and asking it to download the source tarball.   If the spec later changes, the source will be downloaded again.\n\n### Use standard tools in standard ways (the Stackoverflow test)\n\nUsing standard tools such as `rpmbuild`, `mock` and `make` means that when we run into trouble we can often find a solution by searching the web.\nThis is not possible with a custom monolithic build script.\nEven though our monolithic Makefile was based on a standard tool, it used complex and unusual features of make for which documentation and tutorials were hard to find.\n\n### Look like upstream\n\nPlanex is designed to build medium-sized collections of RPM packages which depend on each other and are maintained by a small number of people.\nDistribution builders such as Fedora have a slightly different problem - they have to build huge collections of packages, many of which do not depend on each other and which are maintained by a large number of maintainers.\nThis means that upstream tools are not always suitable for our purposes.\nHowever even when we have to write our own tools we should try to stay as close as possible to the upstream way of doing things so we can benefit from other upstream tools.\nExamples of this include fetching source tarballs instead of checking code out from Git, avoiding patching or re-writing spec files copied from upstream, and following `rpmbuild`'s working directory structure for the spec file repository.\n\n\n## Defining which packages to build\n\nThe main input to Planex is a repository containing RPM spec files, possibly a few source files and a small Makefile.\n```\n.\n├── Makefile\n├── SOURCES\n│   └── bar\n│       └── bar.service\n└── SPECS\n    ├── bar.spec\n    ├── bar.lnk\n    └── foo.spec\n```\n\nEach spec file describes the sources needed to build a package, any other packages which are required to build it, how to build it and how to pack the resulting files into a binary package.\nMost package sources are not kept with the spec files - instead `planex-fetch` downloads them from the URLs given in the spec files.\nThe source files could be static files on HTTP servers or tarballs produced dynamically by source control systems such as GitHub or BitBucket.\nA few sources can be kept in the spec file directory - these could be small temporary patches or resources such as SystemD service files which do not really belong anywhere else.\nThis approach is not suitable for large numbers of frequently-changing extra sources, such as patchqueues.\n\n\n## Overriding and augmenting packages\n\nIf a package relies on a source file which is not fully defined in its spec file, `planex-fetch` will not know where to get it.\nOne way around this problem is to change the spec file to contain a full URL for the source, however if the spec file is for an upstream package which we just re-build we may not want to change it.\nPlanex's solution to this is to add a 'link' file which defines additional sources to fetch and build into the package.\nThe link file can modify the sources listed in the spec in several ways:\n\n   * provide the URL of a source which does not have one\n   * override a source URL in the spec file - for instance to use a local mirror instead of a public repository\n   * provide the URL of a tarball of source files which are required by the package\n   * provide the URL of a tarball containing a patchqueue which will be added to any patches already defined by the spec file\n\nFor development, it is also possible to override a source listed in the spec with the contents of a Git repository.\nTo do this, create a link file with a `.pin` extension in the `PINS` directory.\nThis will cause `planex-fetch` to make a tarball archive of the repository and use it in place of the tarball specified in the spec file.\n",
  "permissions": {
    "read": true,
    "write": false,
    "admin": false
  },
  "media_types": [
    "application/vnd.docker.container.image.v1+json"
  ],
  "content_types": [
    "image"
  ]
}