{
  "user": "mogadanez",
  "name": "sqsd",
  "namespace": "mogadanez",
  "repository_type": "image",
  "status": 1,
  "status_description": "active",
  "description": "A simple alternative to the Amazon SQS Daemon (\"sqsd\") used on AWS Beanstalk worker tier instances",
  "is_private": false,
  "is_automated": true,
  "can_edit": false,
  "star_count": 2,
  "pull_count": 1502476,
  "last_updated": "2020-06-04T14:21:03.503257Z",
  "date_registered": "2017-03-27T13:39:00.778105Z",
  "collaborator_count": 0,
  "affiliation": null,
  "hub_user": "mogadanez",
  "has_starred": false,
  "full_description": "# SQSD\n\nA simple alternative to the Amazon SQS Daemon (\"sqsd\") used on AWS Beanstalk worker tier instances. Inspired by https://github.com/mozart-analytics/sqsd, rewriten for Node.js.\n\n## Architecture Diagram\n\n[AWS Beanstalk](http://aws.amazon.com/elasticbeanstalk/) provides a simple to use *Worker Environment Tier*\n([more info](http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/using-features-managing-env-tiers.html)) that greatly streamlines the deployment of passive worker microservices for background or async processing.\n\n![aws-eb-worker](http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/images/aeb-messageflow-worker.png)\n\n*(diagram by AWS - available [here](http://aws.amazon.com/elasticbeanstalk/))*\n\n## Description\n\nAs the included diagram portrays, in a common workflow, the worker instance will consume messages sent to a specified [Amazon SQS](http://aws.amazon.com/documentation/sqs/) from another service (e.g.: a web server or another worker). These messages will be received by the worker via POST requests. This eliminates the necessity of configuring a worker as an always-on service, as well as having to add code for reading and consuming messages from an AWS SQS queue. In other words, the worker is implemented as a standard RESTful API/Service that will react to a message sent to it at an specific endpoint via a POST request. This is an awesome approach by Amazon to microservices and [reactive design](www.reactivemanifesto.org/).\n\nThe conversion of the SQS message to a POST request is executed by what AWS calls the *\"SQS Daemon\"* or *\"Sqsd\"*. This is a simple daemon they pre-install in the worker tier instances that is constantly monitoring an specific AWS SQS queue (provided by configuration) for new messages. When new messages arrive, it constructs a `POST` request and sends it to a specific endpoint (also provided via configuration). If the endpoint consumes it without errors and returns a `2**` HTTP Code in its response, the *\"Sqsd\"* deletes the message from the queue to signal that its consumption was successful.\n\nHowever, even though this approach is extremely powerful, Amazon does not provide the code of this daemon as open source. Therefore, we have reproduced its behavior by creating our own version of the *\"Sqsd\"* free for everyone to use. Moreover, we have provided lots of customization and configuration properties so that it can be molded to your specific use cases.\n\nBut even more important! **We have \"dockerized\" it** so that you can use it as a Docker container along your worker (even link it to it). This makes this microserviced worker approach even more powerful as it can be easily pre-configured and pre-packaged to be deployed automatically along your services using your favorite Docker orchestration frameworks or even the recently announced [Amazon EC2 Container Service](http://aws.amazon.com/ecs/).\n\nFollowing are detailed instructions of configuration and usage with and without Docker. Any changes, suggestions or Forks are welcome!\n\n## Technologies / Environments Used\n- Node.js 4+\n- AWS Node SDK 2.2.26+\n\n## Usage\n\n### Running / Executing\n\n#### Local development\nTo execute the program, clone down the repository, navigate to it with a terminal and run `npm start`\n\n#### As global command-line tool\n\nTo run as global command-line tool, you can either install globally from NPM or clone down the repository and run `npm link`\nto link it to your global `node_modules` directory.\n\n\n```bash\n# Global Install\n:~: $ npm install sqsd -g\n:~: $ sqsd --help\n```\n\n```bash\n# Link from terminal\n:~: $ cd /Workspace/sqsd\n:~/Workspace/sqsd: $ npm link\n:~/Workspace/sqsd: $ sqsd --help\n```\n\n### Configuration\nThere are 2 ways to configure the `sqsd`'s properties: Environment Variables or command-line arguments. You must set one of the two options.\n\n#### Using Environment Variables\nEnvironment Variables are loaded from an `.env` file using the [dotenv](https://www.npmjs.com/package/dotenv) module.\n\nWhen the program is run, it will automatically look for an `.env` file in the directory the program is executed from.\n\nIf you want to specify your own file, use the `--env` command-line argument\n\n```bash\n:~: $ sqsd --env path/to/env/file\n```\n\n#### Using Command-Line arguments\nYou can also specify properties using command-line flags. See the _Options_ table below for the full list of command-line arguments.\n\nRun the program with the `--help` flag to see the full list of accepted arguments.\n\n```bash\n:~: $ sqsd --help\n```\n\n#### Options\n\n| **Command-Line Argument**  |             **Environmet Variable**              |    **Default**     | **Required** |                                                   **Description**                                                    |\n|---|--------------------------------------------------|--------------------|--------------|----------------------------------------------------------------------------------------------------------------------|\n|  --access-key-id | `AWS_ACCESS_KEY_ID`                              | -                  | no           | Your AWS Access Key.                                                                                                 |\n| --secret-access-key  | `AWS_SECRET_ACCESS_KEY`                          | -                  | no           | Your AWS secret access secret.                                                                                       |\n|  -r, --region | `SQSD_QUEUE_REGION_NAME` or `AWS_DEFAULT_REGION` | `us-east-1`        | no           | The region name of the AWS SQS queue                                                                                 |\n| -q, --queue-url  | `SQSD_QUEUE_URL`                                 | -                  | no          | Your queue URL.                                                                                                      |\n| --queue-name  | `SQSD_QUEUE_NAME`                                 | -                  | no          | The name of the queue. Fetch from queue URL if blank                                                                                                      |\n| --endpoint-url  | `SQSD_ENDPOINT_URL`                                 | -                  | no          | Your endpoint URL if you using a fake sqs.                                                                                                      |\n| --ssl-enabled  | `SQSD_SSL_ENABLED`                                 | `true`                  | no          | To enable ssl or not.                                                                                                      |\n|  -m, --max-messages | `SQSD_MAX_MESSAGES_PER_REQUEST`                  | `10` (max: `10`)   | no           | Max number of messages to retrieve per request.                                                                      |\n|  -d, --daemonized | `SQSD_RUN_DAEMONIZED`                            | `0`                | no           | Whether to continue running with empty queue (0,no,false is no, 1,yes,true is yes)                                   |\n|  -s, --sleep | `SQSD_SLEEP_SECONDS`                             | `0`                | no           | Number of seconds to wait after polling empty queue when daemonized                                                  |\n|  --wait-time | `SQSD_WAIT_TIME_SECONDS`                         | `20` (max: `20`)   | no           | Long polling wait time when querying the queue.                                                                      |\n| -w, --web-hook | `SQSD_WORKER_HTTP_URL`                           | -                  | yes          | Web url address to your service.                                                                                     |\n| --content-type | `SQSD_WORKER_HTTP_REQUEST_CONTENT_TYPE`          | `application/json` | no           | Message MIME Type.                                                                                                   |\n| --concurrency  | `SQSD_WORKER_CONCURRENCY`                        | 3                  | no           | Number of concurrent http request to worker service                                                                  |\n|  -t, --timeout | `SQSD_WORKER_TIMEOUT`                            | 60000              | no           | Timeout for waiting response from worker, ms                                                                         |\n|  --worker-health-url | `SQSD_WORKER_HEALTH_URL`                         | -                  | no           | Url for checking that worker is running, useful when running in linked containers and worker needs some time to  up. |\n|  --worker-health-wait-time | `SQSD_WORKER_HEALTH_WAIT_TIME`                   | 10000              | no           | Timeout for waiting while worker become  health, ms                                                                  |\n\n\n#### Using Docker (with service/worker hosted outside this container)\nUse this run configuration when your worker is running in another container or in a remote server.\n\n    cd /your/sqsd/local/path\n    docker build -t someImageName .\n    docker run -e -e SQSD_WORKER_HTTP_URL=http://someRemoteHost/someRemotePath someImageName\n\n**Remember that if you are running your worker on your Docker host's instance, you cannot use `localhost` as the worker host path since the `localhost` in this case will be the container's address, not your host's. Use linked containers instead**\n\n#### Running with fake_sqs\n\nYou may want to run fake_sqs for local development. To do this gem install fake_sqs and run it with command:\n`fake_sqs`\n\nYou will then need to configure sqsd to communicate with the fake sqs server.\nHere is a sample .env file below.\n\nSQSD_QUEUE_NAME=queue_name\nSQSD_WORKER_HTTP_URL=http://127.0.0.1\nSQSD_ENDPOINT_URL=http://127.0.0.1:4568\nSQSD_SSL_ENABLED=false\nAWS_ACCESS_KEY_ID=meh\nAWS_SECRET_ACCESS_KEY=meh\n\nThe access key and the secret key must not be blank.\n",
  "permissions": {
    "read": true,
    "write": false,
    "admin": false
  },
  "media_types": [
    "application/vnd.docker.container.image.v1+json"
  ],
  "content_types": [
    "image"
  ]
}