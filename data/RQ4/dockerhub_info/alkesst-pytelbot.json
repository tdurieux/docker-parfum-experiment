{
  "user": "alkesst",
  "name": "pytelbot",
  "namespace": "alkesst",
  "repository_type": "image",
  "status": 1,
  "status_description": "active",
  "description": "automate-build for pytelbot environments ",
  "is_private": false,
  "is_automated": true,
  "can_edit": false,
  "star_count": 1,
  "pull_count": 245,
  "last_updated": "2020-02-15T12:01:10.419613Z",
  "date_registered": "2018-08-16T16:05:45.416839Z",
  "collaborator_count": 0,
  "affiliation": null,
  "hub_user": "alkesst",
  "has_starred": false,
  "full_description": "# PyTel-Bot\n###### A playful telegram bot.\n## Requirements\nPython3 or Docker. Not both!\n\n## Introduction\nA telegram bot that interacts with the users in telegram groups. It sends photos, videos \nand stickers.\n\n##### _TOKENS_\nThe tokens are saved using environment variables:\n\n| VARIABLE | DESCRIPTION |\n|----------|--------------|\n| `PYTEL_TELEGRAM` | Telegram API key |\n| `PYTEL_CONSUMER_KEY` | Twitter Consumer Key |\n| `PYTEL_CONSUMER_SECRET` | Twitter Consumer Secret |\n| `PYTEL_ACCESS_TOKEN` | Twitter's user Access Token |\n| `PYTEL_ACCES_TOKEN_SECRET` | Twitter's user Access Token Secret |\n| `PYTEL_PATH` | Optional variable that points to where the files and database are stored |\n| `WEBHOOK_PATH_PREFIX` | Defines the public url to enable the webhook mode |\n\n### Abstract\nTo enable the webhook mode, the environment variable `WEBHOOK_URL` must be defined with the public URL (it supposes that there is a reverse proxy that enables HTTPS for the public part). By default, expects to receive all the requests without any path prefix, but you can define one using the env var `WEBHOOK_PATH_PREFIX`. Both env vars can contain the token `{token}` that will be replaced with the real token if needed.\n\n### Example 1\n - `WEBHOOK_URL`: `https://casita.melchor9000.me/pytelbot`\n - `WEBHOOK_PATH_PREFIX`: `pytelbot`\n\nThis will receive updates to https://casita.melchor9000.me/pytelbot, where the reverse proxy will send them to the bot under the path `/pytelbot`.\n\n### Example 2\n - `WEBHOOK_URL`: `https://casita.melchor9000.me/pytelbot`\n - `WEBHOOK_PATH_PREFIX`: ` ` (empty string)\n\nThis will receive updates to https://casita.melchor9000.me/pytelbot, where the reverse proxy will send them to the bot under the path `/` (removing the `pytelbot` path prefix).\n\n### Example 3\n - `WEBHOOK_URL`: `https://casita.melchor9000.me/bots/{token}`\n - `WEBHOOK_PATH_PREFIX`: `{token}` (empty string)\n\nThis will receive updates to https://casita.melchor9000.me/bots/<TOKEN> (where `<TOKEN>` is the bot token), where the reverse proxy will send them to the bot under the path `/<TOKEN>` (removing the `bots` path prefix and where `<TOKEN>` is the bot token).\n\nMore information: https://github.com/python-telegram-bot/python-telegram-bot/wiki/Webhooks#using-nginx-with-one-domainport-for-all-bots\n\n\n## AUTOMATE THE BOT\n\n### Using Docker\nBefore creating the image with docker, we need to create the .env with the next content:\n```\nPYTEL_TELEGRAM=*REPLACE WITH YOUR TOKEN*\nPYTEL_CONSUMER_KEY=*REPLACE WITH YOUR TOKEN*\nPYTEL_CONSUMER_SECRET=*REPLACE WITH YOUR TOKEN*\nPYTEL_ACCESS_TOKEN=*REPLACE WITH YOUR TOKEN*\nPYTEL_ACCES_TOKEN_SECRET=*REPLACE WITH YOUR TOKEN*\nPYTEL_PATH=*REPLACE WITH YOUR CUSTOM PATH*\n```\n\nBy default, PYTEL_PATH is equals to ../pytel_stuff\nAll the images you want to use will need to be in the docker image.\n\nFirst create the image with `docker image build -t *tag_name* .` and will create an image from the Dockerfile.\n\nOnce created your image, just run with `docker run -it --rm -v *pytel_files_path*:/pytel_stuff --env-file .env *tag_name*`.\n\n### Using Services\n#### Script:\n\nTo run the bot when turning on the raspberry we must create a service.\n\nFirst of all we need to create a script that pulls the changes from git, and then, runs the bot\n```sh\n#!/usr/bin/env bash\ncd /home/pi/Documentos/PyTel-Bot # Path to where the source code is\n\n#  ... SET THE TOKENS VARIABLES HERE ...\nexport PYTEL_TELEGRAM=*REPLACE WITH YOUR TOKEN*\nexport PYTEL_CONSUMER_KEY=*REPLACE WITH YOUR TOKEN*\nexport PYTEL_CONSUMER_SECRET=*REPLACE WITH YOUR TOKEN*\nexport PYTEL_ACCESS_TOKEN=*REPLACE WITH YOUR TOKEN*\nexport PYTEL_ACCES_TOKEN_SECRET=*REPLACE WITH YOUR TOKEN*\nexport PYTEL_PATH=*REPLACE WITH YOUR CUSTOM PATH*\n\nSTATE=$(ping -q -w 1 -c 1 `ip r | grep default | cut -d ' ' -f 3` > /dev/null && echo ok || echo error)\nwhile [  $STATE == \"error\" ]; do\n    #do a ping and check that its not a default message or change to grep for something else\n    STATE=$(ping -q -w 1 -c 1 `ip r | grep default | cut -d ' ' -f 3` > /dev/null && echo ok || echo error)\n\n    #sleep for 2 seconds and try again\n    sleep 2\ndone\necho \"Pulling PyTel-Bot...\"\necho\ngit pull\necho\necho \"Pull done...\"\necho \"Initializating PyTel-Bot...\"\npython3 main.py\n```\n\n\nIt is requiered to use the following code, because the service will start immediatly when the rpi turns on, so, we need to\ncheck if there is internet conection before trying to pull from git.\n```sh\nSTATE=$(ping -q -w 1 -c 1 `ip r | grep default | cut -d ' ' -f 3` > /dev/null && echo ok || echo error)\nwhile [  $STATE == \"error\" ]; do\n    #do a ping and check that its not a default message or change to grep for something else\n    STATE=$(ping -q -w 1 -c 1 `ip r | grep default | cut -d ' ' -f 3` > /dev/null && echo ok || echo error)\n\n    #sleep for 2 seconds and try again\n    sleep 2\ndone\n```\n\n#### Service:\n\nMade the script, now you need to create a .service file with the following code:\n```\n[Unit]\nDescription=PyTwe-Bot\n\n[Service]\nExecStart=/home/pi/rpi_pytwe_script.sh\nUser=pi\nGroup=pi\n\n[Install]\nWantedBy=multi-user.target\n```\n\n#### Enabling service and moving to the path:\n\nWhen you have your .service file, you need to move the file into /etc/systemd/system/ and use the following command:\n```sh\nsudo systemctl enable pytwe.service\n```\n\nSpoiler: you will need to move first your service where you want and then use *__sudo mv pytwe_service /etc/systemd/system__*\n\nDon't forget this:\n```sh\nchmod a+x rpi_pytwe_script.sh\n```\n\nAnd now your bot will run when the rpi powers on.\n",
  "permissions": {
    "read": true,
    "write": false,
    "admin": false
  },
  "media_types": [
    "application/vnd.docker.container.image.v1+json"
  ],
  "content_types": [
    "image"
  ]
}