{
  "user": "kocircuit",
  "name": "kocircuit",
  "namespace": "kocircuit",
  "repository_type": "image",
  "status": 1,
  "status_description": "active",
  "description": "Ko language wrapped in a container",
  "is_private": false,
  "is_automated": true,
  "can_edit": false,
  "star_count": 0,
  "pull_count": 51,
  "last_updated": "2018-10-08T13:07:20.488848Z",
  "date_registered": "2018-10-05T10:47:53.107605Z",
  "collaborator_count": 0,
  "affiliation": null,
  "hub_user": "kocircuit",
  "has_starred": false,
  "full_description": "\n[![Build Status](https://travis-ci.org/kocircuit/kocircuit.svg?branch=master)](https://travis-ci.org/kocircuit/kocircuit)\n\n# Ko\n\n## Experimental\n\nThe Ko language, library & tools are in active development, so do expect things to change.\n\n## Introduction\n\nKo is a concurrent, immutable, functional language.\n\nKo is both generic (function arguments and return values do not declare types)\nand type-safe (a new static-type inference algorithm ensures deep static type\nsafety everywhere).\n\nKo is built on top of the Go runtime, in order to benefit from Go's rich ecosystem of\nintegrations with industrial technologies.\n\nExisting Go libraries and clients can be \"exposed\" in Ko with little relative effort.\nProtocol definitions, like Protocol Buffers or OpenAPI, can also be exposed in Ko\nusing simple code-generation.\n\n## Getting started\n\nTo install the Ko interpreter, run:\n\n```bash\ngo get -u github.com/kocircuit/kocircuit/lang/ko\n```\n\n## Learning Ko\n\nPerhaps the best way to learn the language is by reading sequentially through\nour [step-by-step lessons](https://github.com/kocircuit/kocircuit/tree/master/lessons).\n\n## Design, specifications and theory\n\nAn initial formal specification of the language (its underlying computational model,\nits syntax and its type system) can be found in the evolving [Ko Handbook](https://kocircuit.github.io/).\n\n## Why use Ko?\n\nThere are four main aspects of Ko which make it an interesting proposal:\n\n* __Language.__ Ko is generic and at the same time entirely type-safe.\nGenericity means that functions do not have to declare argument and return \nvalue types, which makes them highly reusable. At the same time, when entire\nKo programs are compiled against external protocols, services or types,\nthey are fully-verified for type compliance.\n\n* __Types.__ Ko uses a type-system which is the common denominator of\nindustry protocol standards, like Protocol Buffers, Thrift, OpenAPI, and so on.\nThese type systems are captured by structures, sequences (repeated types), primitive types,\noptional types and map types. This type system is already familiar to most programmers.\n\n* __Architecture__. The forthcoming Ko compiler compiles Ko programs to\na [high-level intermediate representation](https://github.com/kocircuit/kocircuit/blob/master/bootstrap/asm/proto/asm.proto) (IR) which can be used to code-generate an actual implementation in\nany language (e.g. Go, Java, C++, etc.) with relatively little effort.\nThe IR produced by the Ko compiler is a collection of functions in SSA form,\nwith deep [type annotations](https://github.com/kocircuit/kocircuit/blob/master/bootstrap/types/proto/types.proto) everywhere.\n\n* __Integrations__. The Ko interpreter, being built on top of Go, can\ngain access to any technology available in Go by binding dynamically to it\nwith little effort. This includes libraries and clients written in Go,\nas well as standards like Protocol Buffers and OpenAPI which\nhave bindings for Go. The forthcoming Ko compiler, being a code-generating technology,\ncan benefit from integrations with any target language, as described in\nthe architecture bullet (above).\n",
  "permissions": {
    "read": true,
    "write": false,
    "admin": false
  },
  "media_types": [
    "application/vnd.docker.container.image.v1+json"
  ],
  "content_types": [
    "image"
  ]
}