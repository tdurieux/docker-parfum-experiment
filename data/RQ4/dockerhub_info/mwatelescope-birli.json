{
  "user": "mwatelescope",
  "name": "birli",
  "namespace": "mwatelescope",
  "repository_type": "image",
  "status": 1,
  "status_description": "active",
  "description": "A Rust library for common preprocessing tasks performed by the Murchison Widefield Array (MWA)",
  "is_private": false,
  "is_automated": false,
  "can_edit": false,
  "star_count": 0,
  "pull_count": 4240,
  "last_updated": "2022-11-22T03:59:12.334509Z",
  "date_registered": "2021-07-21T08:51:17.51952Z",
  "collaborator_count": 0,
  "affiliation": null,
  "hub_user": "derwentx",
  "has_starred": false,
  "full_description": "# Birli\n\n<!-- markdownlint-disable MD033 -->\n<div class=\"bg-gray-dark\" align=\"center\" style=\"background-color:#24292e\">\n<img src=\"img/birli.png\" height=\"200px\" alt=\"Birli logo\">\n<br/>\n<a href=\"https://github.com/MWATelescope/Birli/actions/workflows/linux_test.yml\">\n  <img src=\"https://github.com/MWATelescope/Birli/actions/workflows/linux_test.yml/badge.svg\" alt=\"Linux Tests\"></a>\n<a href=\"https://crates.io/crates/birli\">\n  <img alt=\"Crates.io\" src=\"https://img.shields.io/crates/d/birli?label=crates.io%20%E2%AC%87%EF%B8%8F\"></a>\n<a href=\"https://docs.rs/crate/birli/\">\n  <img src=\"https://docs.rs/birli/badge.svg\" alt=\"codecov\"></a>\n<a href=\"https://codecov.io/gh/MWATelescope/Birli\">\n  <img src=\"https://codecov.io/gh/MWATelescope/Birli/branch/main/graph/badge.svg?token=PK2KYEZOW9\" alt=\"codecov\"></a>\n<a href=\"https://rust-reportcard.xuri.me/report/github.com/mwatelescope/birli\">\n  <img src=\"https://rust-reportcard.xuri.me/badge/github.com/mwatelescope/birli\" alt=\"rust-reportcard\"></a>\n<a href=\"https://github.com/MWATelescope/Birli/blob/main/LICENSE\">\n  <img alt=\"Crates.io\" src=\"https://img.shields.io/crates/l/birli\"></a>\n\n</div>\n\nA Rust library for common preprocessing tasks performed in the data pipeline of the Murchison\nWidefield Array (MWA), located on the land of the Wajarri Yamatji people in Murchison Shire, Western\nAustralia.\n\nBirli reads MWA correlator visibilities in the gpufits file format using\n[mwalib](https://github.com/MWATelescope/mwalib), which supports the existing \"legacy\" MWA\ncorrelator, as well as the in-development \"MWAX\" correlator.\n\n**Birli** is the Wajarri word for lightning, a common cause of outages at the MWA, and a great\ndescriptor for the speed which this library intends to deliver.\n\n## Installation\n\n### Prerequisites\n\n- A Rust compiler with a version >= 1.63.0 - <https://www.rust-lang.org/tools/install>\n- [AOFlagger](https://gitlab.com/aroffringa/aoflagger) >= 3.0\n  (Ubuntu > 21.04: apt install aoflagger-dev)\n- [CFitsIO](https://heasarc.gsfc.nasa.gov/fitsio/) >= 3.49\n  (Ubuntu > 20.10: apt install libcfitsio-dev)\n- [LibERFA](https://github.com/liberfa/erfa) >= 1.7.1\n  (Ubuntu > 20.04: apt install liberfa-dev)\n\nfor OS-specific instructions, check out the [linux](https://github.com/MWATelescope/Birli/blob/main/.github/workflows/linux_test.yml) CI Script; the [Makefile.toml](https://github.com/MWATelescope/Birli/blob/main/Makefile.toml); and the [Dockerfile](https://github.com/MWATelescope/Birli/blob/main/Dockerfile) as these are tested regularly. The instructions below may be updated less frequently, but are better documented.\n\n### (Debian/Ubuntu) Linux Setup\n\n```bash\n# Prerequisites for rustup, cargo and cargo-make\nsudo apt install -y gcc libssl-dev pkg-config curl unzip wget\n# Run the Rustup install script, profile=default, toolchain=stable\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs -sSf | sh -s -- -y\n# Cargo make uses Makefile.toml to automate development tasks\ncargo install --force cargo-make\n# Use multiple cores when compiling C/C++ libraries\nexport MAKEFLAGS=\"-j $MAKEFLAGS\"\n# Install prerequisite C/C++ libraries\ncargo make install_deps\n# Ensure that rust can find the C/C++ libraries.\n# AOFlagger and CFitsIO default to /usr/local/lib,\n# however packages installed with apt (LibERFA) end up in /usr/lib/x86_64-linux-gnu/,\n# so we need both.\nexport LD_LIBRARY_PATH=\"/usr/local/lib/:/usr/lib/x86_64-linux-gnu/\"\n```\n\n### Other Operating Systems\n\nUnfortunately most of the prerequisites aren't available on Windows. However, WSL is great, and there is a docker image! You could use VSCode remote for WSL or Docker. Your best best is Ubuntu LTS\n\nPreviously macOS was supported, however this has ben dropped due to issues with the [aoflagger Homebrew tap](https://github.com/MWATelescope/homebrew-tap/blob/main/Formula/aoflagger.rb). Any help here would be welcome.\n\n### Installing the binary\n\n```bash\ncargo --features=aoflagger install --path .\n```\n\nThis creates a `birli` binary with the `aoflagger` feature enabled in `$HOME/.cargo/bin`\n\n## Troubleshooting\n\n### Test suite\n\nHaving issues with Birli? run the test suite to narrow down your issue.\n\n```bash\ncargo test\n```\n\n### Dependencies\n\nExperiencing segfaults? I can guarantee it's because of one of the C library dependencies.\nMake sure you have the right versions of all the libraries. These are specified in [Prerequisites](#Prerequisites).\n\nGet library versions on linux with:\n\n```bash\npkg-config --modversion cfitsio\npkg-config --modversion erfa\naoflagger --version\n```\n\nIf you have something like CASA installed from apt, it's going to put an\nancient cfitsio library version in `/usr/lib/x86_64-linux-gnu/`, to get around\nthis, you must export `LD_LIBRARY_PATH=/usr/local/lib/` in the shell so that Birli can find the correct library version.\n\n### Logging\n\nYou can enable additional logging on individual Rust modules by setting the `RUST_LOG` environment variable. For example:\n\n```bash\nRUST_LOG=trace birli ... # set log level to trace for all module (including dependencies)\nRUST_LOG=birli=debug birli ... # set log level to debug for birli only\nRUST_LOG=birli::io=error birli ... # only show warnings for birli's io module\n```\n\nFor more examples, see the [env_logger docs](https://docs.rs/env_logger/latest/env_logger/)\n\nThe default log level in `info`\n\n### Docker\n\nCouldn't get it working on your environment? You can always run Birli in Docker\n\n```bash\ndocker run mwatelescope/birli:latest -h\n```\n\nWant to open a shell within a fully provisioned Birli development environment? Easy!\n\n```bash\ndocker run -it --entrypoint /bin/bash --volume $PWD:/app mwatelescope/birli:latest\n```\n\nNote: This mounts the current directory to `/app` in the Docker image, meaning both of these systems share the same\n`target` folder. so if your host system is a different\narchitecture than Docker, you may need to `cargo clean` each time you switch between these environments. You may also want to temporarily disable any linters or language servers that use\n\n### Singularity on HPC\n\n```bash\n# - load the singularity module\nmodule load singularity\n# - cd into your preferred sif file location, e.g. /pawsey/mwa/singularity/birli\n# - create a .sif file from the latest mwatelescope/birli docker image\nsingularity pull --dir . docker://mwatelescope/birli:latest\n# - run birli within the singularity image\nsingularity exec  /pawsey/mwa/singularity/birli/birli_latest.sif /app/target/release/birli ${YOUR_BIRLI_ARGS}\n```\n\nsee this gist for an example of [a Garrawarla SLURM job using Birli](https://gist.github.com/d3v-null/9ce233114ebb16dc18072303845257e5)\n\n### Singularity on HPC (debug mode)\n\nThis will give you much more information about any problem you're having with Birli, however the\ndebug build is not optimised, and is much slower.\n\n```bash\n# - request an interactive HPC session\nsalloc --partition workq --time 1:00:00 --nodes 1 -c 38 --mem=350G\n# - load the singularity module\nmodule load singularity\n# - cd into your preferred sif file location, e.g. /pawsey/mwa/singularity/birli\n# - create a .sif file from the latest mwatelescope/birli docker image\nsingularity pull --dir . docker://mwatelescope/birli:debug\n# - run birli within the singularity image\nsingularity exec  /pawsey/mwa/singularity/birli/birli_debug.sif /bin/bash\n```\n\nthen within this shell\n\n```bash\n# - enable lots of logs\nexport RUST_LOG=trace\n# - run birli in debug mode with GDB\ngdb --args /app/target/debug/birli ${YOUR_BIRLI_ARGS}\n# > run\n```\n\n## Usage\n\n`birli -h`\n\n```txt\nUSAGE:\n    birli [OPTIONS] --metafits <PATH> <PATHS>...\n\nOPTIONS:\n        --apply-di-cal <PATH>        Apply DI calibration solutions before averaging\n        --dry-run                    Just print the summary and exit\n        --emulate-cotter             Use Cotter's array position, not MWAlib's\n    -h, --help                       Print help information\n        --no-draw-progress           do not show progress bars\n        --phase-centre <RA> <DEC>    Override Phase centre from metafits (degrees)\n        --pointing-centre            Use pointing instead phase centre\n    -V, --version                    Print version information\n\nINPUT:\n    -m, --metafits <PATH>    Metadata file for the observation\n    <PATHS>...           GPUBox files to process\n\nSELECTION:\n        --no-sel-autos            [WIP] Deselect autocorrelations\n        --no-sel-flagged-ants     [WIP] Deselect flagged antennas\n        --sel-ants <ANTS>...      [WIP] Antenna to select\n        --sel-time <MIN> <MAX>    Timestep index range (inclusive) to select\n\nRESOURCE LIMITS:\n        --max-memory <GIBIBYTES>    [WIP] Estimate --time-chunk with <GIBIBYTES> GiB each chunk.\n        --time-chunk <STEPS>        [WIP] Process observation in chunks of <STEPS> timesteps.\n\nFLAGGING:\n        --flag-antennas <ANTS>...         [WIP] Flag antenna indices\n        --flag-autos                      [WIP] Flag auto correlations\n        --flag-coarse-chans <CHANS>...    [WIP] Flag additional coarse chan indices\n        --flag-dc                         Force flagging of DC centre chans\n        --flag-edge-chans <COUNT>         Flag <COUNT> fine chans on the ends of each coarse\n        --flag-edge-width <KHZ>           Flag bandwidth [kHz] at the ends of each coarse chan\n        --flag-end <SECONDS>              Flag seconds before the last provided time\n        --flag-end-steps <COUNT>          Flag <COUNT> steps before the last provided\n        --flag-fine-chans <CHANS>...      Flag fine chan indices in each coarse chan\n        --flag-init <SECONDS>             Flag <SECONDS> after first common time (quack time)\n        --flag-init-steps <COUNT>         Flag <COUNT> steps after first common time\n        --flag-times <STEPS>...           Flag additional time steps\n        --no-flag-dc                      Do not flag DC centre chans\n        --no-flag-metafits                [WIP] Ignore antenna flags in metafits\n\nCORRECTION:\n        --no-cable-delay           Do not perform cable length corrections\n        --no-digital-gains         Do not perform digital gains corrections\n        --no-geometric-delay       Do not perform geometric corrections\n        --passband-gains <TYPE>    Type of PFB passband filter gains correction to apply [default:\n                                   jake] [possible values: none, cotter, jake]\n\nAVERAGING:\n        --avg-freq-factor <FACTOR>    Average <FACTOR> channels per averaged channel\n        --avg-freq-res <KHZ>          Frequency resolution of averaged data\n        --avg-time-factor <FACTOR>    Average <FACTOR> timesteps per averaged timestep\n        --avg-time-res <SECONDS>      Time resolution of averaged data\n\nOUTPUT:\n    -f, --flag-template <TEMPLATE>    The template used to name flag files. Percents are substituted\n                                      for the zero-prefixed GPUBox ID, which can be up to 3\n                                      characters long. Example: FlagFile%%%.mwaf\n    -M, --ms-out <PATH>               Path for measurement set output\n    -u, --uvfits-out <PATH>           Path for uvfits output\n\nAOFLAGGER:\n        --aoflagger-strategy <PATH>    Strategy to use for RFI Flagging\n        --no-rfi                       Do not perform RFI Flagging with aoflagger\n```\n\nNote: the aoflagged options are only available when the aoflagger feature is enabled.\n\nOperations are performed in the order described by the following sections.\n\n### Cable Delay Corrections\n\nCable delay correction involves adjusting visibility phases to correct for the differences in electrical length of the cable between each tile and it's receiver.\n\nLegacy MWA correlator observations do not typically have cable delays applied, however MWAX observations can. The [`CABLEDEL`](https://wiki.mwatelescope.org/display/MP/MWAX+Metafits+Changes) key in the metafits describes what geometric delays have been applied.\n\nBy default, Birli will apply cable length corrections. You can use `--no-cable-delay` to disable this.\n\nA baseline's cable lengths are determined by the difference between a baseline's rfInput electrical lengths, as specified the the `TILEDATA` HDU of the metafits. Complex visibilities are phase-shifted by an angle determined by the electrical length, and the channel's frequency.\n\n```rust\nlet angle = -2.0 * PI * electrical_length_m * freq_hz / SPEED_OF_LIGHT_IN_VACUUM_M_PER_S;\n```\n\n### Digital Gain Corrections\n\nEach input in the raw data is scaled by a factor for each coarse channel. This is defined in the metafits primary hdu in the Gains column. Birli corrects these digital gains by default, you can disable this with `--no-digital-gains`\n\n### Coarse PFB Passband Corrections\n\nAdjust each coarse channel within a fine channel to correct for the shape of the pfb passband curve. Birli will apply the gains defined in the mwa wiki [on pfb gains](https://wiki.mwatelescope.org/display/MP/RRI+Receiver+PFB+Filter)   by default. They can be disabled with `--passband-gains none`. Another option is to emulate Cotter's `_sb128ChannelSubbandValue2014FromMemo` from `subbandpassband.cpp`, sometimes referred to as Levine Gains. Since these gains were computed at the base legacy correlator resolution of 10KHz, they will not work on all MWAX resolutions. Cotter's implementation of this functionality is slightly different, in that it does not include the channel from the gains when scaling. It's not clear if this is a bug or a feature.\n\nWhen applying pfb gains to an observation that is not at the same resolution as the gains, the gains need to be averaged to fit the data, and the exact details of this averaging depends on the correlator type. For more dtails, see the mwa wiki on [averaging fine channels](https://wiki.mwatelescope.org/display/MP/MWA+Fine+Channel+Centre+Frequencies)\n\n### RFI Flagging.\n\nBy default, Birli will flag the data using the default MWA strategy in AOFlagger. You can use the\n`--no-rfi` option to disable this, or the `--aoflagger-strategy` option to proived your own strategy\nfile.\n\n### Geometric Delay Corrections (AKA Phase Tracking)\n\nGeometric correction involves adjusting visibility phases to correct for the differences in distance that light from the phase center has to travel to reach each tile.\n\nLegacy MWA correlator observations are not typically phase tracked, however MWAX observations can have phase tracking applied. The [`GEODEL`](https://wiki.mwatelescope.org/display/MP/MWAX+Metafits+Changes) card in the metafits describes what geometric delays have been applied.\n\nBy default, Birli will apply geometric corrections at the phase center if they have not already been applied. It determines the observations phase center from the [`RAPHASE` and `DECPHASE`](https://wiki.mwatelescope.org/display/MP/Metafits+files) cards in the metafits. If these are not available, the pointing center cards ([`RA` and `DEC`](https://wiki.mwatelescope.org/display/MP/Metafits+files)) from the metafits are used. You can use `--no-geometric-delay` to disable geometric corrections, as well as the `--phase-centre` and `--pointing-centre` options to override the phase center.\n\nA baseline's geometric length is determined by the w component of it's UVW fourier-space vector, after applying precession and nutation to it's tiles' positions and the phase center to the J2000 epoch, accounting for stellar aberration. Complex visibilities are phase-shifted by an angle determined by the w-component, and the channel's frequency.\n\n```rust\nlet angle = -2.0 * PI * uvw.w * freq_hz / SPEED_OF_LIGHT_IN_VACUUM_M_PER_S;\n```\n\n### Calibration\n\nBirli can apply direction independent calibration solutions using the `--apply-di-cal` flag. Solutions are applied before averaging. The number of channels in the un-averaged visibilities must be an integer multiple of the number of channels in the calibration solutions file. Unlike Cotter, Birli will handle calibration solutions where a `NaN` value is present by flagging any visibilities where a NaN is present.\n\nCurrently, only the MWA aocal format (.bin), historically generated by the `calibrate` binary in the `mwa-reduce` package is supported. This format is described [here](https://github.com/MWATelescope/cotter/blob/master/solutionfile.h), however due to the ambiguous definition of the startTime and endTime fields, their values are ignored and so only a single timeblock of solutions can be applied.\n\n### Cotter Emulation\n\nThe `--emulate-cotter` flag ensures that outputs match Cotter as much as possible. You should only use this flag if you need to perform a direct comparison with Cotter.\n\nBy default, Birli will use the MWA array position from MWALib in order to calculate UVWs and geometric corrections. This is more accurate than the one that Cotter uses, and is the main source of error when doing direct comparisons.\n\nThis flag is used as part of the tests in `src/main.rs` to validate that Birli's output matches that of Cotter to within an acceptable margin.\n\n### Averaging\n\nTo average the data in time or frequency by a given whole number factor, you can provide the `--avg-time-factor`\nor `--avg-freq-factor` options. This can also be achieved with the `--avg-time-res` and\n`--avg-freq-res` options which take a duration \\[seconds\\] or ammount of bandwidth \\[kHz\\]\nrespectively. This second group of options will choose the closest whole number averaging factor\nbased on the resolution of the input data.\n\n### Output\n\nBirli can output visibility data to uvfits or measurement set with `--ms-out` (`-M`) or\n`--uvfits-out` (`-u`). It can also output flags for each coarse channel in .mwaf format with\n`--flag-template` (`-f`), where the `%` characters in the template argument are replaced with\nthe same zero-prefixed coarse channel identifiers that are used to identify the coarse channel\nGPUBox files that the coarse channel data came from. For legacy data, use two percentage characters,\nsince the coarse channel identifier is the GPUBox number. However, for MWAX data, the coarse channel\nidentifier is the channel number, which needs three digits.\n\nExample: automatically determine flag template\n\n```bash\nexport flag_template='Flagfile%%.mwaf'\nif [ ${obsid} -gt 1300000000 ]; then\n    flag_template='Flagfile_ch%%%.mwaf'\nfi\nbirli \\\n  -f $flag_template \\\n  ...\n```\n\n### Comparison with Cotter\n\nThe following table shows how Birli options map onto Cotter options:\n\n| **Birli**                           | **Cotter**              | **Cotter Description**\n| ----------------------------------- | ----------------------- | ------\n| `--version`                         | `-version`              | Output version and exit.\n| `-m <PATH>`                         | `-m <filename>`         | Read meta data from given fits filename.\n| `-f`,`-u`,`-M`                      | `-o <filename>`         | Save output to given filename\n| `--no-rfi`                          | `-norfi`                | Disable RFI detection.\n| `--aoflagger-strategy <PATH>`       | `-flag-strategy <file>` | Use the specified aoflagger strategy.\n| `--no-cable-delay`                  | `-nocablelength`        | Do not perform cable length corrections.\n| `--no-geom`                         | `-nogeom`               | Disable geometric corrections.\n| `--phase-centre <RA> <DEC>`         | `-centre <ra> <dec>`    | Set alternative phase centre, e.g. -centre 00h00m00.0s 00d00m00.0s.\n| `--pointing-centre`                 | `-usepcentre`           | Centre on pointing centre.\n| `--avg-time-res <SECONDS>`          | `-timeres <s>`          | Average nr of sec of timesteps together before writing to measurement set.\n| `--avg-freq-res <KHZ>`              | `-freqres <kHz>`        | Average kHz bandwidth of channels together before writing to measurement set.\n| `--apply-di-cal <PATH>`             | `-full-apply <file>`    | Apply a solution file before averaging.\n| `--no-digital-gains`                | `-nosbgains`            | Do not correct for the digital gains.\n| `--max-memory` (WIP)                | `-absmem <gb>`          | Use at most the given amount of memory, specified in gigabytes.\n| `--flag-edge-width <kHz>`           | `-edgewidth <kHz>`      | Flag the given width of edge channels of each sub-band (default: 80 kHz).\n| `--flag-init <sec>`                 | `-initflag <sec>`       | Specify number of seconds to flag at beginning of observation (default: QUACK)\n| `--flag-end <sec>`                  | `-endflag <sec>`        | Specify number of seconds to flag extra at end of observation (default: 0s).\n| `--flag-dc`                         | `-flagdcchannels`       | Flag the centre channel of each sub-band (currently the default).\n| `--no-flag-dc`                      | `-noflagdcchannels`     | Do not flag the centre channel of each sub-band.\n| `--flag-antennae <ANTS>...` (WIP)   | `-flagantenna <lst>`    | Mark the comma-separated list of zero-indexed antennae as flagged antennae.\n| `--flag-coarse-chans <CHANS>` (WIP) | `-flagsubband <lst>`    | Flag the comma-separated list of zero-indexed sub-bands.\n| `--no-sel-autos` (WIP)              | `-noautos`              | Do not output auto-correlations.\n| (not `--flag-autos`)                | `-noflagautos`          | Do not flag auto-correlations (default for uvfits file output).\n| (default)                           | `-nostats`              | Disable collecting statistics (default for uvfits file output).\n| (not `--no-sel-flagged-ants`, WIP)  | `-noantennapruning`     | Do not remove the flagged antennae.\n| (default)                           | `-allowmissing`         | Do not abort when not all GPU box files are available (default is to abort).\n\nBirli performs all the same default preprocessing steps as Cotter when no flags are provided. The exceptions are that we have not yet implemented flagging of auto-correlations, pruning of flagged antennas. This means that `birli <in/out args>` is equivalent to:\n\n```bash\n cotter \\\n  -allowmissing \\\n  -noantennapruning \\\n  -noflagautos \\\n  -nostats \\\n  -flag-strategy <mwa default aoflagger strategy>\n  <in/out args>\n```\n\nThere is no intention of replicating the following options Birli at this point, so please open an issue if these are important to you:\n\n- Coarse channel selection (`-sbcount`, `-sbstart`): This can be done by simply changing which coarse channel files are given in the CLI arguments)\n- Dysco compression (`-use-dysco`, `-dysco-config`)\n- Manual metadata specification (`-a`, `-h`, `-i`): This information is readily available from metafits.\n- `-offline-gpubox-format`\n- Quality statistics (`-saveqs`, `-histograms`, `-skipwrite`, `-nostats`)\n- `-noflagmissings`: If an HDU is missing, it should always be flagged.\n- `-apply`: only `-full-apply` is supported.\n- `-noalign`: gpuboxes are always aligned.\n- CPU limit (`-j`): Birli uses crossbeam for concurrency which intelligency uses the compute resources available. Strict resource limits can be achieved with cgroups.\n- Memory percentage limit (`-mem`): Only `-absmem` is supported. Determining memory limits on HPC systems is unreliable, so we recommend manually specifying a memory limit instead.\n- `-sbpassband <file>`\n- `-flagfiles <name>` apply existing flags\n\n### Example: RFI Flagging, corrections, averaging, output\n\nIn this example, we use the aoflagger subcommand to:\n\n- Perform RFI flagging using the MWA-default flagging strategy\n- Perform geometric and cable length corrections\n- average the data to 4 seconds, 160khz\n- Output visibilities to .uvfits (`-u`)\n\n```bash\nbirli \\\n  -m tests/data/1254670392_avg/1254670392.metafits \\\n  -f \"/tmp/Flagfile.Birli.MWA.%%.mwaf\" \\\n  -u \"/tmp/1254670392.birli.uvfits\" \\\n  --avg-time-res 4 --avg-freq-res 160 \\\n  tests/data/1254670392_avg/1254670392_*gpubox*.fits\n```\n\nThe equivalent Cotter\ncommands would be:\n\n```bash\n# output uvfits\ncotter \\\n  -m tests/data/1254670392_avg/1254670392.metafits \\\n  -o \"tests/data/1254670392_avg/1254670392.cotter.uvfits\" \\\n  -allowmissing \\\n  -noantennapruning \\\n  -noflagautos \\\n  -nostats \\\n  -timeres 4 \\\n  -freqres 160 \\\n  -flag-strategy /usr/local/share/aoflagger/strategies/mwa-default.lua \\\n  tests/data/1254670392_avg/1254670392_20191009153257_gpubox*.fits\n```\n\n## Contributing\n\nPull requests are welcome! Please do your best to ensure that the high standards\nof test coverage are maintained.\n\nBefore each commit, use `cargo make ci` to ensure your code is formatted correctly.\n\n## Acknowledgement\n\nThis scientific work uses data obtained from the Murchison Radio-astronomy Observatory. We\nacknowledge the Wajarri Yamatji people as the traditional owners of the Observatory site.\n\n## Coverage\n\n<a href=\"https://codecov.io/gh/MWATelescope/Birli\"><img src=\"https://codecov.io/gh/MWATelescope/Birli/branch/main/graphs/sunburst.svg\" height=\"200px\" alt=\"Birli logo\"></a>\n\nThis repo is approved by...\n\n<img src=\"https://github.com/MWATelescope/Birli/raw/main/img/CIRA_Rust_Evangelism_Strike_Force.png\" height=\"200px\" alt=\"CIRA Rust Evangelism Strike Force logo\">\n",
  "permissions": {
    "read": true,
    "write": false,
    "admin": false
  },
  "media_types": [
    "application/vnd.docker.container.image.v1+json"
  ],
  "content_types": [
    "image"
  ]
}