{
  "startTime": 1674251011795,
  "endTime": 1674251012057,
  "originalSmells": [
    {
      "rule": "aptGetInstallUseY",
      "position": {
        "lineStart": 121,
        "lineEnd": 121,
        "columnStart": 22,
        "columnEnd": 41
      }
    },
    {
      "rule": "aptGetInstallUseNoRec",
      "position": {
        "lineStart": 121,
        "lineEnd": 121,
        "columnStart": 22,
        "columnEnd": 41
      }
    },
    {
      "rule": "aptGetInstallThenRemoveAptLists",
      "position": {
        "lineStart": 121,
        "lineEnd": 121,
        "columnStart": 22,
        "columnEnd": 41
      }
    }
  ],
  "repairedSmells": [],
  "repairedDockerfile": "# Docker version 1.11.1\n#\n# Line blocks used for commenting start with a #.\n#\n# Default syntax is:\n# INSTRUCTION arguments\n#\n# INSTRUCTIONs are executed by order.\n\n# FROM\n#\n# It defines the base image to use to start the build process.\n# It can be any image.\n# If a FROM image is not found on the host, docker will try to find it (and download) from the docker image index.\n# It needs to be the first command declared inside a Dockerfile.\n#\n# Usage: FROM <image_name>:<tag>\n# Usage: FROM <image>@<digest>\nFROM ubuntu:15.10\n\n# MAINTAINER\n#\n# It can be set anywhere in the file.\n# This non-executing command declares the author of the image.\n# It should come nonetheless after FROM.\n#\n# Usage: MAINTAINER <name and/or email>\nMAINTAINER TheodorosPloumis <me@theodorosploumis.com>\n\n# ENV\n#\n# The ENV command is used to set the environment variables (one or more).\n# These variables consist of “key = value” pairs which can be accessed within the container by scripts and applications alike.\n# Unlike an ARG instruction, ENV values are always persisted in the built image.\n# We can use ENV variables using $VARIABLE for substitution.\n#\n# Usage: ENV key1 value1 key2 value2\n# Usage: ENV key1=value1 key2=value2\n# Usage with run: \"docker run --env <key>=<value>\"\nENV MEMORY 256M\n\n# ARG\n#\n# The ARG instruction defines a variable that users can pass at build-time to the builder\n# with the docker build command using the --build-arg <varname>=<value> flag.\n# If an ARG value has a default and if there is no value passed at build-time, the builder uses the default.\n# Environment variables defined using the ENV instruction always override an ARG instruction of the same name.\n# Docker has a set of predefined ARG variables that you can use without a corresponding ARG instruction in the Dockerfile.\n# Such as: HTTP_PROXY, HTTPS_PROXY, FTP_PROXY, NO_PROXY\n#\n# Usage: ARG <name>[=<default_value>]\n# Usage with run: \"docker run --build-arg <arg_name>=<value>\"\nARG PRESENTATION_NAME=\"Docker for Developers\"\n\n# LABEL\n#\n# The LABEL instruction adds metadata to an image.\n# A LABEL is a key-value pair.\n# To include spaces within a LABEL value, use quotes and backslashes as you would in cli parsing.\n#\n# Usage: LABEL key1 value1 key2 value2\n# Usage: LABEL key1=value1 key2=value2\n# Usage on the agent CLI: \"docker run --label <key>=<value>\"\nLABEL version=\"1.0\"\n\n# ADD\n#\n# The ADD command gets two arguments: a source and a destination.\n# It copies the files from the source on the host into the container's own filesystem at the set destination.\n# If, however, the source is a URL (e.g. http://github.com/user/file/), then the contents of the URL are downloaded and placed at the destination.\n#\n# Usage: ADD <source_directory or URL> <destination_directory>\nADD /add-local-folder /added-container-folder\n\n# STOPSIGNAL\n#\n# The STOPSIGNAL instruction sets the system call signal that will be sent to the container to exit.\n# This signal can be a valid unsigned number that matches a position in the kernel’s syscall table,\n# for instance 9, or a signal name in the format SIGNAME, for instance SIGKILL.\n# Usage: STOPSIGNAL <value>\nSTOPSIGNAL SIGTERM\n\n# EXPOSE\n#\n# The EXPOSE instruction informs Docker that the container listens on the specified network ports at runtime.\n# EXPOSE does not make the ports of the container accessible to the host.\n# To do that, you must use either the -p flag to publish a range of ports or the -P flag to publish all of the exposed ports.\n# You can expose one port number and publish it externally under another number.\n# To set up port redirection on the host system, see using the -P flag.\n#\n# Usage: EXPOSE <port1> <port2> ...\nEXPOSE 80 3306\n\n# COPY\n#\n# The COPY instruction copies new files or directories from <src> and\n# adds them to the filesystem of the container at the path <dest>.\n# Multiple <src> resource may be specified but they must be relative to the source directory\n# that is being built (the context of the build).\n# Each <src> may contain wildcards.\n#\n# Usahe: COPY <src>... <dest>\n# Usage: COPY [\"<src>\",... \"<dest>\"] (this form is required for paths containing whitespace)\nCOPY copy-local-folder /copied-container-folder\n\n# USER\n#\n# The USER instruction sets the USER name or UID to use when running the image and for\n# any RUN, CMD and ENTRYPOINT instructions that follow it in the Dockerfile.\n#\n# Usage: USER <UID or USER_NAME>\nUSER 1000\n\n# RUN\n#\n# The RUN instruction will execute any commands in a new layer on top of the current image\n# and commit the results, much like source control.\n# The resulting committed image will be used for the next step in the Dockerfile.\n#\n# Usage: RUN <command> (shell form, the command is run in a shell - /bin/sh -c)\n# Usage: RUN [\"executable\", \"param1\", \"param2\"] (exec form)\nRUN apt-get update && apt-get install -y --no-install-recommends vim && rm -rf /var/lib/apt/lists/*;\n\n# ONBUILD\n#\n# The ONBUILD instruction adds to the image a trigger instruction to be executed at a later time,\n# when the image is used as the base for another build.\n# The trigger will be executed in the context of the downstream build,\n# as if it had been inserted immediately after the FROM instruction in the downstream Dockerfile.\n# Triggers are cleared from the final image after being executed (not inherited by \"grand-children\" builds).\n#\n# Usage: ONBUILD [INSTRUCTION]\nONBUILD RUN echo \"This is ONBUILD.\"\n\n# VOLUME\n#\n# The VOLUME instruction creates a mount point with the specified name and\n# marks it as holding externally mounted volumes from native host or other containers.\n# The value can be a JSON array, VOLUME [\"/var/log/\"], or a plain string with multiple arguments,\n# such as VOLUME /var/log or VOLUME /var/log /var/db.\n# Paths can be ralative (to WORKDIR) or absolute.\n# Anything after the VOLUME instruction in a Dockerfile will not be able to make changes to that volume.\n# Data volumes are initialized when a container is created.\n# Data volumes can be shared and reused among containers.\n# Changes to a data volume are made directly.\n# Changes to a data volume will not be included when you update an image.\n# Data volumes persist even if the container itself is deleted.\n#\n# Usage: VOLUME [\"/dir_1\", \"/dir_2\", ...]\n# Usage: VOLUME /dir_1, /dir_2, ...\nVOLUME /added-container-folder /copied-container-folder\n\n# WORKDIR\n#\n# The WORKDIR instruction sets the working directory for any\n# RUN, CMD, ENTRYPOINT, COPY and ADD instructions that follow it in the Dockerfile.\n# It can be used multiple times in the one Dockerfile.\n# If a relative path is provided, it will be relative to the path of the previous WORKDIR instruction.\n#\n# Usage: WORKDIR /path/on/container\nWORKDIR /var/www/html\n\n# ENTRYPOINT\n#\n# An ENTRYPOINT allows you to configure a container that will run as an executable.\n# Command line arguments to docker run <image> will be appended after all elements in an exec form ENTRYPOINT,\n# and will override all elements specified using CMD.\n# You can override the ENTRYPOINT instruction using the \"docker run --entrypoint <command>\" flag.\n# Only the last ENTRYPOINT instruction in the Dockerfile will have an effect.\n# The default ENTRYPOINT is /bin/sh -c and CMD is passed into that as an argument.\n#\n# Usage: ENTRYPOINT [\"executable\", \"param1\", \"param2\"] #(exec form, preferred)\n# Usage: ENTRYPOINT command param1 param2 #(shell form)\nENTRYPOINT [\"top\", \"-b\"]\n\n# CMD\n#\n# There can only be one CMD instruction in a Dockerfile!\n# If you list more than one CMD then only the last CMD will take effect.\n# The main purpose of a CMD is to provide defaults for an executing container.\n# These defaults can include an executable, or they can omit the executable,\n# in which case you must specify an ENTRYPOINT instruction as well.\n#\n# Usage: CMD [\"executable\",\"param1\",\"param2\"] #(exec form, this is the preferred form)\n# Usege: CMD [\"param1\",\"param2\"] #(as default parameters to ENTRYPOINT)\n# Usage: CMD command param1 param2 #(shell form)\nCMD ls\n"
}